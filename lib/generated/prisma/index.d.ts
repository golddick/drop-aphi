
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model OTP
 * 
 */
export type OTP = $Result.DefaultSelection<Prisma.$OTPPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model ThirdPartyOTP
 * 
 */
export type ThirdPartyOTP = $Result.DefaultSelection<Prisma.$ThirdPartyOTPPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model Kyc
 * 
 */
export type Kyc = $Result.DefaultSelection<Prisma.$KycPayload>
/**
 * Model KYCDocument
 * 
 */
export type KYCDocument = $Result.DefaultSelection<Prisma.$KYCDocumentPayload>
/**
 * Model MembershipUsage
 * 
 */
export type MembershipUsage = $Result.DefaultSelection<Prisma.$MembershipUsagePayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model FlagedBlogPost
 * 
 */
export type FlagedBlogPost = $Result.DefaultSelection<Prisma.$FlagedBlogPostPayload>
/**
 * Model BlogPostView
 * 
 */
export type BlogPostView = $Result.DefaultSelection<Prisma.$BlogPostViewPayload>
/**
 * Model BlogCategory
 * 
 */
export type BlogCategory = $Result.DefaultSelection<Prisma.$BlogCategoryPayload>
/**
 * Model BlogTag
 * 
 */
export type BlogTag = $Result.DefaultSelection<Prisma.$BlogTagPayload>
/**
 * Model BlogComment
 * 
 */
export type BlogComment = $Result.DefaultSelection<Prisma.$BlogCommentPayload>
/**
 * Model ReportedComment
 * 
 */
export type ReportedComment = $Result.DefaultSelection<Prisma.$ReportedCommentPayload>
/**
 * Model BlogAIGeneration
 * 
 */
export type BlogAIGeneration = $Result.DefaultSelection<Prisma.$BlogAIGenerationPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model Subscriber
 * 
 */
export type Subscriber = $Result.DefaultSelection<Prisma.$SubscriberPayload>
/**
 * Model EmailNotification
 * 
 */
export type EmailNotification = $Result.DefaultSelection<Prisma.$EmailNotificationPayload>
/**
 * Model ClickedLink
 * 
 */
export type ClickedLink = $Result.DefaultSelection<Prisma.$ClickedLinkPayload>
/**
 * Model NotificationEmailClickedLink
 * 
 */
export type NotificationEmailClickedLink = $Result.DefaultSelection<Prisma.$NotificationEmailClickedLinkPayload>
/**
 * Model Email
 * 
 */
export type Email = $Result.DefaultSelection<Prisma.$EmailPayload>
/**
 * Model EmailElement
 * 
 */
export type EmailElement = $Result.DefaultSelection<Prisma.$EmailElementPayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model EmailAttachment
 * 
 */
export type EmailAttachment = $Result.DefaultSelection<Prisma.$EmailAttachmentPayload>
/**
 * Model EmailRecipient
 * 
 */
export type EmailRecipient = $Result.DefaultSelection<Prisma.$EmailRecipientPayload>
/**
 * Model EmailAnalytics
 * 
 */
export type EmailAnalytics = $Result.DefaultSelection<Prisma.$EmailAnalyticsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Plan: {
  FREE: 'FREE',
  LAUNCH: 'LAUNCH',
  SCALE: 'SCALE',
  ENTERPRISE: 'ENTERPRISE'
};

export type Plan = (typeof Plan)[keyof typeof Plan]


export const Role: {
  USER: 'USER',
  NEWSLETTEROWNER: 'NEWSLETTEROWNER',
  PLATFORMADMIN: 'PLATFORMADMIN',
  SUPERADMIN: 'SUPERADMIN',
  BLOGWRITER: 'BLOGWRITER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const PlanSubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  PAST_DUE: 'PAST_DUE',
  CANCELLED: 'CANCELLED'
};

export type PlanSubscriptionStatus = (typeof PlanSubscriptionStatus)[keyof typeof PlanSubscriptionStatus]


export const SubscriptionStatus: {
  SUBSCRIBED: 'SUBSCRIBED',
  UNSUBSCRIBED: 'UNSUBSCRIBED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const CampaignStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  ENDED: 'ENDED'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]


export const NotificationType: {
  EMAIL: 'EMAIL',
  SYSTEM: 'SYSTEM',
  PUSH: 'PUSH',
  SMS: 'SMS'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationCategory: {
  WELCOME: 'WELCOME',
  NEWSLETTER: 'NEWSLETTER',
  NEW_BLOG: 'NEW_BLOG',
  KYC_APPROVAL: 'KYC_APPROVAL',
  FLAGGED: 'FLAGGED',
  FLAGGED_RESOLVED: 'FLAGGED_RESOLVED'
};

export type NotificationCategory = (typeof NotificationCategory)[keyof typeof NotificationCategory]


export const NotificationStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  SENDING: 'SENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  FAILED: 'FAILED',
  READ: 'READ'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const NotificationPriority: {
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type NotificationPriority = (typeof NotificationPriority)[keyof typeof NotificationPriority]


export const PostStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED',
  SCHEDULED: 'SCHEDULED'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const FlagStatus: {
  FLAGGED: 'FLAGGED',
  RESOLVED: 'RESOLVED'
};

export type FlagStatus = (typeof FlagStatus)[keyof typeof FlagStatus]


export const PostVisibility: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE',
  MEMBERS_ONLY: 'MEMBERS_ONLY'
};

export type PostVisibility = (typeof PostVisibility)[keyof typeof PostVisibility]


export const ContentFormat: {
  MARKDOWN: 'MARKDOWN',
  HTML: 'HTML',
  RICH_TEXT: 'RICH_TEXT'
};

export type ContentFormat = (typeof ContentFormat)[keyof typeof ContentFormat]


export const AIGenerationStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  IN_PROGRESS: 'IN_PROGRESS'
};

export type AIGenerationStatus = (typeof AIGenerationStatus)[keyof typeof AIGenerationStatus]


export const KYCAccountType: {
  INDIVIDUAL: 'INDIVIDUAL',
  ORGANIZATION: 'ORGANIZATION'
};

export type KYCAccountType = (typeof KYCAccountType)[keyof typeof KYCAccountType]


export const AccountType: {
  INDIVIDUAL: 'INDIVIDUAL',
  ORGANIZATION: 'ORGANIZATION'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const KYCStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED',
  APPROVED: 'APPROVED',
  IN_PROGRESS: 'IN_PROGRESS'
};

export type KYCStatus = (typeof KYCStatus)[keyof typeof KYCStatus]


export const EmailStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  SENDING: 'SENDING',
  SENT: 'SENT',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type EmailStatus = (typeof EmailStatus)[keyof typeof EmailStatus]


export const EmailType: {
  BROADCAST: 'BROADCAST',
  TRANSACTIONAL: 'TRANSACTIONAL',
  NEWSLETTER: 'NEWSLETTER',
  CAMPAIGN: 'CAMPAIGN',
  AUTOMATION: 'AUTOMATION',
  TEST: 'TEST'
};

export type EmailType = (typeof EmailType)[keyof typeof EmailType]


export const ElementType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  BUTTON: 'BUTTON',
  SOCIAL: 'SOCIAL',
  DIVIDER: 'DIVIDER',
  COLUMNS: 'COLUMNS'
};

export type ElementType = (typeof ElementType)[keyof typeof ElementType]


export const RecipientStatus: {
  FAILED: 'FAILED',
  PENDING: 'PENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  OPENED: 'OPENED',
  CLICKED: 'CLICKED',
  BOUNCED: 'BOUNCED',
  UNSUBSCRIBED: 'UNSUBSCRIBED',
  COMPLAINED: 'COMPLAINED'
};

export type RecipientStatus = (typeof RecipientStatus)[keyof typeof RecipientStatus]

}

export type Plan = $Enums.Plan

export const Plan: typeof $Enums.Plan

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type PlanSubscriptionStatus = $Enums.PlanSubscriptionStatus

export const PlanSubscriptionStatus: typeof $Enums.PlanSubscriptionStatus

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationCategory = $Enums.NotificationCategory

export const NotificationCategory: typeof $Enums.NotificationCategory

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type NotificationPriority = $Enums.NotificationPriority

export const NotificationPriority: typeof $Enums.NotificationPriority

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type FlagStatus = $Enums.FlagStatus

export const FlagStatus: typeof $Enums.FlagStatus

export type PostVisibility = $Enums.PostVisibility

export const PostVisibility: typeof $Enums.PostVisibility

export type ContentFormat = $Enums.ContentFormat

export const ContentFormat: typeof $Enums.ContentFormat

export type AIGenerationStatus = $Enums.AIGenerationStatus

export const AIGenerationStatus: typeof $Enums.AIGenerationStatus

export type KYCAccountType = $Enums.KYCAccountType

export const KYCAccountType: typeof $Enums.KYCAccountType

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type KYCStatus = $Enums.KYCStatus

export const KYCStatus: typeof $Enums.KYCStatus

export type EmailStatus = $Enums.EmailStatus

export const EmailStatus: typeof $Enums.EmailStatus

export type EmailType = $Enums.EmailType

export const EmailType: typeof $Enums.EmailType

export type ElementType = $Enums.ElementType

export const ElementType: typeof $Enums.ElementType

export type RecipientStatus = $Enums.RecipientStatus

export const RecipientStatus: typeof $Enums.RecipientStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oTP`: Exposes CRUD operations for the **OTP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OTPS
    * const oTPS = await prisma.oTP.findMany()
    * ```
    */
  get oTP(): Prisma.OTPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.thirdPartyOTP`: Exposes CRUD operations for the **ThirdPartyOTP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThirdPartyOTPS
    * const thirdPartyOTPS = await prisma.thirdPartyOTP.findMany()
    * ```
    */
  get thirdPartyOTP(): Prisma.ThirdPartyOTPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kyc`: Exposes CRUD operations for the **Kyc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kycs
    * const kycs = await prisma.kyc.findMany()
    * ```
    */
  get kyc(): Prisma.KycDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kYCDocument`: Exposes CRUD operations for the **KYCDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KYCDocuments
    * const kYCDocuments = await prisma.kYCDocument.findMany()
    * ```
    */
  get kYCDocument(): Prisma.KYCDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membershipUsage`: Exposes CRUD operations for the **MembershipUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MembershipUsages
    * const membershipUsages = await prisma.membershipUsage.findMany()
    * ```
    */
  get membershipUsage(): Prisma.MembershipUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flagedBlogPost`: Exposes CRUD operations for the **FlagedBlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlagedBlogPosts
    * const flagedBlogPosts = await prisma.flagedBlogPost.findMany()
    * ```
    */
  get flagedBlogPost(): Prisma.FlagedBlogPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogPostView`: Exposes CRUD operations for the **BlogPostView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPostViews
    * const blogPostViews = await prisma.blogPostView.findMany()
    * ```
    */
  get blogPostView(): Prisma.BlogPostViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogCategory`: Exposes CRUD operations for the **BlogCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogCategories
    * const blogCategories = await prisma.blogCategory.findMany()
    * ```
    */
  get blogCategory(): Prisma.BlogCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogTag`: Exposes CRUD operations for the **BlogTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogTags
    * const blogTags = await prisma.blogTag.findMany()
    * ```
    */
  get blogTag(): Prisma.BlogTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogComment`: Exposes CRUD operations for the **BlogComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogComments
    * const blogComments = await prisma.blogComment.findMany()
    * ```
    */
  get blogComment(): Prisma.BlogCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportedComment`: Exposes CRUD operations for the **ReportedComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportedComments
    * const reportedComments = await prisma.reportedComment.findMany()
    * ```
    */
  get reportedComment(): Prisma.ReportedCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogAIGeneration`: Exposes CRUD operations for the **BlogAIGeneration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogAIGenerations
    * const blogAIGenerations = await prisma.blogAIGeneration.findMany()
    * ```
    */
  get blogAIGeneration(): Prisma.BlogAIGenerationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriber`: Exposes CRUD operations for the **Subscriber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscribers
    * const subscribers = await prisma.subscriber.findMany()
    * ```
    */
  get subscriber(): Prisma.SubscriberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailNotification`: Exposes CRUD operations for the **EmailNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailNotifications
    * const emailNotifications = await prisma.emailNotification.findMany()
    * ```
    */
  get emailNotification(): Prisma.EmailNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clickedLink`: Exposes CRUD operations for the **ClickedLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClickedLinks
    * const clickedLinks = await prisma.clickedLink.findMany()
    * ```
    */
  get clickedLink(): Prisma.ClickedLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationEmailClickedLink`: Exposes CRUD operations for the **NotificationEmailClickedLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationEmailClickedLinks
    * const notificationEmailClickedLinks = await prisma.notificationEmailClickedLink.findMany()
    * ```
    */
  get notificationEmailClickedLink(): Prisma.NotificationEmailClickedLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.email`: Exposes CRUD operations for the **Email** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emails
    * const emails = await prisma.email.findMany()
    * ```
    */
  get email(): Prisma.EmailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailElement`: Exposes CRUD operations for the **EmailElement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailElements
    * const emailElements = await prisma.emailElement.findMany()
    * ```
    */
  get emailElement(): Prisma.EmailElementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailAttachment`: Exposes CRUD operations for the **EmailAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAttachments
    * const emailAttachments = await prisma.emailAttachment.findMany()
    * ```
    */
  get emailAttachment(): Prisma.EmailAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailRecipient`: Exposes CRUD operations for the **EmailRecipient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailRecipients
    * const emailRecipients = await prisma.emailRecipient.findMany()
    * ```
    */
  get emailRecipient(): Prisma.EmailRecipientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailAnalytics`: Exposes CRUD operations for the **EmailAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAnalytics
    * const emailAnalytics = await prisma.emailAnalytics.findMany()
    * ```
    */
  get emailAnalytics(): Prisma.EmailAnalyticsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.0
   * Query Engine version: c0aafc03b8ef6cdced8654b9a817999e02457d6a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    RefreshToken: 'RefreshToken',
    OTP: 'OTP',
    Invoice: 'Invoice',
    ThirdPartyOTP: 'ThirdPartyOTP',
    ApiKey: 'ApiKey',
    Kyc: 'Kyc',
    KYCDocument: 'KYCDocument',
    MembershipUsage: 'MembershipUsage',
    BlogPost: 'BlogPost',
    FlagedBlogPost: 'FlagedBlogPost',
    BlogPostView: 'BlogPostView',
    BlogCategory: 'BlogCategory',
    BlogTag: 'BlogTag',
    BlogComment: 'BlogComment',
    ReportedComment: 'ReportedComment',
    BlogAIGeneration: 'BlogAIGeneration',
    Campaign: 'Campaign',
    Subscriber: 'Subscriber',
    EmailNotification: 'EmailNotification',
    ClickedLink: 'ClickedLink',
    NotificationEmailClickedLink: 'NotificationEmailClickedLink',
    Email: 'Email',
    EmailElement: 'EmailElement',
    EmailTemplate: 'EmailTemplate',
    EmailAttachment: 'EmailAttachment',
    EmailRecipient: 'EmailRecipient',
    EmailAnalytics: 'EmailAnalytics'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "refreshToken" | "oTP" | "invoice" | "thirdPartyOTP" | "apiKey" | "kyc" | "kYCDocument" | "membershipUsage" | "blogPost" | "flagedBlogPost" | "blogPostView" | "blogCategory" | "blogTag" | "blogComment" | "reportedComment" | "blogAIGeneration" | "campaign" | "subscriber" | "emailNotification" | "clickedLink" | "notificationEmailClickedLink" | "email" | "emailElement" | "emailTemplate" | "emailAttachment" | "emailRecipient" | "emailAnalytics"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      OTP: {
        payload: Prisma.$OTPPayload<ExtArgs>
        fields: Prisma.OTPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OTPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OTPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          findFirst: {
            args: Prisma.OTPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OTPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          findMany: {
            args: Prisma.OTPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          create: {
            args: Prisma.OTPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          createMany: {
            args: Prisma.OTPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OTPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          delete: {
            args: Prisma.OTPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          update: {
            args: Prisma.OTPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          deleteMany: {
            args: Prisma.OTPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OTPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OTPUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          upsert: {
            args: Prisma.OTPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          aggregate: {
            args: Prisma.OTPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOTP>
          }
          groupBy: {
            args: Prisma.OTPGroupByArgs<ExtArgs>
            result: $Utils.Optional<OTPGroupByOutputType>[]
          }
          count: {
            args: Prisma.OTPCountArgs<ExtArgs>
            result: $Utils.Optional<OTPCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      ThirdPartyOTP: {
        payload: Prisma.$ThirdPartyOTPPayload<ExtArgs>
        fields: Prisma.ThirdPartyOTPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThirdPartyOTPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThirdPartyOTPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThirdPartyOTPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThirdPartyOTPPayload>
          }
          findFirst: {
            args: Prisma.ThirdPartyOTPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThirdPartyOTPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThirdPartyOTPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThirdPartyOTPPayload>
          }
          findMany: {
            args: Prisma.ThirdPartyOTPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThirdPartyOTPPayload>[]
          }
          create: {
            args: Prisma.ThirdPartyOTPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThirdPartyOTPPayload>
          }
          createMany: {
            args: Prisma.ThirdPartyOTPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThirdPartyOTPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThirdPartyOTPPayload>[]
          }
          delete: {
            args: Prisma.ThirdPartyOTPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThirdPartyOTPPayload>
          }
          update: {
            args: Prisma.ThirdPartyOTPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThirdPartyOTPPayload>
          }
          deleteMany: {
            args: Prisma.ThirdPartyOTPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThirdPartyOTPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ThirdPartyOTPUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThirdPartyOTPPayload>[]
          }
          upsert: {
            args: Prisma.ThirdPartyOTPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThirdPartyOTPPayload>
          }
          aggregate: {
            args: Prisma.ThirdPartyOTPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThirdPartyOTP>
          }
          groupBy: {
            args: Prisma.ThirdPartyOTPGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThirdPartyOTPGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThirdPartyOTPCountArgs<ExtArgs>
            result: $Utils.Optional<ThirdPartyOTPCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      Kyc: {
        payload: Prisma.$KycPayload<ExtArgs>
        fields: Prisma.KycFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KycFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KycFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycPayload>
          }
          findFirst: {
            args: Prisma.KycFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KycFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycPayload>
          }
          findMany: {
            args: Prisma.KycFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycPayload>[]
          }
          create: {
            args: Prisma.KycCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycPayload>
          }
          createMany: {
            args: Prisma.KycCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KycCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycPayload>[]
          }
          delete: {
            args: Prisma.KycDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycPayload>
          }
          update: {
            args: Prisma.KycUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycPayload>
          }
          deleteMany: {
            args: Prisma.KycDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KycUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KycUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycPayload>[]
          }
          upsert: {
            args: Prisma.KycUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycPayload>
          }
          aggregate: {
            args: Prisma.KycAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKyc>
          }
          groupBy: {
            args: Prisma.KycGroupByArgs<ExtArgs>
            result: $Utils.Optional<KycGroupByOutputType>[]
          }
          count: {
            args: Prisma.KycCountArgs<ExtArgs>
            result: $Utils.Optional<KycCountAggregateOutputType> | number
          }
        }
      }
      KYCDocument: {
        payload: Prisma.$KYCDocumentPayload<ExtArgs>
        fields: Prisma.KYCDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KYCDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KYCDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>
          }
          findFirst: {
            args: Prisma.KYCDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KYCDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>
          }
          findMany: {
            args: Prisma.KYCDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>[]
          }
          create: {
            args: Prisma.KYCDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>
          }
          createMany: {
            args: Prisma.KYCDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KYCDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>[]
          }
          delete: {
            args: Prisma.KYCDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>
          }
          update: {
            args: Prisma.KYCDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>
          }
          deleteMany: {
            args: Prisma.KYCDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KYCDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KYCDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>[]
          }
          upsert: {
            args: Prisma.KYCDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>
          }
          aggregate: {
            args: Prisma.KYCDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKYCDocument>
          }
          groupBy: {
            args: Prisma.KYCDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<KYCDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.KYCDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<KYCDocumentCountAggregateOutputType> | number
          }
        }
      }
      MembershipUsage: {
        payload: Prisma.$MembershipUsagePayload<ExtArgs>
        fields: Prisma.MembershipUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUsagePayload>
          }
          findFirst: {
            args: Prisma.MembershipUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUsagePayload>
          }
          findMany: {
            args: Prisma.MembershipUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUsagePayload>[]
          }
          create: {
            args: Prisma.MembershipUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUsagePayload>
          }
          createMany: {
            args: Prisma.MembershipUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUsagePayload>[]
          }
          delete: {
            args: Prisma.MembershipUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUsagePayload>
          }
          update: {
            args: Prisma.MembershipUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUsagePayload>
          }
          deleteMany: {
            args: Prisma.MembershipUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MembershipUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUsagePayload>[]
          }
          upsert: {
            args: Prisma.MembershipUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUsagePayload>
          }
          aggregate: {
            args: Prisma.MembershipUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembershipUsage>
          }
          groupBy: {
            args: Prisma.MembershipUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipUsageCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipUsageCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      FlagedBlogPost: {
        payload: Prisma.$FlagedBlogPostPayload<ExtArgs>
        fields: Prisma.FlagedBlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlagedBlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagedBlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlagedBlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagedBlogPostPayload>
          }
          findFirst: {
            args: Prisma.FlagedBlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagedBlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlagedBlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagedBlogPostPayload>
          }
          findMany: {
            args: Prisma.FlagedBlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagedBlogPostPayload>[]
          }
          create: {
            args: Prisma.FlagedBlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagedBlogPostPayload>
          }
          createMany: {
            args: Prisma.FlagedBlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlagedBlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagedBlogPostPayload>[]
          }
          delete: {
            args: Prisma.FlagedBlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagedBlogPostPayload>
          }
          update: {
            args: Prisma.FlagedBlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagedBlogPostPayload>
          }
          deleteMany: {
            args: Prisma.FlagedBlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlagedBlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlagedBlogPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagedBlogPostPayload>[]
          }
          upsert: {
            args: Prisma.FlagedBlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagedBlogPostPayload>
          }
          aggregate: {
            args: Prisma.FlagedBlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlagedBlogPost>
          }
          groupBy: {
            args: Prisma.FlagedBlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlagedBlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlagedBlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<FlagedBlogPostCountAggregateOutputType> | number
          }
        }
      }
      BlogPostView: {
        payload: Prisma.$BlogPostViewPayload<ExtArgs>
        fields: Prisma.BlogPostViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostViewPayload>
          }
          findFirst: {
            args: Prisma.BlogPostViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostViewPayload>
          }
          findMany: {
            args: Prisma.BlogPostViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostViewPayload>[]
          }
          create: {
            args: Prisma.BlogPostViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostViewPayload>
          }
          createMany: {
            args: Prisma.BlogPostViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostViewPayload>[]
          }
          delete: {
            args: Prisma.BlogPostViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostViewPayload>
          }
          update: {
            args: Prisma.BlogPostViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostViewPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogPostViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostViewPayload>[]
          }
          upsert: {
            args: Prisma.BlogPostViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostViewPayload>
          }
          aggregate: {
            args: Prisma.BlogPostViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPostView>
          }
          groupBy: {
            args: Prisma.BlogPostViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostViewCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostViewCountAggregateOutputType> | number
          }
        }
      }
      BlogCategory: {
        payload: Prisma.$BlogCategoryPayload<ExtArgs>
        fields: Prisma.BlogCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>
          }
          findFirst: {
            args: Prisma.BlogCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>
          }
          findMany: {
            args: Prisma.BlogCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>[]
          }
          create: {
            args: Prisma.BlogCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>
          }
          createMany: {
            args: Prisma.BlogCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>[]
          }
          delete: {
            args: Prisma.BlogCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>
          }
          update: {
            args: Prisma.BlogCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>
          }
          deleteMany: {
            args: Prisma.BlogCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>[]
          }
          upsert: {
            args: Prisma.BlogCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>
          }
          aggregate: {
            args: Prisma.BlogCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogCategory>
          }
          groupBy: {
            args: Prisma.BlogCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCategoryCountAggregateOutputType> | number
          }
        }
      }
      BlogTag: {
        payload: Prisma.$BlogTagPayload<ExtArgs>
        fields: Prisma.BlogTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          findFirst: {
            args: Prisma.BlogTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          findMany: {
            args: Prisma.BlogTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          create: {
            args: Prisma.BlogTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          createMany: {
            args: Prisma.BlogTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          delete: {
            args: Prisma.BlogTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          update: {
            args: Prisma.BlogTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          deleteMany: {
            args: Prisma.BlogTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          upsert: {
            args: Prisma.BlogTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          aggregate: {
            args: Prisma.BlogTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogTag>
          }
          groupBy: {
            args: Prisma.BlogTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogTagCountArgs<ExtArgs>
            result: $Utils.Optional<BlogTagCountAggregateOutputType> | number
          }
        }
      }
      BlogComment: {
        payload: Prisma.$BlogCommentPayload<ExtArgs>
        fields: Prisma.BlogCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          findFirst: {
            args: Prisma.BlogCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          findMany: {
            args: Prisma.BlogCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>[]
          }
          create: {
            args: Prisma.BlogCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          createMany: {
            args: Prisma.BlogCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>[]
          }
          delete: {
            args: Prisma.BlogCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          update: {
            args: Prisma.BlogCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          deleteMany: {
            args: Prisma.BlogCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>[]
          }
          upsert: {
            args: Prisma.BlogCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCommentPayload>
          }
          aggregate: {
            args: Prisma.BlogCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogComment>
          }
          groupBy: {
            args: Prisma.BlogCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogCommentCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCommentCountAggregateOutputType> | number
          }
        }
      }
      ReportedComment: {
        payload: Prisma.$ReportedCommentPayload<ExtArgs>
        fields: Prisma.ReportedCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportedCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportedCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportedCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportedCommentPayload>
          }
          findFirst: {
            args: Prisma.ReportedCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportedCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportedCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportedCommentPayload>
          }
          findMany: {
            args: Prisma.ReportedCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportedCommentPayload>[]
          }
          create: {
            args: Prisma.ReportedCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportedCommentPayload>
          }
          createMany: {
            args: Prisma.ReportedCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportedCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportedCommentPayload>[]
          }
          delete: {
            args: Prisma.ReportedCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportedCommentPayload>
          }
          update: {
            args: Prisma.ReportedCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportedCommentPayload>
          }
          deleteMany: {
            args: Prisma.ReportedCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportedCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportedCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportedCommentPayload>[]
          }
          upsert: {
            args: Prisma.ReportedCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportedCommentPayload>
          }
          aggregate: {
            args: Prisma.ReportedCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportedComment>
          }
          groupBy: {
            args: Prisma.ReportedCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportedCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportedCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ReportedCommentCountAggregateOutputType> | number
          }
        }
      }
      BlogAIGeneration: {
        payload: Prisma.$BlogAIGenerationPayload<ExtArgs>
        fields: Prisma.BlogAIGenerationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogAIGenerationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogAIGenerationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogAIGenerationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogAIGenerationPayload>
          }
          findFirst: {
            args: Prisma.BlogAIGenerationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogAIGenerationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogAIGenerationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogAIGenerationPayload>
          }
          findMany: {
            args: Prisma.BlogAIGenerationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogAIGenerationPayload>[]
          }
          create: {
            args: Prisma.BlogAIGenerationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogAIGenerationPayload>
          }
          createMany: {
            args: Prisma.BlogAIGenerationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogAIGenerationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogAIGenerationPayload>[]
          }
          delete: {
            args: Prisma.BlogAIGenerationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogAIGenerationPayload>
          }
          update: {
            args: Prisma.BlogAIGenerationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogAIGenerationPayload>
          }
          deleteMany: {
            args: Prisma.BlogAIGenerationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogAIGenerationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogAIGenerationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogAIGenerationPayload>[]
          }
          upsert: {
            args: Prisma.BlogAIGenerationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogAIGenerationPayload>
          }
          aggregate: {
            args: Prisma.BlogAIGenerationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogAIGeneration>
          }
          groupBy: {
            args: Prisma.BlogAIGenerationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogAIGenerationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogAIGenerationCountArgs<ExtArgs>
            result: $Utils.Optional<BlogAIGenerationCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      Subscriber: {
        payload: Prisma.$SubscriberPayload<ExtArgs>
        fields: Prisma.SubscriberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          findFirst: {
            args: Prisma.SubscriberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          findMany: {
            args: Prisma.SubscriberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
          }
          create: {
            args: Prisma.SubscriberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          createMany: {
            args: Prisma.SubscriberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
          }
          delete: {
            args: Prisma.SubscriberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          update: {
            args: Prisma.SubscriberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          deleteMany: {
            args: Prisma.SubscriberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
          }
          upsert: {
            args: Prisma.SubscriberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          aggregate: {
            args: Prisma.SubscriberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriber>
          }
          groupBy: {
            args: Prisma.SubscriberGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriberGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriberCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriberCountAggregateOutputType> | number
          }
        }
      }
      EmailNotification: {
        payload: Prisma.$EmailNotificationPayload<ExtArgs>
        fields: Prisma.EmailNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          findFirst: {
            args: Prisma.EmailNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          findMany: {
            args: Prisma.EmailNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>[]
          }
          create: {
            args: Prisma.EmailNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          createMany: {
            args: Prisma.EmailNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>[]
          }
          delete: {
            args: Prisma.EmailNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          update: {
            args: Prisma.EmailNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          deleteMany: {
            args: Prisma.EmailNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>[]
          }
          upsert: {
            args: Prisma.EmailNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          aggregate: {
            args: Prisma.EmailNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailNotification>
          }
          groupBy: {
            args: Prisma.EmailNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<EmailNotificationCountAggregateOutputType> | number
          }
        }
      }
      ClickedLink: {
        payload: Prisma.$ClickedLinkPayload<ExtArgs>
        fields: Prisma.ClickedLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClickedLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickedLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClickedLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickedLinkPayload>
          }
          findFirst: {
            args: Prisma.ClickedLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickedLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClickedLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickedLinkPayload>
          }
          findMany: {
            args: Prisma.ClickedLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickedLinkPayload>[]
          }
          create: {
            args: Prisma.ClickedLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickedLinkPayload>
          }
          createMany: {
            args: Prisma.ClickedLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClickedLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickedLinkPayload>[]
          }
          delete: {
            args: Prisma.ClickedLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickedLinkPayload>
          }
          update: {
            args: Prisma.ClickedLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickedLinkPayload>
          }
          deleteMany: {
            args: Prisma.ClickedLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClickedLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClickedLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickedLinkPayload>[]
          }
          upsert: {
            args: Prisma.ClickedLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickedLinkPayload>
          }
          aggregate: {
            args: Prisma.ClickedLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClickedLink>
          }
          groupBy: {
            args: Prisma.ClickedLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClickedLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClickedLinkCountArgs<ExtArgs>
            result: $Utils.Optional<ClickedLinkCountAggregateOutputType> | number
          }
        }
      }
      NotificationEmailClickedLink: {
        payload: Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>
        fields: Prisma.NotificationEmailClickedLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationEmailClickedLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEmailClickedLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationEmailClickedLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEmailClickedLinkPayload>
          }
          findFirst: {
            args: Prisma.NotificationEmailClickedLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEmailClickedLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationEmailClickedLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEmailClickedLinkPayload>
          }
          findMany: {
            args: Prisma.NotificationEmailClickedLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEmailClickedLinkPayload>[]
          }
          create: {
            args: Prisma.NotificationEmailClickedLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEmailClickedLinkPayload>
          }
          createMany: {
            args: Prisma.NotificationEmailClickedLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationEmailClickedLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEmailClickedLinkPayload>[]
          }
          delete: {
            args: Prisma.NotificationEmailClickedLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEmailClickedLinkPayload>
          }
          update: {
            args: Prisma.NotificationEmailClickedLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEmailClickedLinkPayload>
          }
          deleteMany: {
            args: Prisma.NotificationEmailClickedLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationEmailClickedLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationEmailClickedLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEmailClickedLinkPayload>[]
          }
          upsert: {
            args: Prisma.NotificationEmailClickedLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEmailClickedLinkPayload>
          }
          aggregate: {
            args: Prisma.NotificationEmailClickedLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationEmailClickedLink>
          }
          groupBy: {
            args: Prisma.NotificationEmailClickedLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationEmailClickedLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationEmailClickedLinkCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationEmailClickedLinkCountAggregateOutputType> | number
          }
        }
      }
      Email: {
        payload: Prisma.$EmailPayload<ExtArgs>
        fields: Prisma.EmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findFirst: {
            args: Prisma.EmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findMany: {
            args: Prisma.EmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>[]
          }
          create: {
            args: Prisma.EmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          createMany: {
            args: Prisma.EmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>[]
          }
          delete: {
            args: Prisma.EmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          update: {
            args: Prisma.EmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          deleteMany: {
            args: Prisma.EmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>[]
          }
          upsert: {
            args: Prisma.EmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          aggregate: {
            args: Prisma.EmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail>
          }
          groupBy: {
            args: Prisma.EmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailCountArgs<ExtArgs>
            result: $Utils.Optional<EmailCountAggregateOutputType> | number
          }
        }
      }
      EmailElement: {
        payload: Prisma.$EmailElementPayload<ExtArgs>
        fields: Prisma.EmailElementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailElementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailElementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailElementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailElementPayload>
          }
          findFirst: {
            args: Prisma.EmailElementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailElementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailElementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailElementPayload>
          }
          findMany: {
            args: Prisma.EmailElementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailElementPayload>[]
          }
          create: {
            args: Prisma.EmailElementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailElementPayload>
          }
          createMany: {
            args: Prisma.EmailElementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailElementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailElementPayload>[]
          }
          delete: {
            args: Prisma.EmailElementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailElementPayload>
          }
          update: {
            args: Prisma.EmailElementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailElementPayload>
          }
          deleteMany: {
            args: Prisma.EmailElementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailElementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailElementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailElementPayload>[]
          }
          upsert: {
            args: Prisma.EmailElementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailElementPayload>
          }
          aggregate: {
            args: Prisma.EmailElementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailElement>
          }
          groupBy: {
            args: Prisma.EmailElementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailElementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailElementCountArgs<ExtArgs>
            result: $Utils.Optional<EmailElementCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      EmailAttachment: {
        payload: Prisma.$EmailAttachmentPayload<ExtArgs>
        fields: Prisma.EmailAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          findFirst: {
            args: Prisma.EmailAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          findMany: {
            args: Prisma.EmailAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>[]
          }
          create: {
            args: Prisma.EmailAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          createMany: {
            args: Prisma.EmailAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>[]
          }
          delete: {
            args: Prisma.EmailAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          update: {
            args: Prisma.EmailAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.EmailAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.EmailAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          aggregate: {
            args: Prisma.EmailAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailAttachment>
          }
          groupBy: {
            args: Prisma.EmailAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<EmailAttachmentCountAggregateOutputType> | number
          }
        }
      }
      EmailRecipient: {
        payload: Prisma.$EmailRecipientPayload<ExtArgs>
        fields: Prisma.EmailRecipientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailRecipientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailRecipientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailRecipientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailRecipientPayload>
          }
          findFirst: {
            args: Prisma.EmailRecipientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailRecipientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailRecipientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailRecipientPayload>
          }
          findMany: {
            args: Prisma.EmailRecipientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailRecipientPayload>[]
          }
          create: {
            args: Prisma.EmailRecipientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailRecipientPayload>
          }
          createMany: {
            args: Prisma.EmailRecipientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailRecipientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailRecipientPayload>[]
          }
          delete: {
            args: Prisma.EmailRecipientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailRecipientPayload>
          }
          update: {
            args: Prisma.EmailRecipientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailRecipientPayload>
          }
          deleteMany: {
            args: Prisma.EmailRecipientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailRecipientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailRecipientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailRecipientPayload>[]
          }
          upsert: {
            args: Prisma.EmailRecipientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailRecipientPayload>
          }
          aggregate: {
            args: Prisma.EmailRecipientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailRecipient>
          }
          groupBy: {
            args: Prisma.EmailRecipientGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailRecipientGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailRecipientCountArgs<ExtArgs>
            result: $Utils.Optional<EmailRecipientCountAggregateOutputType> | number
          }
        }
      }
      EmailAnalytics: {
        payload: Prisma.$EmailAnalyticsPayload<ExtArgs>
        fields: Prisma.EmailAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.EmailAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAnalyticsPayload>
          }
          findMany: {
            args: Prisma.EmailAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAnalyticsPayload>[]
          }
          create: {
            args: Prisma.EmailAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAnalyticsPayload>
          }
          createMany: {
            args: Prisma.EmailAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.EmailAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAnalyticsPayload>
          }
          update: {
            args: Prisma.EmailAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.EmailAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.EmailAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.EmailAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailAnalytics>
          }
          groupBy: {
            args: Prisma.EmailAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<EmailAnalyticsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    oTP?: OTPOmit
    invoice?: InvoiceOmit
    thirdPartyOTP?: ThirdPartyOTPOmit
    apiKey?: ApiKeyOmit
    kyc?: KycOmit
    kYCDocument?: KYCDocumentOmit
    membershipUsage?: MembershipUsageOmit
    blogPost?: BlogPostOmit
    flagedBlogPost?: FlagedBlogPostOmit
    blogPostView?: BlogPostViewOmit
    blogCategory?: BlogCategoryOmit
    blogTag?: BlogTagOmit
    blogComment?: BlogCommentOmit
    reportedComment?: ReportedCommentOmit
    blogAIGeneration?: BlogAIGenerationOmit
    campaign?: CampaignOmit
    subscriber?: SubscriberOmit
    emailNotification?: EmailNotificationOmit
    clickedLink?: ClickedLinkOmit
    notificationEmailClickedLink?: NotificationEmailClickedLinkOmit
    email?: EmailOmit
    emailElement?: EmailElementOmit
    emailTemplate?: EmailTemplateOmit
    emailAttachment?: EmailAttachmentOmit
    emailRecipient?: EmailRecipientOmit
    emailAnalytics?: EmailAnalyticsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    apiKeys: number
    aIContentGenerationToExcerpt: number
    blogComments: number
    blogPosts: number
    postViews: number
    emails: number
    flagedPosts: number
    invoices: number
    usage: number
    notificationEmails: number
    tokens: number
    reportedComments: number
    template: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
    aIContentGenerationToExcerpt?: boolean | UserCountOutputTypeCountAIContentGenerationToExcerptArgs
    blogComments?: boolean | UserCountOutputTypeCountBlogCommentsArgs
    blogPosts?: boolean | UserCountOutputTypeCountBlogPostsArgs
    postViews?: boolean | UserCountOutputTypeCountPostViewsArgs
    emails?: boolean | UserCountOutputTypeCountEmailsArgs
    flagedPosts?: boolean | UserCountOutputTypeCountFlagedPostsArgs
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    usage?: boolean | UserCountOutputTypeCountUsageArgs
    notificationEmails?: boolean | UserCountOutputTypeCountNotificationEmailsArgs
    tokens?: boolean | UserCountOutputTypeCountTokensArgs
    reportedComments?: boolean | UserCountOutputTypeCountReportedCommentsArgs
    template?: boolean | UserCountOutputTypeCountTemplateArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAIContentGenerationToExcerptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogAIGenerationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostViewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFlagedPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagedBlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportedCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportedCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
  }


  /**
   * Count Type KycCountOutputType
   */

  export type KycCountOutputType = {
    kycDocuments: number
  }

  export type KycCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kycDocuments?: boolean | KycCountOutputTypeCountKycDocumentsArgs
  }

  // Custom InputTypes
  /**
   * KycCountOutputType without action
   */
  export type KycCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycCountOutputType
     */
    select?: KycCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KycCountOutputType without action
   */
  export type KycCountOutputTypeCountKycDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KYCDocumentWhereInput
  }


  /**
   * Count Type BlogPostCountOutputType
   */

  export type BlogPostCountOutputType = {
    comments: number
    viewsCount: number
    flaggedPosts: number
    tags: number
  }

  export type BlogPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | BlogPostCountOutputTypeCountCommentsArgs
    viewsCount?: boolean | BlogPostCountOutputTypeCountViewsCountArgs
    flaggedPosts?: boolean | BlogPostCountOutputTypeCountFlaggedPostsArgs
    tags?: boolean | BlogPostCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostCountOutputType
     */
    select?: BlogPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCommentWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountViewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostViewWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountFlaggedPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagedBlogPostWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogTagWhereInput
  }


  /**
   * Count Type BlogCategoryCountOutputType
   */

  export type BlogCategoryCountOutputType = {
    posts: number
  }

  export type BlogCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | BlogCategoryCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * BlogCategoryCountOutputType without action
   */
  export type BlogCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategoryCountOutputType
     */
    select?: BlogCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogCategoryCountOutputType without action
   */
  export type BlogCategoryCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }


  /**
   * Count Type BlogTagCountOutputType
   */

  export type BlogTagCountOutputType = {
    posts: number
  }

  export type BlogTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | BlogTagCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * BlogTagCountOutputType without action
   */
  export type BlogTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTagCountOutputType
     */
    select?: BlogTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogTagCountOutputType without action
   */
  export type BlogTagCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }


  /**
   * Count Type BlogCommentCountOutputType
   */

  export type BlogCommentCountOutputType = {
    replies: number
    reportedComments: number
  }

  export type BlogCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | BlogCommentCountOutputTypeCountRepliesArgs
    reportedComments?: boolean | BlogCommentCountOutputTypeCountReportedCommentsArgs
  }

  // Custom InputTypes
  /**
   * BlogCommentCountOutputType without action
   */
  export type BlogCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCommentCountOutputType
     */
    select?: BlogCommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogCommentCountOutputType without action
   */
  export type BlogCommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCommentWhereInput
  }

  /**
   * BlogCommentCountOutputType without action
   */
  export type BlogCommentCountOutputTypeCountReportedCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportedCommentWhereInput
  }


  /**
   * Count Type BlogAIGenerationCountOutputType
   */

  export type BlogAIGenerationCountOutputType = {
    blogPosts: number
  }

  export type BlogAIGenerationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPosts?: boolean | BlogAIGenerationCountOutputTypeCountBlogPostsArgs
  }

  // Custom InputTypes
  /**
   * BlogAIGenerationCountOutputType without action
   */
  export type BlogAIGenerationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGenerationCountOutputType
     */
    select?: BlogAIGenerationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogAIGenerationCountOutputType without action
   */
  export type BlogAIGenerationCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    emails: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emails?: boolean | CampaignCountOutputTypeCountEmailsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
  }


  /**
   * Count Type EmailNotificationCountOutputType
   */

  export type EmailNotificationCountOutputType = {
    NotificationEmailClickedLink: number
  }

  export type EmailNotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NotificationEmailClickedLink?: boolean | EmailNotificationCountOutputTypeCountNotificationEmailClickedLinkArgs
  }

  // Custom InputTypes
  /**
   * EmailNotificationCountOutputType without action
   */
  export type EmailNotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotificationCountOutputType
     */
    select?: EmailNotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailNotificationCountOutputType without action
   */
  export type EmailNotificationCountOutputTypeCountNotificationEmailClickedLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationEmailClickedLinkWhereInput
  }


  /**
   * Count Type EmailCountOutputType
   */

  export type EmailCountOutputType = {
    elements: number
    clickedLinks: number
    emailAttachments: number
    emailRecipients: number
  }

  export type EmailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    elements?: boolean | EmailCountOutputTypeCountElementsArgs
    clickedLinks?: boolean | EmailCountOutputTypeCountClickedLinksArgs
    emailAttachments?: boolean | EmailCountOutputTypeCountEmailAttachmentsArgs
    emailRecipients?: boolean | EmailCountOutputTypeCountEmailRecipientsArgs
  }

  // Custom InputTypes
  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCountOutputType
     */
    select?: EmailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeCountElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailElementWhereInput
  }

  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeCountClickedLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClickedLinkWhereInput
  }

  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeCountEmailAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAttachmentWhereInput
  }

  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeCountEmailRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailRecipientWhereInput
  }


  /**
   * Count Type EmailTemplateCountOutputType
   */

  export type EmailTemplateCountOutputType = {
    emails: number
  }

  export type EmailTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emails?: boolean | EmailTemplateCountOutputTypeCountEmailsArgs
  }

  // Custom InputTypes
  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplateCountOutputType
     */
    select?: EmailTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    amount: number | null
    successfulPayments: number | null
    failedAttempts: number | null
    subscriberLimit: number | null
    emailLimit: number | null
    blogPostLimit: number | null
    aiGenerationLimit: number | null
  }

  export type UserSumAggregateOutputType = {
    amount: number | null
    successfulPayments: number | null
    failedAttempts: number | null
    subscriberLimit: number | null
    emailLimit: number | null
    blogPostLimit: number | null
    aiGenerationLimit: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    fullName: string | null
    userName: string | null
    password: string | null
    imageUrl: string | null
    paystackCustomerId: string | null
    paystackSubscriptionId: string | null
    plan: $Enums.Plan | null
    role: $Enums.Role | null
    subscriptionStatus: $Enums.PlanSubscriptionStatus | null
    accType: $Enums.AccountType | null
    currentPeriodEnd: Date | null
    organization: string | null
    website: string | null
    kycStatus: $Enums.KYCStatus | null
    SenderName: string | null
    amount: number | null
    currency: string | null
    lastPaymentDate: Date | null
    nextPaymentDate: Date | null
    successfulPayments: number | null
    failedAttempts: number | null
    subscriberLimit: number | null
    emailLimit: number | null
    blogPostLimit: number | null
    aiGenerationLimit: number | null
    termsAndConditionsAccepted: boolean | null
    approvedKYC: boolean | null
    isEmailVerified: boolean | null
    isLoggedIn: boolean | null
    is2FAEnabled: boolean | null
    createdAt: Date | null
    loggedInAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    fullName: string | null
    userName: string | null
    password: string | null
    imageUrl: string | null
    paystackCustomerId: string | null
    paystackSubscriptionId: string | null
    plan: $Enums.Plan | null
    role: $Enums.Role | null
    subscriptionStatus: $Enums.PlanSubscriptionStatus | null
    accType: $Enums.AccountType | null
    currentPeriodEnd: Date | null
    organization: string | null
    website: string | null
    kycStatus: $Enums.KYCStatus | null
    SenderName: string | null
    amount: number | null
    currency: string | null
    lastPaymentDate: Date | null
    nextPaymentDate: Date | null
    successfulPayments: number | null
    failedAttempts: number | null
    subscriberLimit: number | null
    emailLimit: number | null
    blogPostLimit: number | null
    aiGenerationLimit: number | null
    termsAndConditionsAccepted: boolean | null
    approvedKYC: boolean | null
    isEmailVerified: boolean | null
    isLoggedIn: boolean | null
    is2FAEnabled: boolean | null
    createdAt: Date | null
    loggedInAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    fullName: number
    userName: number
    password: number
    imageUrl: number
    paystackCustomerId: number
    paystackSubscriptionId: number
    plan: number
    role: number
    subscriptionStatus: number
    accType: number
    currentPeriodEnd: number
    organization: number
    website: number
    kycStatus: number
    SenderName: number
    amount: number
    currency: number
    lastPaymentDate: number
    nextPaymentDate: number
    successfulPayments: number
    failedAttempts: number
    subscriberLimit: number
    emailLimit: number
    blogPostLimit: number
    aiGenerationLimit: number
    termsAndConditionsAccepted: number
    approvedKYC: number
    isEmailVerified: number
    isLoggedIn: number
    is2FAEnabled: number
    createdAt: number
    loggedInAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    amount?: true
    successfulPayments?: true
    failedAttempts?: true
    subscriberLimit?: true
    emailLimit?: true
    blogPostLimit?: true
    aiGenerationLimit?: true
  }

  export type UserSumAggregateInputType = {
    amount?: true
    successfulPayments?: true
    failedAttempts?: true
    subscriberLimit?: true
    emailLimit?: true
    blogPostLimit?: true
    aiGenerationLimit?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    fullName?: true
    userName?: true
    password?: true
    imageUrl?: true
    paystackCustomerId?: true
    paystackSubscriptionId?: true
    plan?: true
    role?: true
    subscriptionStatus?: true
    accType?: true
    currentPeriodEnd?: true
    organization?: true
    website?: true
    kycStatus?: true
    SenderName?: true
    amount?: true
    currency?: true
    lastPaymentDate?: true
    nextPaymentDate?: true
    successfulPayments?: true
    failedAttempts?: true
    subscriberLimit?: true
    emailLimit?: true
    blogPostLimit?: true
    aiGenerationLimit?: true
    termsAndConditionsAccepted?: true
    approvedKYC?: true
    isEmailVerified?: true
    isLoggedIn?: true
    is2FAEnabled?: true
    createdAt?: true
    loggedInAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    fullName?: true
    userName?: true
    password?: true
    imageUrl?: true
    paystackCustomerId?: true
    paystackSubscriptionId?: true
    plan?: true
    role?: true
    subscriptionStatus?: true
    accType?: true
    currentPeriodEnd?: true
    organization?: true
    website?: true
    kycStatus?: true
    SenderName?: true
    amount?: true
    currency?: true
    lastPaymentDate?: true
    nextPaymentDate?: true
    successfulPayments?: true
    failedAttempts?: true
    subscriberLimit?: true
    emailLimit?: true
    blogPostLimit?: true
    aiGenerationLimit?: true
    termsAndConditionsAccepted?: true
    approvedKYC?: true
    isEmailVerified?: true
    isLoggedIn?: true
    is2FAEnabled?: true
    createdAt?: true
    loggedInAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    fullName?: true
    userName?: true
    password?: true
    imageUrl?: true
    paystackCustomerId?: true
    paystackSubscriptionId?: true
    plan?: true
    role?: true
    subscriptionStatus?: true
    accType?: true
    currentPeriodEnd?: true
    organization?: true
    website?: true
    kycStatus?: true
    SenderName?: true
    amount?: true
    currency?: true
    lastPaymentDate?: true
    nextPaymentDate?: true
    successfulPayments?: true
    failedAttempts?: true
    subscriberLimit?: true
    emailLimit?: true
    blogPostLimit?: true
    aiGenerationLimit?: true
    termsAndConditionsAccepted?: true
    approvedKYC?: true
    isEmailVerified?: true
    isLoggedIn?: true
    is2FAEnabled?: true
    createdAt?: true
    loggedInAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl: string | null
    paystackCustomerId: string | null
    paystackSubscriptionId: string | null
    plan: $Enums.Plan
    role: $Enums.Role
    subscriptionStatus: $Enums.PlanSubscriptionStatus
    accType: $Enums.AccountType
    currentPeriodEnd: Date | null
    organization: string | null
    website: string | null
    kycStatus: $Enums.KYCStatus
    SenderName: string | null
    amount: number
    currency: string
    lastPaymentDate: Date | null
    nextPaymentDate: Date | null
    successfulPayments: number
    failedAttempts: number
    subscriberLimit: number
    emailLimit: number
    blogPostLimit: number
    aiGenerationLimit: number
    termsAndConditionsAccepted: boolean
    approvedKYC: boolean
    isEmailVerified: boolean
    isLoggedIn: boolean
    is2FAEnabled: boolean
    createdAt: Date
    loggedInAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    fullName?: boolean
    userName?: boolean
    password?: boolean
    imageUrl?: boolean
    paystackCustomerId?: boolean
    paystackSubscriptionId?: boolean
    plan?: boolean
    role?: boolean
    subscriptionStatus?: boolean
    accType?: boolean
    currentPeriodEnd?: boolean
    organization?: boolean
    website?: boolean
    kycStatus?: boolean
    SenderName?: boolean
    amount?: boolean
    currency?: boolean
    lastPaymentDate?: boolean
    nextPaymentDate?: boolean
    successfulPayments?: boolean
    failedAttempts?: boolean
    subscriberLimit?: boolean
    emailLimit?: boolean
    blogPostLimit?: boolean
    aiGenerationLimit?: boolean
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: boolean
    loggedInAt?: boolean
    updatedAt?: boolean
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    aIContentGenerationToExcerpt?: boolean | User$aIContentGenerationToExcerptArgs<ExtArgs>
    blogComments?: boolean | User$blogCommentsArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    postViews?: boolean | User$postViewsArgs<ExtArgs>
    emails?: boolean | User$emailsArgs<ExtArgs>
    flagedPosts?: boolean | User$flagedPostsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    kyc?: boolean | User$kycArgs<ExtArgs>
    usage?: boolean | User$usageArgs<ExtArgs>
    notificationEmails?: boolean | User$notificationEmailsArgs<ExtArgs>
    tokens?: boolean | User$tokensArgs<ExtArgs>
    reportedComments?: boolean | User$reportedCommentsArgs<ExtArgs>
    template?: boolean | User$templateArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    fullName?: boolean
    userName?: boolean
    password?: boolean
    imageUrl?: boolean
    paystackCustomerId?: boolean
    paystackSubscriptionId?: boolean
    plan?: boolean
    role?: boolean
    subscriptionStatus?: boolean
    accType?: boolean
    currentPeriodEnd?: boolean
    organization?: boolean
    website?: boolean
    kycStatus?: boolean
    SenderName?: boolean
    amount?: boolean
    currency?: boolean
    lastPaymentDate?: boolean
    nextPaymentDate?: boolean
    successfulPayments?: boolean
    failedAttempts?: boolean
    subscriberLimit?: boolean
    emailLimit?: boolean
    blogPostLimit?: boolean
    aiGenerationLimit?: boolean
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: boolean
    loggedInAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    fullName?: boolean
    userName?: boolean
    password?: boolean
    imageUrl?: boolean
    paystackCustomerId?: boolean
    paystackSubscriptionId?: boolean
    plan?: boolean
    role?: boolean
    subscriptionStatus?: boolean
    accType?: boolean
    currentPeriodEnd?: boolean
    organization?: boolean
    website?: boolean
    kycStatus?: boolean
    SenderName?: boolean
    amount?: boolean
    currency?: boolean
    lastPaymentDate?: boolean
    nextPaymentDate?: boolean
    successfulPayments?: boolean
    failedAttempts?: boolean
    subscriberLimit?: boolean
    emailLimit?: boolean
    blogPostLimit?: boolean
    aiGenerationLimit?: boolean
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: boolean
    loggedInAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    fullName?: boolean
    userName?: boolean
    password?: boolean
    imageUrl?: boolean
    paystackCustomerId?: boolean
    paystackSubscriptionId?: boolean
    plan?: boolean
    role?: boolean
    subscriptionStatus?: boolean
    accType?: boolean
    currentPeriodEnd?: boolean
    organization?: boolean
    website?: boolean
    kycStatus?: boolean
    SenderName?: boolean
    amount?: boolean
    currency?: boolean
    lastPaymentDate?: boolean
    nextPaymentDate?: boolean
    successfulPayments?: boolean
    failedAttempts?: boolean
    subscriberLimit?: boolean
    emailLimit?: boolean
    blogPostLimit?: boolean
    aiGenerationLimit?: boolean
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: boolean
    loggedInAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "email" | "fullName" | "userName" | "password" | "imageUrl" | "paystackCustomerId" | "paystackSubscriptionId" | "plan" | "role" | "subscriptionStatus" | "accType" | "currentPeriodEnd" | "organization" | "website" | "kycStatus" | "SenderName" | "amount" | "currency" | "lastPaymentDate" | "nextPaymentDate" | "successfulPayments" | "failedAttempts" | "subscriberLimit" | "emailLimit" | "blogPostLimit" | "aiGenerationLimit" | "termsAndConditionsAccepted" | "approvedKYC" | "isEmailVerified" | "isLoggedIn" | "is2FAEnabled" | "createdAt" | "loggedInAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    aIContentGenerationToExcerpt?: boolean | User$aIContentGenerationToExcerptArgs<ExtArgs>
    blogComments?: boolean | User$blogCommentsArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    postViews?: boolean | User$postViewsArgs<ExtArgs>
    emails?: boolean | User$emailsArgs<ExtArgs>
    flagedPosts?: boolean | User$flagedPostsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    kyc?: boolean | User$kycArgs<ExtArgs>
    usage?: boolean | User$usageArgs<ExtArgs>
    notificationEmails?: boolean | User$notificationEmailsArgs<ExtArgs>
    tokens?: boolean | User$tokensArgs<ExtArgs>
    reportedComments?: boolean | User$reportedCommentsArgs<ExtArgs>
    template?: boolean | User$templateArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      aIContentGenerationToExcerpt: Prisma.$BlogAIGenerationPayload<ExtArgs>[]
      blogComments: Prisma.$BlogCommentPayload<ExtArgs>[]
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
      postViews: Prisma.$BlogPostViewPayload<ExtArgs>[]
      emails: Prisma.$EmailPayload<ExtArgs>[]
      flagedPosts: Prisma.$FlagedBlogPostPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      kyc: Prisma.$KycPayload<ExtArgs> | null
      usage: Prisma.$MembershipUsagePayload<ExtArgs>[]
      notificationEmails: Prisma.$EmailNotificationPayload<ExtArgs>[]
      tokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      reportedComments: Prisma.$ReportedCommentPayload<ExtArgs>[]
      template: Prisma.$EmailTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      email: string
      fullName: string
      userName: string
      password: string
      imageUrl: string | null
      paystackCustomerId: string | null
      paystackSubscriptionId: string | null
      plan: $Enums.Plan
      role: $Enums.Role
      subscriptionStatus: $Enums.PlanSubscriptionStatus
      accType: $Enums.AccountType
      currentPeriodEnd: Date | null
      organization: string | null
      website: string | null
      kycStatus: $Enums.KYCStatus
      SenderName: string | null
      amount: number
      currency: string
      lastPaymentDate: Date | null
      nextPaymentDate: Date | null
      successfulPayments: number
      failedAttempts: number
      subscriberLimit: number
      emailLimit: number
      blogPostLimit: number
      aiGenerationLimit: number
      termsAndConditionsAccepted: boolean
      approvedKYC: boolean
      isEmailVerified: boolean
      isLoggedIn: boolean
      is2FAEnabled: boolean
      createdAt: Date
      loggedInAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aIContentGenerationToExcerpt<T extends User$aIContentGenerationToExcerptArgs<ExtArgs> = {}>(args?: Subset<T, User$aIContentGenerationToExcerptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blogComments<T extends User$blogCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blogPosts<T extends User$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postViews<T extends User$postViewsArgs<ExtArgs> = {}>(args?: Subset<T, User$postViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emails<T extends User$emailsArgs<ExtArgs> = {}>(args?: Subset<T, User$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flagedPosts<T extends User$flagedPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$flagedPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kyc<T extends User$kycArgs<ExtArgs> = {}>(args?: Subset<T, User$kycArgs<ExtArgs>>): Prisma__KycClient<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usage<T extends User$usageArgs<ExtArgs> = {}>(args?: Subset<T, User$usageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationEmails<T extends User$notificationEmailsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationEmailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tokens<T extends User$tokensArgs<ExtArgs> = {}>(args?: Subset<T, User$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportedComments<T extends User$reportedCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportedCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    template<T extends User$templateArgs<ExtArgs> = {}>(args?: Subset<T, User$templateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly userId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly userName: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly imageUrl: FieldRef<"User", 'String'>
    readonly paystackCustomerId: FieldRef<"User", 'String'>
    readonly paystackSubscriptionId: FieldRef<"User", 'String'>
    readonly plan: FieldRef<"User", 'Plan'>
    readonly role: FieldRef<"User", 'Role'>
    readonly subscriptionStatus: FieldRef<"User", 'PlanSubscriptionStatus'>
    readonly accType: FieldRef<"User", 'AccountType'>
    readonly currentPeriodEnd: FieldRef<"User", 'DateTime'>
    readonly organization: FieldRef<"User", 'String'>
    readonly website: FieldRef<"User", 'String'>
    readonly kycStatus: FieldRef<"User", 'KYCStatus'>
    readonly SenderName: FieldRef<"User", 'String'>
    readonly amount: FieldRef<"User", 'Int'>
    readonly currency: FieldRef<"User", 'String'>
    readonly lastPaymentDate: FieldRef<"User", 'DateTime'>
    readonly nextPaymentDate: FieldRef<"User", 'DateTime'>
    readonly successfulPayments: FieldRef<"User", 'Int'>
    readonly failedAttempts: FieldRef<"User", 'Int'>
    readonly subscriberLimit: FieldRef<"User", 'Int'>
    readonly emailLimit: FieldRef<"User", 'Int'>
    readonly blogPostLimit: FieldRef<"User", 'Int'>
    readonly aiGenerationLimit: FieldRef<"User", 'Int'>
    readonly termsAndConditionsAccepted: FieldRef<"User", 'Boolean'>
    readonly approvedKYC: FieldRef<"User", 'Boolean'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly isLoggedIn: FieldRef<"User", 'Boolean'>
    readonly is2FAEnabled: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly loggedInAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * User.aIContentGenerationToExcerpt
   */
  export type User$aIContentGenerationToExcerptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationInclude<ExtArgs> | null
    where?: BlogAIGenerationWhereInput
    orderBy?: BlogAIGenerationOrderByWithRelationInput | BlogAIGenerationOrderByWithRelationInput[]
    cursor?: BlogAIGenerationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogAIGenerationScalarFieldEnum | BlogAIGenerationScalarFieldEnum[]
  }

  /**
   * User.blogComments
   */
  export type User$blogCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    where?: BlogCommentWhereInput
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    cursor?: BlogCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * User.blogPosts
   */
  export type User$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * User.postViews
   */
  export type User$postViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewInclude<ExtArgs> | null
    where?: BlogPostViewWhereInput
    orderBy?: BlogPostViewOrderByWithRelationInput | BlogPostViewOrderByWithRelationInput[]
    cursor?: BlogPostViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostViewScalarFieldEnum | BlogPostViewScalarFieldEnum[]
  }

  /**
   * User.emails
   */
  export type User$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    cursor?: EmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * User.flagedPosts
   */
  export type User$flagedPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostInclude<ExtArgs> | null
    where?: FlagedBlogPostWhereInput
    orderBy?: FlagedBlogPostOrderByWithRelationInput | FlagedBlogPostOrderByWithRelationInput[]
    cursor?: FlagedBlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlagedBlogPostScalarFieldEnum | FlagedBlogPostScalarFieldEnum[]
  }

  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.kyc
   */
  export type User$kycArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycInclude<ExtArgs> | null
    where?: KycWhereInput
  }

  /**
   * User.usage
   */
  export type User$usageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageInclude<ExtArgs> | null
    where?: MembershipUsageWhereInput
    orderBy?: MembershipUsageOrderByWithRelationInput | MembershipUsageOrderByWithRelationInput[]
    cursor?: MembershipUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipUsageScalarFieldEnum | MembershipUsageScalarFieldEnum[]
  }

  /**
   * User.notificationEmails
   */
  export type User$notificationEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    where?: EmailNotificationWhereInput
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    cursor?: EmailNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailNotificationScalarFieldEnum | EmailNotificationScalarFieldEnum[]
  }

  /**
   * User.tokens
   */
  export type User$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.reportedComments
   */
  export type User$reportedCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentInclude<ExtArgs> | null
    where?: ReportedCommentWhereInput
    orderBy?: ReportedCommentOrderByWithRelationInput | ReportedCommentOrderByWithRelationInput[]
    cursor?: ReportedCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportedCommentScalarFieldEnum | ReportedCommentScalarFieldEnum[]
  }

  /**
   * User.template
   */
  export type User$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    cursor?: EmailTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    jti: string | null
    userId: string | null
    hashed: string | null
    userAgent: string | null
    ip: string | null
    revoked: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    jti: string | null
    userId: string | null
    hashed: string | null
    userAgent: string | null
    ip: string | null
    revoked: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    jti: number
    userId: number
    hashed: number
    userAgent: number
    ip: number
    revoked: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    jti?: true
    userId?: true
    hashed?: true
    userAgent?: true
    ip?: true
    revoked?: true
    createdAt?: true
    expiresAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    jti?: true
    userId?: true
    hashed?: true
    userAgent?: true
    ip?: true
    revoked?: true
    createdAt?: true
    expiresAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    jti?: true
    userId?: true
    hashed?: true
    userAgent?: true
    ip?: true
    revoked?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    jti: string
    userId: string
    hashed: string
    userAgent: string | null
    ip: string | null
    revoked: boolean
    createdAt: Date
    expiresAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jti?: boolean
    userId?: boolean
    hashed?: boolean
    userAgent?: boolean
    ip?: boolean
    revoked?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jti?: boolean
    userId?: boolean
    hashed?: boolean
    userAgent?: boolean
    ip?: boolean
    revoked?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jti?: boolean
    userId?: boolean
    hashed?: boolean
    userAgent?: boolean
    ip?: boolean
    revoked?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    jti?: boolean
    userId?: boolean
    hashed?: boolean
    userAgent?: boolean
    ip?: boolean
    revoked?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jti" | "userId" | "hashed" | "userAgent" | "ip" | "revoked" | "createdAt" | "expiresAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jti: string
      userId: string
      hashed: string
      userAgent: string | null
      ip: string | null
      revoked: boolean
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly jti: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly hashed: FieldRef<"RefreshToken", 'String'>
    readonly userAgent: FieldRef<"RefreshToken", 'String'>
    readonly ip: FieldRef<"RefreshToken", 'String'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model OTP
   */

  export type AggregateOTP = {
    _count: OTPCountAggregateOutputType | null
    _avg: OTPAvgAggregateOutputType | null
    _sum: OTPSumAggregateOutputType | null
    _min: OTPMinAggregateOutputType | null
    _max: OTPMaxAggregateOutputType | null
  }

  export type OTPAvgAggregateOutputType = {
    attempts: number | null
  }

  export type OTPSumAggregateOutputType = {
    attempts: number | null
  }

  export type OTPMinAggregateOutputType = {
    id: string | null
    email: string | null
    otp: string | null
    attempts: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OTPMaxAggregateOutputType = {
    id: string | null
    email: string | null
    otp: string | null
    attempts: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OTPCountAggregateOutputType = {
    id: number
    email: number
    otp: number
    attempts: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OTPAvgAggregateInputType = {
    attempts?: true
  }

  export type OTPSumAggregateInputType = {
    attempts?: true
  }

  export type OTPMinAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    attempts?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OTPMaxAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    attempts?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OTPCountAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    attempts?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OTPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTP to aggregate.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OTPS
    **/
    _count?: true | OTPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OTPAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OTPSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OTPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OTPMaxAggregateInputType
  }

  export type GetOTPAggregateType<T extends OTPAggregateArgs> = {
        [P in keyof T & keyof AggregateOTP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOTP[P]>
      : GetScalarType<T[P], AggregateOTP[P]>
  }




  export type OTPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTPWhereInput
    orderBy?: OTPOrderByWithAggregationInput | OTPOrderByWithAggregationInput[]
    by: OTPScalarFieldEnum[] | OTPScalarFieldEnum
    having?: OTPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OTPCountAggregateInputType | true
    _avg?: OTPAvgAggregateInputType
    _sum?: OTPSumAggregateInputType
    _min?: OTPMinAggregateInputType
    _max?: OTPMaxAggregateInputType
  }

  export type OTPGroupByOutputType = {
    id: string
    email: string
    otp: string
    attempts: number
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: OTPCountAggregateOutputType | null
    _avg: OTPAvgAggregateOutputType | null
    _sum: OTPSumAggregateOutputType | null
    _min: OTPMinAggregateOutputType | null
    _max: OTPMaxAggregateOutputType | null
  }

  type GetOTPGroupByPayload<T extends OTPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OTPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OTPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OTPGroupByOutputType[P]>
            : GetScalarType<T[P], OTPGroupByOutputType[P]>
        }
      >
    >


  export type OTPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    attempts?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    attempts?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    attempts?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectScalar = {
    id?: boolean
    email?: boolean
    otp?: boolean
    attempts?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OTPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "otp" | "attempts" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["oTP"]>

  export type $OTPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OTP"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      otp: string
      attempts: number
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["oTP"]>
    composites: {}
  }

  type OTPGetPayload<S extends boolean | null | undefined | OTPDefaultArgs> = $Result.GetResult<Prisma.$OTPPayload, S>

  type OTPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OTPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OTPCountAggregateInputType | true
    }

  export interface OTPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OTP'], meta: { name: 'OTP' } }
    /**
     * Find zero or one OTP that matches the filter.
     * @param {OTPFindUniqueArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OTPFindUniqueArgs>(args: SelectSubset<T, OTPFindUniqueArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OTP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OTPFindUniqueOrThrowArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OTPFindUniqueOrThrowArgs>(args: SelectSubset<T, OTPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OTP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindFirstArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OTPFindFirstArgs>(args?: SelectSubset<T, OTPFindFirstArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OTP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindFirstOrThrowArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OTPFindFirstOrThrowArgs>(args?: SelectSubset<T, OTPFindFirstOrThrowArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OTPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OTPS
     * const oTPS = await prisma.oTP.findMany()
     * 
     * // Get first 10 OTPS
     * const oTPS = await prisma.oTP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oTPWithIdOnly = await prisma.oTP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OTPFindManyArgs>(args?: SelectSubset<T, OTPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OTP.
     * @param {OTPCreateArgs} args - Arguments to create a OTP.
     * @example
     * // Create one OTP
     * const OTP = await prisma.oTP.create({
     *   data: {
     *     // ... data to create a OTP
     *   }
     * })
     * 
     */
    create<T extends OTPCreateArgs>(args: SelectSubset<T, OTPCreateArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OTPS.
     * @param {OTPCreateManyArgs} args - Arguments to create many OTPS.
     * @example
     * // Create many OTPS
     * const oTP = await prisma.oTP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OTPCreateManyArgs>(args?: SelectSubset<T, OTPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OTPS and returns the data saved in the database.
     * @param {OTPCreateManyAndReturnArgs} args - Arguments to create many OTPS.
     * @example
     * // Create many OTPS
     * const oTP = await prisma.oTP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OTPS and only return the `id`
     * const oTPWithIdOnly = await prisma.oTP.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OTPCreateManyAndReturnArgs>(args?: SelectSubset<T, OTPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OTP.
     * @param {OTPDeleteArgs} args - Arguments to delete one OTP.
     * @example
     * // Delete one OTP
     * const OTP = await prisma.oTP.delete({
     *   where: {
     *     // ... filter to delete one OTP
     *   }
     * })
     * 
     */
    delete<T extends OTPDeleteArgs>(args: SelectSubset<T, OTPDeleteArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OTP.
     * @param {OTPUpdateArgs} args - Arguments to update one OTP.
     * @example
     * // Update one OTP
     * const oTP = await prisma.oTP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OTPUpdateArgs>(args: SelectSubset<T, OTPUpdateArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OTPS.
     * @param {OTPDeleteManyArgs} args - Arguments to filter OTPS to delete.
     * @example
     * // Delete a few OTPS
     * const { count } = await prisma.oTP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OTPDeleteManyArgs>(args?: SelectSubset<T, OTPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OTPS
     * const oTP = await prisma.oTP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OTPUpdateManyArgs>(args: SelectSubset<T, OTPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPS and returns the data updated in the database.
     * @param {OTPUpdateManyAndReturnArgs} args - Arguments to update many OTPS.
     * @example
     * // Update many OTPS
     * const oTP = await prisma.oTP.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OTPS and only return the `id`
     * const oTPWithIdOnly = await prisma.oTP.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OTPUpdateManyAndReturnArgs>(args: SelectSubset<T, OTPUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OTP.
     * @param {OTPUpsertArgs} args - Arguments to update or create a OTP.
     * @example
     * // Update or create a OTP
     * const oTP = await prisma.oTP.upsert({
     *   create: {
     *     // ... data to create a OTP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OTP we want to update
     *   }
     * })
     */
    upsert<T extends OTPUpsertArgs>(args: SelectSubset<T, OTPUpsertArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCountArgs} args - Arguments to filter OTPS to count.
     * @example
     * // Count the number of OTPS
     * const count = await prisma.oTP.count({
     *   where: {
     *     // ... the filter for the OTPS we want to count
     *   }
     * })
    **/
    count<T extends OTPCountArgs>(
      args?: Subset<T, OTPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OTPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OTPAggregateArgs>(args: Subset<T, OTPAggregateArgs>): Prisma.PrismaPromise<GetOTPAggregateType<T>>

    /**
     * Group by OTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OTPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OTPGroupByArgs['orderBy'] }
        : { orderBy?: OTPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OTPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOTPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OTP model
   */
  readonly fields: OTPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OTP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OTPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OTP model
   */
  interface OTPFieldRefs {
    readonly id: FieldRef<"OTP", 'String'>
    readonly email: FieldRef<"OTP", 'String'>
    readonly otp: FieldRef<"OTP", 'String'>
    readonly attempts: FieldRef<"OTP", 'Int'>
    readonly expiresAt: FieldRef<"OTP", 'DateTime'>
    readonly createdAt: FieldRef<"OTP", 'DateTime'>
    readonly updatedAt: FieldRef<"OTP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OTP findUnique
   */
  export type OTPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP findUniqueOrThrow
   */
  export type OTPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP findFirst
   */
  export type OTPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPS.
     */
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP findFirstOrThrow
   */
  export type OTPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPS.
     */
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP findMany
   */
  export type OTPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Filter, which OTPS to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP create
   */
  export type OTPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The data needed to create a OTP.
     */
    data: XOR<OTPCreateInput, OTPUncheckedCreateInput>
  }

  /**
   * OTP createMany
   */
  export type OTPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OTPS.
     */
    data: OTPCreateManyInput | OTPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OTP createManyAndReturn
   */
  export type OTPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The data used to create many OTPS.
     */
    data: OTPCreateManyInput | OTPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OTP update
   */
  export type OTPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The data needed to update a OTP.
     */
    data: XOR<OTPUpdateInput, OTPUncheckedUpdateInput>
    /**
     * Choose, which OTP to update.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP updateMany
   */
  export type OTPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OTPS.
     */
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyInput>
    /**
     * Filter which OTPS to update
     */
    where?: OTPWhereInput
    /**
     * Limit how many OTPS to update.
     */
    limit?: number
  }

  /**
   * OTP updateManyAndReturn
   */
  export type OTPUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The data used to update OTPS.
     */
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyInput>
    /**
     * Filter which OTPS to update
     */
    where?: OTPWhereInput
    /**
     * Limit how many OTPS to update.
     */
    limit?: number
  }

  /**
   * OTP upsert
   */
  export type OTPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The filter to search for the OTP to update in case it exists.
     */
    where: OTPWhereUniqueInput
    /**
     * In case the OTP found by the `where` argument doesn't exist, create a new OTP with this data.
     */
    create: XOR<OTPCreateInput, OTPUncheckedCreateInput>
    /**
     * In case the OTP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OTPUpdateInput, OTPUncheckedUpdateInput>
  }

  /**
   * OTP delete
   */
  export type OTPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Filter which OTP to delete.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP deleteMany
   */
  export type OTPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTPS to delete
     */
    where?: OTPWhereInput
    /**
     * Limit how many OTPS to delete.
     */
    limit?: number
  }

  /**
   * OTP without action
   */
  export type OTPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    description: string | null
    amount: number | null
    status: string | null
    invoiceUrl: string | null
    date: Date | null
    externalId: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    description: string | null
    amount: number | null
    status: string | null
    invoiceUrl: string | null
    date: Date | null
    externalId: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    userId: number
    description: number
    amount: number
    status: number
    invoiceUrl: number
    date: number
    externalId: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    userId?: true
    description?: true
    amount?: true
    status?: true
    invoiceUrl?: true
    date?: true
    externalId?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    userId?: true
    description?: true
    amount?: true
    status?: true
    invoiceUrl?: true
    date?: true
    externalId?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    userId?: true
    description?: true
    amount?: true
    status?: true
    invoiceUrl?: true
    date?: true
    externalId?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    userId: string
    description: string
    amount: number
    status: string
    invoiceUrl: string
    date: Date
    externalId: string | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    description?: boolean
    amount?: boolean
    status?: boolean
    invoiceUrl?: boolean
    date?: boolean
    externalId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    description?: boolean
    amount?: boolean
    status?: boolean
    invoiceUrl?: boolean
    date?: boolean
    externalId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    description?: boolean
    amount?: boolean
    status?: boolean
    invoiceUrl?: boolean
    date?: boolean
    externalId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    userId?: boolean
    description?: boolean
    amount?: boolean
    status?: boolean
    invoiceUrl?: boolean
    date?: boolean
    externalId?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "description" | "amount" | "status" | "invoiceUrl" | "date" | "externalId", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      description: string
      amount: number
      status: string
      invoiceUrl: string
      date: Date
      externalId: string | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly userId: FieldRef<"Invoice", 'String'>
    readonly description: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Int'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly invoiceUrl: FieldRef<"Invoice", 'String'>
    readonly date: FieldRef<"Invoice", 'DateTime'>
    readonly externalId: FieldRef<"Invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model ThirdPartyOTP
   */

  export type AggregateThirdPartyOTP = {
    _count: ThirdPartyOTPCountAggregateOutputType | null
    _avg: ThirdPartyOTPAvgAggregateOutputType | null
    _sum: ThirdPartyOTPSumAggregateOutputType | null
    _min: ThirdPartyOTPMinAggregateOutputType | null
    _max: ThirdPartyOTPMaxAggregateOutputType | null
  }

  export type ThirdPartyOTPAvgAggregateOutputType = {
    attempts: number | null
  }

  export type ThirdPartyOTPSumAggregateOutputType = {
    attempts: number | null
  }

  export type ThirdPartyOTPMinAggregateOutputType = {
    email: string | null
    code: string | null
    otpType: string | null
    expiresAt: Date | null
    createdBy: string | null
    createdAt: Date | null
    attempts: number | null
  }

  export type ThirdPartyOTPMaxAggregateOutputType = {
    email: string | null
    code: string | null
    otpType: string | null
    expiresAt: Date | null
    createdBy: string | null
    createdAt: Date | null
    attempts: number | null
  }

  export type ThirdPartyOTPCountAggregateOutputType = {
    email: number
    code: number
    otpType: number
    expiresAt: number
    createdBy: number
    createdAt: number
    attempts: number
    _all: number
  }


  export type ThirdPartyOTPAvgAggregateInputType = {
    attempts?: true
  }

  export type ThirdPartyOTPSumAggregateInputType = {
    attempts?: true
  }

  export type ThirdPartyOTPMinAggregateInputType = {
    email?: true
    code?: true
    otpType?: true
    expiresAt?: true
    createdBy?: true
    createdAt?: true
    attempts?: true
  }

  export type ThirdPartyOTPMaxAggregateInputType = {
    email?: true
    code?: true
    otpType?: true
    expiresAt?: true
    createdBy?: true
    createdAt?: true
    attempts?: true
  }

  export type ThirdPartyOTPCountAggregateInputType = {
    email?: true
    code?: true
    otpType?: true
    expiresAt?: true
    createdBy?: true
    createdAt?: true
    attempts?: true
    _all?: true
  }

  export type ThirdPartyOTPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThirdPartyOTP to aggregate.
     */
    where?: ThirdPartyOTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThirdPartyOTPS to fetch.
     */
    orderBy?: ThirdPartyOTPOrderByWithRelationInput | ThirdPartyOTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThirdPartyOTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThirdPartyOTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThirdPartyOTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThirdPartyOTPS
    **/
    _count?: true | ThirdPartyOTPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ThirdPartyOTPAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ThirdPartyOTPSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThirdPartyOTPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThirdPartyOTPMaxAggregateInputType
  }

  export type GetThirdPartyOTPAggregateType<T extends ThirdPartyOTPAggregateArgs> = {
        [P in keyof T & keyof AggregateThirdPartyOTP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThirdPartyOTP[P]>
      : GetScalarType<T[P], AggregateThirdPartyOTP[P]>
  }




  export type ThirdPartyOTPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThirdPartyOTPWhereInput
    orderBy?: ThirdPartyOTPOrderByWithAggregationInput | ThirdPartyOTPOrderByWithAggregationInput[]
    by: ThirdPartyOTPScalarFieldEnum[] | ThirdPartyOTPScalarFieldEnum
    having?: ThirdPartyOTPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThirdPartyOTPCountAggregateInputType | true
    _avg?: ThirdPartyOTPAvgAggregateInputType
    _sum?: ThirdPartyOTPSumAggregateInputType
    _min?: ThirdPartyOTPMinAggregateInputType
    _max?: ThirdPartyOTPMaxAggregateInputType
  }

  export type ThirdPartyOTPGroupByOutputType = {
    email: string
    code: string
    otpType: string
    expiresAt: Date
    createdBy: string
    createdAt: Date
    attempts: number
    _count: ThirdPartyOTPCountAggregateOutputType | null
    _avg: ThirdPartyOTPAvgAggregateOutputType | null
    _sum: ThirdPartyOTPSumAggregateOutputType | null
    _min: ThirdPartyOTPMinAggregateOutputType | null
    _max: ThirdPartyOTPMaxAggregateOutputType | null
  }

  type GetThirdPartyOTPGroupByPayload<T extends ThirdPartyOTPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThirdPartyOTPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThirdPartyOTPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThirdPartyOTPGroupByOutputType[P]>
            : GetScalarType<T[P], ThirdPartyOTPGroupByOutputType[P]>
        }
      >
    >


  export type ThirdPartyOTPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    code?: boolean
    otpType?: boolean
    expiresAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    attempts?: boolean
  }, ExtArgs["result"]["thirdPartyOTP"]>

  export type ThirdPartyOTPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    code?: boolean
    otpType?: boolean
    expiresAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    attempts?: boolean
  }, ExtArgs["result"]["thirdPartyOTP"]>

  export type ThirdPartyOTPSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    code?: boolean
    otpType?: boolean
    expiresAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    attempts?: boolean
  }, ExtArgs["result"]["thirdPartyOTP"]>

  export type ThirdPartyOTPSelectScalar = {
    email?: boolean
    code?: boolean
    otpType?: boolean
    expiresAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    attempts?: boolean
  }

  export type ThirdPartyOTPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"email" | "code" | "otpType" | "expiresAt" | "createdBy" | "createdAt" | "attempts", ExtArgs["result"]["thirdPartyOTP"]>

  export type $ThirdPartyOTPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ThirdPartyOTP"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      email: string
      code: string
      otpType: string
      expiresAt: Date
      createdBy: string
      createdAt: Date
      attempts: number
    }, ExtArgs["result"]["thirdPartyOTP"]>
    composites: {}
  }

  type ThirdPartyOTPGetPayload<S extends boolean | null | undefined | ThirdPartyOTPDefaultArgs> = $Result.GetResult<Prisma.$ThirdPartyOTPPayload, S>

  type ThirdPartyOTPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThirdPartyOTPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThirdPartyOTPCountAggregateInputType | true
    }

  export interface ThirdPartyOTPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ThirdPartyOTP'], meta: { name: 'ThirdPartyOTP' } }
    /**
     * Find zero or one ThirdPartyOTP that matches the filter.
     * @param {ThirdPartyOTPFindUniqueArgs} args - Arguments to find a ThirdPartyOTP
     * @example
     * // Get one ThirdPartyOTP
     * const thirdPartyOTP = await prisma.thirdPartyOTP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThirdPartyOTPFindUniqueArgs>(args: SelectSubset<T, ThirdPartyOTPFindUniqueArgs<ExtArgs>>): Prisma__ThirdPartyOTPClient<$Result.GetResult<Prisma.$ThirdPartyOTPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ThirdPartyOTP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThirdPartyOTPFindUniqueOrThrowArgs} args - Arguments to find a ThirdPartyOTP
     * @example
     * // Get one ThirdPartyOTP
     * const thirdPartyOTP = await prisma.thirdPartyOTP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThirdPartyOTPFindUniqueOrThrowArgs>(args: SelectSubset<T, ThirdPartyOTPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThirdPartyOTPClient<$Result.GetResult<Prisma.$ThirdPartyOTPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThirdPartyOTP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThirdPartyOTPFindFirstArgs} args - Arguments to find a ThirdPartyOTP
     * @example
     * // Get one ThirdPartyOTP
     * const thirdPartyOTP = await prisma.thirdPartyOTP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThirdPartyOTPFindFirstArgs>(args?: SelectSubset<T, ThirdPartyOTPFindFirstArgs<ExtArgs>>): Prisma__ThirdPartyOTPClient<$Result.GetResult<Prisma.$ThirdPartyOTPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThirdPartyOTP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThirdPartyOTPFindFirstOrThrowArgs} args - Arguments to find a ThirdPartyOTP
     * @example
     * // Get one ThirdPartyOTP
     * const thirdPartyOTP = await prisma.thirdPartyOTP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThirdPartyOTPFindFirstOrThrowArgs>(args?: SelectSubset<T, ThirdPartyOTPFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThirdPartyOTPClient<$Result.GetResult<Prisma.$ThirdPartyOTPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ThirdPartyOTPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThirdPartyOTPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThirdPartyOTPS
     * const thirdPartyOTPS = await prisma.thirdPartyOTP.findMany()
     * 
     * // Get first 10 ThirdPartyOTPS
     * const thirdPartyOTPS = await prisma.thirdPartyOTP.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const thirdPartyOTPWithEmailOnly = await prisma.thirdPartyOTP.findMany({ select: { email: true } })
     * 
     */
    findMany<T extends ThirdPartyOTPFindManyArgs>(args?: SelectSubset<T, ThirdPartyOTPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThirdPartyOTPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ThirdPartyOTP.
     * @param {ThirdPartyOTPCreateArgs} args - Arguments to create a ThirdPartyOTP.
     * @example
     * // Create one ThirdPartyOTP
     * const ThirdPartyOTP = await prisma.thirdPartyOTP.create({
     *   data: {
     *     // ... data to create a ThirdPartyOTP
     *   }
     * })
     * 
     */
    create<T extends ThirdPartyOTPCreateArgs>(args: SelectSubset<T, ThirdPartyOTPCreateArgs<ExtArgs>>): Prisma__ThirdPartyOTPClient<$Result.GetResult<Prisma.$ThirdPartyOTPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ThirdPartyOTPS.
     * @param {ThirdPartyOTPCreateManyArgs} args - Arguments to create many ThirdPartyOTPS.
     * @example
     * // Create many ThirdPartyOTPS
     * const thirdPartyOTP = await prisma.thirdPartyOTP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThirdPartyOTPCreateManyArgs>(args?: SelectSubset<T, ThirdPartyOTPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ThirdPartyOTPS and returns the data saved in the database.
     * @param {ThirdPartyOTPCreateManyAndReturnArgs} args - Arguments to create many ThirdPartyOTPS.
     * @example
     * // Create many ThirdPartyOTPS
     * const thirdPartyOTP = await prisma.thirdPartyOTP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ThirdPartyOTPS and only return the `email`
     * const thirdPartyOTPWithEmailOnly = await prisma.thirdPartyOTP.createManyAndReturn({
     *   select: { email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThirdPartyOTPCreateManyAndReturnArgs>(args?: SelectSubset<T, ThirdPartyOTPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThirdPartyOTPPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ThirdPartyOTP.
     * @param {ThirdPartyOTPDeleteArgs} args - Arguments to delete one ThirdPartyOTP.
     * @example
     * // Delete one ThirdPartyOTP
     * const ThirdPartyOTP = await prisma.thirdPartyOTP.delete({
     *   where: {
     *     // ... filter to delete one ThirdPartyOTP
     *   }
     * })
     * 
     */
    delete<T extends ThirdPartyOTPDeleteArgs>(args: SelectSubset<T, ThirdPartyOTPDeleteArgs<ExtArgs>>): Prisma__ThirdPartyOTPClient<$Result.GetResult<Prisma.$ThirdPartyOTPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ThirdPartyOTP.
     * @param {ThirdPartyOTPUpdateArgs} args - Arguments to update one ThirdPartyOTP.
     * @example
     * // Update one ThirdPartyOTP
     * const thirdPartyOTP = await prisma.thirdPartyOTP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThirdPartyOTPUpdateArgs>(args: SelectSubset<T, ThirdPartyOTPUpdateArgs<ExtArgs>>): Prisma__ThirdPartyOTPClient<$Result.GetResult<Prisma.$ThirdPartyOTPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ThirdPartyOTPS.
     * @param {ThirdPartyOTPDeleteManyArgs} args - Arguments to filter ThirdPartyOTPS to delete.
     * @example
     * // Delete a few ThirdPartyOTPS
     * const { count } = await prisma.thirdPartyOTP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThirdPartyOTPDeleteManyArgs>(args?: SelectSubset<T, ThirdPartyOTPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThirdPartyOTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThirdPartyOTPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThirdPartyOTPS
     * const thirdPartyOTP = await prisma.thirdPartyOTP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThirdPartyOTPUpdateManyArgs>(args: SelectSubset<T, ThirdPartyOTPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThirdPartyOTPS and returns the data updated in the database.
     * @param {ThirdPartyOTPUpdateManyAndReturnArgs} args - Arguments to update many ThirdPartyOTPS.
     * @example
     * // Update many ThirdPartyOTPS
     * const thirdPartyOTP = await prisma.thirdPartyOTP.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ThirdPartyOTPS and only return the `email`
     * const thirdPartyOTPWithEmailOnly = await prisma.thirdPartyOTP.updateManyAndReturn({
     *   select: { email: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThirdPartyOTPUpdateManyAndReturnArgs>(args: SelectSubset<T, ThirdPartyOTPUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThirdPartyOTPPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ThirdPartyOTP.
     * @param {ThirdPartyOTPUpsertArgs} args - Arguments to update or create a ThirdPartyOTP.
     * @example
     * // Update or create a ThirdPartyOTP
     * const thirdPartyOTP = await prisma.thirdPartyOTP.upsert({
     *   create: {
     *     // ... data to create a ThirdPartyOTP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThirdPartyOTP we want to update
     *   }
     * })
     */
    upsert<T extends ThirdPartyOTPUpsertArgs>(args: SelectSubset<T, ThirdPartyOTPUpsertArgs<ExtArgs>>): Prisma__ThirdPartyOTPClient<$Result.GetResult<Prisma.$ThirdPartyOTPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ThirdPartyOTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThirdPartyOTPCountArgs} args - Arguments to filter ThirdPartyOTPS to count.
     * @example
     * // Count the number of ThirdPartyOTPS
     * const count = await prisma.thirdPartyOTP.count({
     *   where: {
     *     // ... the filter for the ThirdPartyOTPS we want to count
     *   }
     * })
    **/
    count<T extends ThirdPartyOTPCountArgs>(
      args?: Subset<T, ThirdPartyOTPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThirdPartyOTPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThirdPartyOTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThirdPartyOTPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThirdPartyOTPAggregateArgs>(args: Subset<T, ThirdPartyOTPAggregateArgs>): Prisma.PrismaPromise<GetThirdPartyOTPAggregateType<T>>

    /**
     * Group by ThirdPartyOTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThirdPartyOTPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThirdPartyOTPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThirdPartyOTPGroupByArgs['orderBy'] }
        : { orderBy?: ThirdPartyOTPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThirdPartyOTPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThirdPartyOTPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ThirdPartyOTP model
   */
  readonly fields: ThirdPartyOTPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThirdPartyOTP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThirdPartyOTPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ThirdPartyOTP model
   */
  interface ThirdPartyOTPFieldRefs {
    readonly email: FieldRef<"ThirdPartyOTP", 'String'>
    readonly code: FieldRef<"ThirdPartyOTP", 'String'>
    readonly otpType: FieldRef<"ThirdPartyOTP", 'String'>
    readonly expiresAt: FieldRef<"ThirdPartyOTP", 'DateTime'>
    readonly createdBy: FieldRef<"ThirdPartyOTP", 'String'>
    readonly createdAt: FieldRef<"ThirdPartyOTP", 'DateTime'>
    readonly attempts: FieldRef<"ThirdPartyOTP", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ThirdPartyOTP findUnique
   */
  export type ThirdPartyOTPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThirdPartyOTP
     */
    select?: ThirdPartyOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThirdPartyOTP
     */
    omit?: ThirdPartyOTPOmit<ExtArgs> | null
    /**
     * Filter, which ThirdPartyOTP to fetch.
     */
    where: ThirdPartyOTPWhereUniqueInput
  }

  /**
   * ThirdPartyOTP findUniqueOrThrow
   */
  export type ThirdPartyOTPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThirdPartyOTP
     */
    select?: ThirdPartyOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThirdPartyOTP
     */
    omit?: ThirdPartyOTPOmit<ExtArgs> | null
    /**
     * Filter, which ThirdPartyOTP to fetch.
     */
    where: ThirdPartyOTPWhereUniqueInput
  }

  /**
   * ThirdPartyOTP findFirst
   */
  export type ThirdPartyOTPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThirdPartyOTP
     */
    select?: ThirdPartyOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThirdPartyOTP
     */
    omit?: ThirdPartyOTPOmit<ExtArgs> | null
    /**
     * Filter, which ThirdPartyOTP to fetch.
     */
    where?: ThirdPartyOTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThirdPartyOTPS to fetch.
     */
    orderBy?: ThirdPartyOTPOrderByWithRelationInput | ThirdPartyOTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThirdPartyOTPS.
     */
    cursor?: ThirdPartyOTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThirdPartyOTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThirdPartyOTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThirdPartyOTPS.
     */
    distinct?: ThirdPartyOTPScalarFieldEnum | ThirdPartyOTPScalarFieldEnum[]
  }

  /**
   * ThirdPartyOTP findFirstOrThrow
   */
  export type ThirdPartyOTPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThirdPartyOTP
     */
    select?: ThirdPartyOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThirdPartyOTP
     */
    omit?: ThirdPartyOTPOmit<ExtArgs> | null
    /**
     * Filter, which ThirdPartyOTP to fetch.
     */
    where?: ThirdPartyOTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThirdPartyOTPS to fetch.
     */
    orderBy?: ThirdPartyOTPOrderByWithRelationInput | ThirdPartyOTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThirdPartyOTPS.
     */
    cursor?: ThirdPartyOTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThirdPartyOTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThirdPartyOTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThirdPartyOTPS.
     */
    distinct?: ThirdPartyOTPScalarFieldEnum | ThirdPartyOTPScalarFieldEnum[]
  }

  /**
   * ThirdPartyOTP findMany
   */
  export type ThirdPartyOTPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThirdPartyOTP
     */
    select?: ThirdPartyOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThirdPartyOTP
     */
    omit?: ThirdPartyOTPOmit<ExtArgs> | null
    /**
     * Filter, which ThirdPartyOTPS to fetch.
     */
    where?: ThirdPartyOTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThirdPartyOTPS to fetch.
     */
    orderBy?: ThirdPartyOTPOrderByWithRelationInput | ThirdPartyOTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThirdPartyOTPS.
     */
    cursor?: ThirdPartyOTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThirdPartyOTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThirdPartyOTPS.
     */
    skip?: number
    distinct?: ThirdPartyOTPScalarFieldEnum | ThirdPartyOTPScalarFieldEnum[]
  }

  /**
   * ThirdPartyOTP create
   */
  export type ThirdPartyOTPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThirdPartyOTP
     */
    select?: ThirdPartyOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThirdPartyOTP
     */
    omit?: ThirdPartyOTPOmit<ExtArgs> | null
    /**
     * The data needed to create a ThirdPartyOTP.
     */
    data: XOR<ThirdPartyOTPCreateInput, ThirdPartyOTPUncheckedCreateInput>
  }

  /**
   * ThirdPartyOTP createMany
   */
  export type ThirdPartyOTPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ThirdPartyOTPS.
     */
    data: ThirdPartyOTPCreateManyInput | ThirdPartyOTPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ThirdPartyOTP createManyAndReturn
   */
  export type ThirdPartyOTPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThirdPartyOTP
     */
    select?: ThirdPartyOTPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThirdPartyOTP
     */
    omit?: ThirdPartyOTPOmit<ExtArgs> | null
    /**
     * The data used to create many ThirdPartyOTPS.
     */
    data: ThirdPartyOTPCreateManyInput | ThirdPartyOTPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ThirdPartyOTP update
   */
  export type ThirdPartyOTPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThirdPartyOTP
     */
    select?: ThirdPartyOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThirdPartyOTP
     */
    omit?: ThirdPartyOTPOmit<ExtArgs> | null
    /**
     * The data needed to update a ThirdPartyOTP.
     */
    data: XOR<ThirdPartyOTPUpdateInput, ThirdPartyOTPUncheckedUpdateInput>
    /**
     * Choose, which ThirdPartyOTP to update.
     */
    where: ThirdPartyOTPWhereUniqueInput
  }

  /**
   * ThirdPartyOTP updateMany
   */
  export type ThirdPartyOTPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ThirdPartyOTPS.
     */
    data: XOR<ThirdPartyOTPUpdateManyMutationInput, ThirdPartyOTPUncheckedUpdateManyInput>
    /**
     * Filter which ThirdPartyOTPS to update
     */
    where?: ThirdPartyOTPWhereInput
    /**
     * Limit how many ThirdPartyOTPS to update.
     */
    limit?: number
  }

  /**
   * ThirdPartyOTP updateManyAndReturn
   */
  export type ThirdPartyOTPUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThirdPartyOTP
     */
    select?: ThirdPartyOTPSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThirdPartyOTP
     */
    omit?: ThirdPartyOTPOmit<ExtArgs> | null
    /**
     * The data used to update ThirdPartyOTPS.
     */
    data: XOR<ThirdPartyOTPUpdateManyMutationInput, ThirdPartyOTPUncheckedUpdateManyInput>
    /**
     * Filter which ThirdPartyOTPS to update
     */
    where?: ThirdPartyOTPWhereInput
    /**
     * Limit how many ThirdPartyOTPS to update.
     */
    limit?: number
  }

  /**
   * ThirdPartyOTP upsert
   */
  export type ThirdPartyOTPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThirdPartyOTP
     */
    select?: ThirdPartyOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThirdPartyOTP
     */
    omit?: ThirdPartyOTPOmit<ExtArgs> | null
    /**
     * The filter to search for the ThirdPartyOTP to update in case it exists.
     */
    where: ThirdPartyOTPWhereUniqueInput
    /**
     * In case the ThirdPartyOTP found by the `where` argument doesn't exist, create a new ThirdPartyOTP with this data.
     */
    create: XOR<ThirdPartyOTPCreateInput, ThirdPartyOTPUncheckedCreateInput>
    /**
     * In case the ThirdPartyOTP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThirdPartyOTPUpdateInput, ThirdPartyOTPUncheckedUpdateInput>
  }

  /**
   * ThirdPartyOTP delete
   */
  export type ThirdPartyOTPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThirdPartyOTP
     */
    select?: ThirdPartyOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThirdPartyOTP
     */
    omit?: ThirdPartyOTPOmit<ExtArgs> | null
    /**
     * Filter which ThirdPartyOTP to delete.
     */
    where: ThirdPartyOTPWhereUniqueInput
  }

  /**
   * ThirdPartyOTP deleteMany
   */
  export type ThirdPartyOTPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThirdPartyOTPS to delete
     */
    where?: ThirdPartyOTPWhereInput
    /**
     * Limit how many ThirdPartyOTPS to delete.
     */
    limit?: number
  }

  /**
   * ThirdPartyOTP without action
   */
  export type ThirdPartyOTPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThirdPartyOTP
     */
    select?: ThirdPartyOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThirdPartyOTP
     */
    omit?: ThirdPartyOTPOmit<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    keyHash: string | null
    jwt: string | null
    createdAt: Date | null
    isTrial: boolean | null
    expiresAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    keyHash: string | null
    jwt: string | null
    createdAt: Date | null
    isTrial: boolean | null
    expiresAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    userId: number
    keyHash: number
    jwt: number
    createdAt: number
    isTrial: number
    expiresAt: number
    _all: number
  }


  export type ApiKeyMinAggregateInputType = {
    id?: true
    userId?: true
    keyHash?: true
    jwt?: true
    createdAt?: true
    isTrial?: true
    expiresAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    userId?: true
    keyHash?: true
    jwt?: true
    createdAt?: true
    isTrial?: true
    expiresAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    userId?: true
    keyHash?: true
    jwt?: true
    createdAt?: true
    isTrial?: true
    expiresAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    userId: string
    keyHash: string
    jwt: string
    createdAt: Date
    isTrial: boolean
    expiresAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    keyHash?: boolean
    jwt?: boolean
    createdAt?: boolean
    isTrial?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    keyHash?: boolean
    jwt?: boolean
    createdAt?: boolean
    isTrial?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    keyHash?: boolean
    jwt?: boolean
    createdAt?: boolean
    isTrial?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    userId?: boolean
    keyHash?: boolean
    jwt?: boolean
    createdAt?: boolean
    isTrial?: boolean
    expiresAt?: boolean
  }

  export type ApiKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "keyHash" | "jwt" | "createdAt" | "isTrial" | "expiresAt", ExtArgs["result"]["apiKey"]>
  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      keyHash: string
      jwt: string
      createdAt: Date
      isTrial: boolean
      expiresAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys and returns the data updated in the database.
     * @param {ApiKeyUpdateManyAndReturnArgs} args - Arguments to update many ApiKeys.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly userId: FieldRef<"ApiKey", 'String'>
    readonly keyHash: FieldRef<"ApiKey", 'String'>
    readonly jwt: FieldRef<"ApiKey", 'String'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly isTrial: FieldRef<"ApiKey", 'Boolean'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
  }

  /**
   * ApiKey updateManyAndReturn
   */
  export type ApiKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to delete.
     */
    limit?: number
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model Kyc
   */

  export type AggregateKyc = {
    _count: KycCountAggregateOutputType | null
    _min: KycMinAggregateOutputType | null
    _max: KycMaxAggregateOutputType | null
  }

  export type KycMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountType: $Enums.KYCAccountType | null
    status: $Enums.KYCStatus | null
    livePhoto: string | null
    reviewedTime: Date | null
    reviewedBy: string | null
    rejectedResponse: string | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KycMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountType: $Enums.KYCAccountType | null
    status: $Enums.KYCStatus | null
    livePhoto: string | null
    reviewedTime: Date | null
    reviewedBy: string | null
    rejectedResponse: string | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KycCountAggregateOutputType = {
    id: number
    userId: number
    accountType: number
    status: number
    levels: number
    documents: number
    livePhoto: number
    reviewedTime: number
    reviewedBy: number
    rejectedResponse: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KycMinAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    status?: true
    livePhoto?: true
    reviewedTime?: true
    reviewedBy?: true
    rejectedResponse?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KycMaxAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    status?: true
    livePhoto?: true
    reviewedTime?: true
    reviewedBy?: true
    rejectedResponse?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KycCountAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    status?: true
    levels?: true
    documents?: true
    livePhoto?: true
    reviewedTime?: true
    reviewedBy?: true
    rejectedResponse?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KycAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kyc to aggregate.
     */
    where?: KycWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kycs to fetch.
     */
    orderBy?: KycOrderByWithRelationInput | KycOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KycWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kycs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kycs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kycs
    **/
    _count?: true | KycCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KycMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KycMaxAggregateInputType
  }

  export type GetKycAggregateType<T extends KycAggregateArgs> = {
        [P in keyof T & keyof AggregateKyc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKyc[P]>
      : GetScalarType<T[P], AggregateKyc[P]>
  }




  export type KycGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KycWhereInput
    orderBy?: KycOrderByWithAggregationInput | KycOrderByWithAggregationInput[]
    by: KycScalarFieldEnum[] | KycScalarFieldEnum
    having?: KycScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KycCountAggregateInputType | true
    _min?: KycMinAggregateInputType
    _max?: KycMaxAggregateInputType
  }

  export type KycGroupByOutputType = {
    id: string
    userId: string
    accountType: $Enums.KYCAccountType
    status: $Enums.KYCStatus
    levels: JsonValue
    documents: JsonValue
    livePhoto: string | null
    reviewedTime: Date | null
    reviewedBy: string | null
    rejectedResponse: string | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: KycCountAggregateOutputType | null
    _min: KycMinAggregateOutputType | null
    _max: KycMaxAggregateOutputType | null
  }

  type GetKycGroupByPayload<T extends KycGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KycGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KycGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KycGroupByOutputType[P]>
            : GetScalarType<T[P], KycGroupByOutputType[P]>
        }
      >
    >


  export type KycSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    status?: boolean
    levels?: boolean
    documents?: boolean
    livePhoto?: boolean
    reviewedTime?: boolean
    reviewedBy?: boolean
    rejectedResponse?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    kycDocuments?: boolean | Kyc$kycDocumentsArgs<ExtArgs>
    _count?: boolean | KycCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kyc"]>

  export type KycSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    status?: boolean
    levels?: boolean
    documents?: boolean
    livePhoto?: boolean
    reviewedTime?: boolean
    reviewedBy?: boolean
    rejectedResponse?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kyc"]>

  export type KycSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    status?: boolean
    levels?: boolean
    documents?: boolean
    livePhoto?: boolean
    reviewedTime?: boolean
    reviewedBy?: boolean
    rejectedResponse?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kyc"]>

  export type KycSelectScalar = {
    id?: boolean
    userId?: boolean
    accountType?: boolean
    status?: boolean
    levels?: boolean
    documents?: boolean
    livePhoto?: boolean
    reviewedTime?: boolean
    reviewedBy?: boolean
    rejectedResponse?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KycOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountType" | "status" | "levels" | "documents" | "livePhoto" | "reviewedTime" | "reviewedBy" | "rejectedResponse" | "comments" | "createdAt" | "updatedAt", ExtArgs["result"]["kyc"]>
  export type KycInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    kycDocuments?: boolean | Kyc$kycDocumentsArgs<ExtArgs>
    _count?: boolean | KycCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KycIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KycIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $KycPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kyc"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      kycDocuments: Prisma.$KYCDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountType: $Enums.KYCAccountType
      status: $Enums.KYCStatus
      levels: Prisma.JsonValue
      documents: Prisma.JsonValue
      livePhoto: string | null
      reviewedTime: Date | null
      reviewedBy: string | null
      rejectedResponse: string | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kyc"]>
    composites: {}
  }

  type KycGetPayload<S extends boolean | null | undefined | KycDefaultArgs> = $Result.GetResult<Prisma.$KycPayload, S>

  type KycCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KycFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KycCountAggregateInputType | true
    }

  export interface KycDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kyc'], meta: { name: 'Kyc' } }
    /**
     * Find zero or one Kyc that matches the filter.
     * @param {KycFindUniqueArgs} args - Arguments to find a Kyc
     * @example
     * // Get one Kyc
     * const kyc = await prisma.kyc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KycFindUniqueArgs>(args: SelectSubset<T, KycFindUniqueArgs<ExtArgs>>): Prisma__KycClient<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kyc that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KycFindUniqueOrThrowArgs} args - Arguments to find a Kyc
     * @example
     * // Get one Kyc
     * const kyc = await prisma.kyc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KycFindUniqueOrThrowArgs>(args: SelectSubset<T, KycFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KycClient<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kyc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycFindFirstArgs} args - Arguments to find a Kyc
     * @example
     * // Get one Kyc
     * const kyc = await prisma.kyc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KycFindFirstArgs>(args?: SelectSubset<T, KycFindFirstArgs<ExtArgs>>): Prisma__KycClient<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kyc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycFindFirstOrThrowArgs} args - Arguments to find a Kyc
     * @example
     * // Get one Kyc
     * const kyc = await prisma.kyc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KycFindFirstOrThrowArgs>(args?: SelectSubset<T, KycFindFirstOrThrowArgs<ExtArgs>>): Prisma__KycClient<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kycs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kycs
     * const kycs = await prisma.kyc.findMany()
     * 
     * // Get first 10 Kycs
     * const kycs = await prisma.kyc.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kycWithIdOnly = await prisma.kyc.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KycFindManyArgs>(args?: SelectSubset<T, KycFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kyc.
     * @param {KycCreateArgs} args - Arguments to create a Kyc.
     * @example
     * // Create one Kyc
     * const Kyc = await prisma.kyc.create({
     *   data: {
     *     // ... data to create a Kyc
     *   }
     * })
     * 
     */
    create<T extends KycCreateArgs>(args: SelectSubset<T, KycCreateArgs<ExtArgs>>): Prisma__KycClient<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kycs.
     * @param {KycCreateManyArgs} args - Arguments to create many Kycs.
     * @example
     * // Create many Kycs
     * const kyc = await prisma.kyc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KycCreateManyArgs>(args?: SelectSubset<T, KycCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kycs and returns the data saved in the database.
     * @param {KycCreateManyAndReturnArgs} args - Arguments to create many Kycs.
     * @example
     * // Create many Kycs
     * const kyc = await prisma.kyc.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kycs and only return the `id`
     * const kycWithIdOnly = await prisma.kyc.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KycCreateManyAndReturnArgs>(args?: SelectSubset<T, KycCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kyc.
     * @param {KycDeleteArgs} args - Arguments to delete one Kyc.
     * @example
     * // Delete one Kyc
     * const Kyc = await prisma.kyc.delete({
     *   where: {
     *     // ... filter to delete one Kyc
     *   }
     * })
     * 
     */
    delete<T extends KycDeleteArgs>(args: SelectSubset<T, KycDeleteArgs<ExtArgs>>): Prisma__KycClient<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kyc.
     * @param {KycUpdateArgs} args - Arguments to update one Kyc.
     * @example
     * // Update one Kyc
     * const kyc = await prisma.kyc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KycUpdateArgs>(args: SelectSubset<T, KycUpdateArgs<ExtArgs>>): Prisma__KycClient<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kycs.
     * @param {KycDeleteManyArgs} args - Arguments to filter Kycs to delete.
     * @example
     * // Delete a few Kycs
     * const { count } = await prisma.kyc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KycDeleteManyArgs>(args?: SelectSubset<T, KycDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kycs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kycs
     * const kyc = await prisma.kyc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KycUpdateManyArgs>(args: SelectSubset<T, KycUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kycs and returns the data updated in the database.
     * @param {KycUpdateManyAndReturnArgs} args - Arguments to update many Kycs.
     * @example
     * // Update many Kycs
     * const kyc = await prisma.kyc.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kycs and only return the `id`
     * const kycWithIdOnly = await prisma.kyc.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KycUpdateManyAndReturnArgs>(args: SelectSubset<T, KycUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kyc.
     * @param {KycUpsertArgs} args - Arguments to update or create a Kyc.
     * @example
     * // Update or create a Kyc
     * const kyc = await prisma.kyc.upsert({
     *   create: {
     *     // ... data to create a Kyc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kyc we want to update
     *   }
     * })
     */
    upsert<T extends KycUpsertArgs>(args: SelectSubset<T, KycUpsertArgs<ExtArgs>>): Prisma__KycClient<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kycs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycCountArgs} args - Arguments to filter Kycs to count.
     * @example
     * // Count the number of Kycs
     * const count = await prisma.kyc.count({
     *   where: {
     *     // ... the filter for the Kycs we want to count
     *   }
     * })
    **/
    count<T extends KycCountArgs>(
      args?: Subset<T, KycCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KycCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kyc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KycAggregateArgs>(args: Subset<T, KycAggregateArgs>): Prisma.PrismaPromise<GetKycAggregateType<T>>

    /**
     * Group by Kyc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KycGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KycGroupByArgs['orderBy'] }
        : { orderBy?: KycGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KycGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKycGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kyc model
   */
  readonly fields: KycFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kyc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KycClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    kycDocuments<T extends Kyc$kycDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Kyc$kycDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kyc model
   */
  interface KycFieldRefs {
    readonly id: FieldRef<"Kyc", 'String'>
    readonly userId: FieldRef<"Kyc", 'String'>
    readonly accountType: FieldRef<"Kyc", 'KYCAccountType'>
    readonly status: FieldRef<"Kyc", 'KYCStatus'>
    readonly levels: FieldRef<"Kyc", 'Json'>
    readonly documents: FieldRef<"Kyc", 'Json'>
    readonly livePhoto: FieldRef<"Kyc", 'String'>
    readonly reviewedTime: FieldRef<"Kyc", 'DateTime'>
    readonly reviewedBy: FieldRef<"Kyc", 'String'>
    readonly rejectedResponse: FieldRef<"Kyc", 'String'>
    readonly comments: FieldRef<"Kyc", 'String'>
    readonly createdAt: FieldRef<"Kyc", 'DateTime'>
    readonly updatedAt: FieldRef<"Kyc", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Kyc findUnique
   */
  export type KycFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycInclude<ExtArgs> | null
    /**
     * Filter, which Kyc to fetch.
     */
    where: KycWhereUniqueInput
  }

  /**
   * Kyc findUniqueOrThrow
   */
  export type KycFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycInclude<ExtArgs> | null
    /**
     * Filter, which Kyc to fetch.
     */
    where: KycWhereUniqueInput
  }

  /**
   * Kyc findFirst
   */
  export type KycFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycInclude<ExtArgs> | null
    /**
     * Filter, which Kyc to fetch.
     */
    where?: KycWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kycs to fetch.
     */
    orderBy?: KycOrderByWithRelationInput | KycOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kycs.
     */
    cursor?: KycWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kycs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kycs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kycs.
     */
    distinct?: KycScalarFieldEnum | KycScalarFieldEnum[]
  }

  /**
   * Kyc findFirstOrThrow
   */
  export type KycFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycInclude<ExtArgs> | null
    /**
     * Filter, which Kyc to fetch.
     */
    where?: KycWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kycs to fetch.
     */
    orderBy?: KycOrderByWithRelationInput | KycOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kycs.
     */
    cursor?: KycWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kycs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kycs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kycs.
     */
    distinct?: KycScalarFieldEnum | KycScalarFieldEnum[]
  }

  /**
   * Kyc findMany
   */
  export type KycFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycInclude<ExtArgs> | null
    /**
     * Filter, which Kycs to fetch.
     */
    where?: KycWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kycs to fetch.
     */
    orderBy?: KycOrderByWithRelationInput | KycOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kycs.
     */
    cursor?: KycWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kycs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kycs.
     */
    skip?: number
    distinct?: KycScalarFieldEnum | KycScalarFieldEnum[]
  }

  /**
   * Kyc create
   */
  export type KycCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycInclude<ExtArgs> | null
    /**
     * The data needed to create a Kyc.
     */
    data: XOR<KycCreateInput, KycUncheckedCreateInput>
  }

  /**
   * Kyc createMany
   */
  export type KycCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kycs.
     */
    data: KycCreateManyInput | KycCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kyc createManyAndReturn
   */
  export type KycCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * The data used to create many Kycs.
     */
    data: KycCreateManyInput | KycCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kyc update
   */
  export type KycUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycInclude<ExtArgs> | null
    /**
     * The data needed to update a Kyc.
     */
    data: XOR<KycUpdateInput, KycUncheckedUpdateInput>
    /**
     * Choose, which Kyc to update.
     */
    where: KycWhereUniqueInput
  }

  /**
   * Kyc updateMany
   */
  export type KycUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kycs.
     */
    data: XOR<KycUpdateManyMutationInput, KycUncheckedUpdateManyInput>
    /**
     * Filter which Kycs to update
     */
    where?: KycWhereInput
    /**
     * Limit how many Kycs to update.
     */
    limit?: number
  }

  /**
   * Kyc updateManyAndReturn
   */
  export type KycUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * The data used to update Kycs.
     */
    data: XOR<KycUpdateManyMutationInput, KycUncheckedUpdateManyInput>
    /**
     * Filter which Kycs to update
     */
    where?: KycWhereInput
    /**
     * Limit how many Kycs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kyc upsert
   */
  export type KycUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycInclude<ExtArgs> | null
    /**
     * The filter to search for the Kyc to update in case it exists.
     */
    where: KycWhereUniqueInput
    /**
     * In case the Kyc found by the `where` argument doesn't exist, create a new Kyc with this data.
     */
    create: XOR<KycCreateInput, KycUncheckedCreateInput>
    /**
     * In case the Kyc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KycUpdateInput, KycUncheckedUpdateInput>
  }

  /**
   * Kyc delete
   */
  export type KycDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycInclude<ExtArgs> | null
    /**
     * Filter which Kyc to delete.
     */
    where: KycWhereUniqueInput
  }

  /**
   * Kyc deleteMany
   */
  export type KycDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kycs to delete
     */
    where?: KycWhereInput
    /**
     * Limit how many Kycs to delete.
     */
    limit?: number
  }

  /**
   * Kyc.kycDocuments
   */
  export type Kyc$kycDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    where?: KYCDocumentWhereInput
    orderBy?: KYCDocumentOrderByWithRelationInput | KYCDocumentOrderByWithRelationInput[]
    cursor?: KYCDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KYCDocumentScalarFieldEnum | KYCDocumentScalarFieldEnum[]
  }

  /**
   * Kyc without action
   */
  export type KycDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc
     */
    select?: KycSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kyc
     */
    omit?: KycOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycInclude<ExtArgs> | null
  }


  /**
   * Model KYCDocument
   */

  export type AggregateKYCDocument = {
    _count: KYCDocumentCountAggregateOutputType | null
    _min: KYCDocumentMinAggregateOutputType | null
    _max: KYCDocumentMaxAggregateOutputType | null
  }

  export type KYCDocumentMinAggregateOutputType = {
    id: string | null
    kycId: string | null
    type: string | null
    url: string | null
    key: string | null
    uploadedAt: Date | null
  }

  export type KYCDocumentMaxAggregateOutputType = {
    id: string | null
    kycId: string | null
    type: string | null
    url: string | null
    key: string | null
    uploadedAt: Date | null
  }

  export type KYCDocumentCountAggregateOutputType = {
    id: number
    kycId: number
    type: number
    url: number
    key: number
    uploadedAt: number
    _all: number
  }


  export type KYCDocumentMinAggregateInputType = {
    id?: true
    kycId?: true
    type?: true
    url?: true
    key?: true
    uploadedAt?: true
  }

  export type KYCDocumentMaxAggregateInputType = {
    id?: true
    kycId?: true
    type?: true
    url?: true
    key?: true
    uploadedAt?: true
  }

  export type KYCDocumentCountAggregateInputType = {
    id?: true
    kycId?: true
    type?: true
    url?: true
    key?: true
    uploadedAt?: true
    _all?: true
  }

  export type KYCDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYCDocument to aggregate.
     */
    where?: KYCDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCDocuments to fetch.
     */
    orderBy?: KYCDocumentOrderByWithRelationInput | KYCDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KYCDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KYCDocuments
    **/
    _count?: true | KYCDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KYCDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KYCDocumentMaxAggregateInputType
  }

  export type GetKYCDocumentAggregateType<T extends KYCDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateKYCDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKYCDocument[P]>
      : GetScalarType<T[P], AggregateKYCDocument[P]>
  }




  export type KYCDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KYCDocumentWhereInput
    orderBy?: KYCDocumentOrderByWithAggregationInput | KYCDocumentOrderByWithAggregationInput[]
    by: KYCDocumentScalarFieldEnum[] | KYCDocumentScalarFieldEnum
    having?: KYCDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KYCDocumentCountAggregateInputType | true
    _min?: KYCDocumentMinAggregateInputType
    _max?: KYCDocumentMaxAggregateInputType
  }

  export type KYCDocumentGroupByOutputType = {
    id: string
    kycId: string
    type: string
    url: string
    key: string
    uploadedAt: Date
    _count: KYCDocumentCountAggregateOutputType | null
    _min: KYCDocumentMinAggregateOutputType | null
    _max: KYCDocumentMaxAggregateOutputType | null
  }

  type GetKYCDocumentGroupByPayload<T extends KYCDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KYCDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KYCDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KYCDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], KYCDocumentGroupByOutputType[P]>
        }
      >
    >


  export type KYCDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kycId?: boolean
    type?: boolean
    url?: boolean
    key?: boolean
    uploadedAt?: boolean
    kyc?: boolean | KycDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYCDocument"]>

  export type KYCDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kycId?: boolean
    type?: boolean
    url?: boolean
    key?: boolean
    uploadedAt?: boolean
    kyc?: boolean | KycDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYCDocument"]>

  export type KYCDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kycId?: boolean
    type?: boolean
    url?: boolean
    key?: boolean
    uploadedAt?: boolean
    kyc?: boolean | KycDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYCDocument"]>

  export type KYCDocumentSelectScalar = {
    id?: boolean
    kycId?: boolean
    type?: boolean
    url?: boolean
    key?: boolean
    uploadedAt?: boolean
  }

  export type KYCDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kycId" | "type" | "url" | "key" | "uploadedAt", ExtArgs["result"]["kYCDocument"]>
  export type KYCDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc?: boolean | KycDefaultArgs<ExtArgs>
  }
  export type KYCDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc?: boolean | KycDefaultArgs<ExtArgs>
  }
  export type KYCDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc?: boolean | KycDefaultArgs<ExtArgs>
  }

  export type $KYCDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KYCDocument"
    objects: {
      kyc: Prisma.$KycPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kycId: string
      type: string
      url: string
      key: string
      uploadedAt: Date
    }, ExtArgs["result"]["kYCDocument"]>
    composites: {}
  }

  type KYCDocumentGetPayload<S extends boolean | null | undefined | KYCDocumentDefaultArgs> = $Result.GetResult<Prisma.$KYCDocumentPayload, S>

  type KYCDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KYCDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KYCDocumentCountAggregateInputType | true
    }

  export interface KYCDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KYCDocument'], meta: { name: 'KYCDocument' } }
    /**
     * Find zero or one KYCDocument that matches the filter.
     * @param {KYCDocumentFindUniqueArgs} args - Arguments to find a KYCDocument
     * @example
     * // Get one KYCDocument
     * const kYCDocument = await prisma.kYCDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KYCDocumentFindUniqueArgs>(args: SelectSubset<T, KYCDocumentFindUniqueArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KYCDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KYCDocumentFindUniqueOrThrowArgs} args - Arguments to find a KYCDocument
     * @example
     * // Get one KYCDocument
     * const kYCDocument = await prisma.kYCDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KYCDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, KYCDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYCDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentFindFirstArgs} args - Arguments to find a KYCDocument
     * @example
     * // Get one KYCDocument
     * const kYCDocument = await prisma.kYCDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KYCDocumentFindFirstArgs>(args?: SelectSubset<T, KYCDocumentFindFirstArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYCDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentFindFirstOrThrowArgs} args - Arguments to find a KYCDocument
     * @example
     * // Get one KYCDocument
     * const kYCDocument = await prisma.kYCDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KYCDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, KYCDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KYCDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KYCDocuments
     * const kYCDocuments = await prisma.kYCDocument.findMany()
     * 
     * // Get first 10 KYCDocuments
     * const kYCDocuments = await prisma.kYCDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kYCDocumentWithIdOnly = await prisma.kYCDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KYCDocumentFindManyArgs>(args?: SelectSubset<T, KYCDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KYCDocument.
     * @param {KYCDocumentCreateArgs} args - Arguments to create a KYCDocument.
     * @example
     * // Create one KYCDocument
     * const KYCDocument = await prisma.kYCDocument.create({
     *   data: {
     *     // ... data to create a KYCDocument
     *   }
     * })
     * 
     */
    create<T extends KYCDocumentCreateArgs>(args: SelectSubset<T, KYCDocumentCreateArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KYCDocuments.
     * @param {KYCDocumentCreateManyArgs} args - Arguments to create many KYCDocuments.
     * @example
     * // Create many KYCDocuments
     * const kYCDocument = await prisma.kYCDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KYCDocumentCreateManyArgs>(args?: SelectSubset<T, KYCDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KYCDocuments and returns the data saved in the database.
     * @param {KYCDocumentCreateManyAndReturnArgs} args - Arguments to create many KYCDocuments.
     * @example
     * // Create many KYCDocuments
     * const kYCDocument = await prisma.kYCDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KYCDocuments and only return the `id`
     * const kYCDocumentWithIdOnly = await prisma.kYCDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KYCDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, KYCDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KYCDocument.
     * @param {KYCDocumentDeleteArgs} args - Arguments to delete one KYCDocument.
     * @example
     * // Delete one KYCDocument
     * const KYCDocument = await prisma.kYCDocument.delete({
     *   where: {
     *     // ... filter to delete one KYCDocument
     *   }
     * })
     * 
     */
    delete<T extends KYCDocumentDeleteArgs>(args: SelectSubset<T, KYCDocumentDeleteArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KYCDocument.
     * @param {KYCDocumentUpdateArgs} args - Arguments to update one KYCDocument.
     * @example
     * // Update one KYCDocument
     * const kYCDocument = await prisma.kYCDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KYCDocumentUpdateArgs>(args: SelectSubset<T, KYCDocumentUpdateArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KYCDocuments.
     * @param {KYCDocumentDeleteManyArgs} args - Arguments to filter KYCDocuments to delete.
     * @example
     * // Delete a few KYCDocuments
     * const { count } = await prisma.kYCDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KYCDocumentDeleteManyArgs>(args?: SelectSubset<T, KYCDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KYCDocuments
     * const kYCDocument = await prisma.kYCDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KYCDocumentUpdateManyArgs>(args: SelectSubset<T, KYCDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCDocuments and returns the data updated in the database.
     * @param {KYCDocumentUpdateManyAndReturnArgs} args - Arguments to update many KYCDocuments.
     * @example
     * // Update many KYCDocuments
     * const kYCDocument = await prisma.kYCDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KYCDocuments and only return the `id`
     * const kYCDocumentWithIdOnly = await prisma.kYCDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KYCDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, KYCDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KYCDocument.
     * @param {KYCDocumentUpsertArgs} args - Arguments to update or create a KYCDocument.
     * @example
     * // Update or create a KYCDocument
     * const kYCDocument = await prisma.kYCDocument.upsert({
     *   create: {
     *     // ... data to create a KYCDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KYCDocument we want to update
     *   }
     * })
     */
    upsert<T extends KYCDocumentUpsertArgs>(args: SelectSubset<T, KYCDocumentUpsertArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KYCDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentCountArgs} args - Arguments to filter KYCDocuments to count.
     * @example
     * // Count the number of KYCDocuments
     * const count = await prisma.kYCDocument.count({
     *   where: {
     *     // ... the filter for the KYCDocuments we want to count
     *   }
     * })
    **/
    count<T extends KYCDocumentCountArgs>(
      args?: Subset<T, KYCDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KYCDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KYCDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KYCDocumentAggregateArgs>(args: Subset<T, KYCDocumentAggregateArgs>): Prisma.PrismaPromise<GetKYCDocumentAggregateType<T>>

    /**
     * Group by KYCDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KYCDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KYCDocumentGroupByArgs['orderBy'] }
        : { orderBy?: KYCDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KYCDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKYCDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KYCDocument model
   */
  readonly fields: KYCDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KYCDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KYCDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc<T extends KycDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KycDefaultArgs<ExtArgs>>): Prisma__KycClient<$Result.GetResult<Prisma.$KycPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KYCDocument model
   */
  interface KYCDocumentFieldRefs {
    readonly id: FieldRef<"KYCDocument", 'String'>
    readonly kycId: FieldRef<"KYCDocument", 'String'>
    readonly type: FieldRef<"KYCDocument", 'String'>
    readonly url: FieldRef<"KYCDocument", 'String'>
    readonly key: FieldRef<"KYCDocument", 'String'>
    readonly uploadedAt: FieldRef<"KYCDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KYCDocument findUnique
   */
  export type KYCDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KYCDocument to fetch.
     */
    where: KYCDocumentWhereUniqueInput
  }

  /**
   * KYCDocument findUniqueOrThrow
   */
  export type KYCDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KYCDocument to fetch.
     */
    where: KYCDocumentWhereUniqueInput
  }

  /**
   * KYCDocument findFirst
   */
  export type KYCDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KYCDocument to fetch.
     */
    where?: KYCDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCDocuments to fetch.
     */
    orderBy?: KYCDocumentOrderByWithRelationInput | KYCDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCDocuments.
     */
    cursor?: KYCDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCDocuments.
     */
    distinct?: KYCDocumentScalarFieldEnum | KYCDocumentScalarFieldEnum[]
  }

  /**
   * KYCDocument findFirstOrThrow
   */
  export type KYCDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KYCDocument to fetch.
     */
    where?: KYCDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCDocuments to fetch.
     */
    orderBy?: KYCDocumentOrderByWithRelationInput | KYCDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCDocuments.
     */
    cursor?: KYCDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCDocuments.
     */
    distinct?: KYCDocumentScalarFieldEnum | KYCDocumentScalarFieldEnum[]
  }

  /**
   * KYCDocument findMany
   */
  export type KYCDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KYCDocuments to fetch.
     */
    where?: KYCDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCDocuments to fetch.
     */
    orderBy?: KYCDocumentOrderByWithRelationInput | KYCDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KYCDocuments.
     */
    cursor?: KYCDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCDocuments.
     */
    skip?: number
    distinct?: KYCDocumentScalarFieldEnum | KYCDocumentScalarFieldEnum[]
  }

  /**
   * KYCDocument create
   */
  export type KYCDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a KYCDocument.
     */
    data: XOR<KYCDocumentCreateInput, KYCDocumentUncheckedCreateInput>
  }

  /**
   * KYCDocument createMany
   */
  export type KYCDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KYCDocuments.
     */
    data: KYCDocumentCreateManyInput | KYCDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KYCDocument createManyAndReturn
   */
  export type KYCDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many KYCDocuments.
     */
    data: KYCDocumentCreateManyInput | KYCDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYCDocument update
   */
  export type KYCDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a KYCDocument.
     */
    data: XOR<KYCDocumentUpdateInput, KYCDocumentUncheckedUpdateInput>
    /**
     * Choose, which KYCDocument to update.
     */
    where: KYCDocumentWhereUniqueInput
  }

  /**
   * KYCDocument updateMany
   */
  export type KYCDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KYCDocuments.
     */
    data: XOR<KYCDocumentUpdateManyMutationInput, KYCDocumentUncheckedUpdateManyInput>
    /**
     * Filter which KYCDocuments to update
     */
    where?: KYCDocumentWhereInput
    /**
     * Limit how many KYCDocuments to update.
     */
    limit?: number
  }

  /**
   * KYCDocument updateManyAndReturn
   */
  export type KYCDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * The data used to update KYCDocuments.
     */
    data: XOR<KYCDocumentUpdateManyMutationInput, KYCDocumentUncheckedUpdateManyInput>
    /**
     * Filter which KYCDocuments to update
     */
    where?: KYCDocumentWhereInput
    /**
     * Limit how many KYCDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYCDocument upsert
   */
  export type KYCDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the KYCDocument to update in case it exists.
     */
    where: KYCDocumentWhereUniqueInput
    /**
     * In case the KYCDocument found by the `where` argument doesn't exist, create a new KYCDocument with this data.
     */
    create: XOR<KYCDocumentCreateInput, KYCDocumentUncheckedCreateInput>
    /**
     * In case the KYCDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KYCDocumentUpdateInput, KYCDocumentUncheckedUpdateInput>
  }

  /**
   * KYCDocument delete
   */
  export type KYCDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * Filter which KYCDocument to delete.
     */
    where: KYCDocumentWhereUniqueInput
  }

  /**
   * KYCDocument deleteMany
   */
  export type KYCDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYCDocuments to delete
     */
    where?: KYCDocumentWhereInput
    /**
     * Limit how many KYCDocuments to delete.
     */
    limit?: number
  }

  /**
   * KYCDocument without action
   */
  export type KYCDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
  }


  /**
   * Model MembershipUsage
   */

  export type AggregateMembershipUsage = {
    _count: MembershipUsageCountAggregateOutputType | null
    _avg: MembershipUsageAvgAggregateOutputType | null
    _sum: MembershipUsageSumAggregateOutputType | null
    _min: MembershipUsageMinAggregateOutputType | null
    _max: MembershipUsageMaxAggregateOutputType | null
  }

  export type MembershipUsageAvgAggregateOutputType = {
    emailsSent: number | null
    subscribersAdded: number | null
    campaignsCreated: number | null
    blogPostsCreated: number | null
    aiGenerationsUsed: number | null
  }

  export type MembershipUsageSumAggregateOutputType = {
    emailsSent: number | null
    subscribersAdded: number | null
    campaignsCreated: number | null
    blogPostsCreated: number | null
    aiGenerationsUsed: number | null
  }

  export type MembershipUsageMinAggregateOutputType = {
    id: string | null
    userId: string | null
    month: string | null
    emailsSent: number | null
    subscribersAdded: number | null
    campaignsCreated: number | null
    blogPostsCreated: number | null
    aiGenerationsUsed: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipUsageMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    month: string | null
    emailsSent: number | null
    subscribersAdded: number | null
    campaignsCreated: number | null
    blogPostsCreated: number | null
    aiGenerationsUsed: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipUsageCountAggregateOutputType = {
    id: number
    userId: number
    month: number
    emailsSent: number
    subscribersAdded: number
    campaignsCreated: number
    blogPostsCreated: number
    aiGenerationsUsed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MembershipUsageAvgAggregateInputType = {
    emailsSent?: true
    subscribersAdded?: true
    campaignsCreated?: true
    blogPostsCreated?: true
    aiGenerationsUsed?: true
  }

  export type MembershipUsageSumAggregateInputType = {
    emailsSent?: true
    subscribersAdded?: true
    campaignsCreated?: true
    blogPostsCreated?: true
    aiGenerationsUsed?: true
  }

  export type MembershipUsageMinAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    emailsSent?: true
    subscribersAdded?: true
    campaignsCreated?: true
    blogPostsCreated?: true
    aiGenerationsUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipUsageMaxAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    emailsSent?: true
    subscribersAdded?: true
    campaignsCreated?: true
    blogPostsCreated?: true
    aiGenerationsUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipUsageCountAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    emailsSent?: true
    subscribersAdded?: true
    campaignsCreated?: true
    blogPostsCreated?: true
    aiGenerationsUsed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MembershipUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipUsage to aggregate.
     */
    where?: MembershipUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipUsages to fetch.
     */
    orderBy?: MembershipUsageOrderByWithRelationInput | MembershipUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MembershipUsages
    **/
    _count?: true | MembershipUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembershipUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembershipUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipUsageMaxAggregateInputType
  }

  export type GetMembershipUsageAggregateType<T extends MembershipUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateMembershipUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembershipUsage[P]>
      : GetScalarType<T[P], AggregateMembershipUsage[P]>
  }




  export type MembershipUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipUsageWhereInput
    orderBy?: MembershipUsageOrderByWithAggregationInput | MembershipUsageOrderByWithAggregationInput[]
    by: MembershipUsageScalarFieldEnum[] | MembershipUsageScalarFieldEnum
    having?: MembershipUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipUsageCountAggregateInputType | true
    _avg?: MembershipUsageAvgAggregateInputType
    _sum?: MembershipUsageSumAggregateInputType
    _min?: MembershipUsageMinAggregateInputType
    _max?: MembershipUsageMaxAggregateInputType
  }

  export type MembershipUsageGroupByOutputType = {
    id: string
    userId: string
    month: string
    emailsSent: number
    subscribersAdded: number
    campaignsCreated: number
    blogPostsCreated: number
    aiGenerationsUsed: number
    createdAt: Date
    updatedAt: Date
    _count: MembershipUsageCountAggregateOutputType | null
    _avg: MembershipUsageAvgAggregateOutputType | null
    _sum: MembershipUsageSumAggregateOutputType | null
    _min: MembershipUsageMinAggregateOutputType | null
    _max: MembershipUsageMaxAggregateOutputType | null
  }

  type GetMembershipUsageGroupByPayload<T extends MembershipUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipUsageGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipUsageGroupByOutputType[P]>
        }
      >
    >


  export type MembershipUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    emailsSent?: boolean
    subscribersAdded?: boolean
    campaignsCreated?: boolean
    blogPostsCreated?: boolean
    aiGenerationsUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipUsage"]>

  export type MembershipUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    emailsSent?: boolean
    subscribersAdded?: boolean
    campaignsCreated?: boolean
    blogPostsCreated?: boolean
    aiGenerationsUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipUsage"]>

  export type MembershipUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    emailsSent?: boolean
    subscribersAdded?: boolean
    campaignsCreated?: boolean
    blogPostsCreated?: boolean
    aiGenerationsUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipUsage"]>

  export type MembershipUsageSelectScalar = {
    id?: boolean
    userId?: boolean
    month?: boolean
    emailsSent?: boolean
    subscribersAdded?: boolean
    campaignsCreated?: boolean
    blogPostsCreated?: boolean
    aiGenerationsUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MembershipUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "month" | "emailsSent" | "subscribersAdded" | "campaignsCreated" | "blogPostsCreated" | "aiGenerationsUsed" | "createdAt" | "updatedAt", ExtArgs["result"]["membershipUsage"]>
  export type MembershipUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MembershipUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MembershipUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MembershipUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MembershipUsage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      month: string
      emailsSent: number
      subscribersAdded: number
      campaignsCreated: number
      blogPostsCreated: number
      aiGenerationsUsed: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["membershipUsage"]>
    composites: {}
  }

  type MembershipUsageGetPayload<S extends boolean | null | undefined | MembershipUsageDefaultArgs> = $Result.GetResult<Prisma.$MembershipUsagePayload, S>

  type MembershipUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MembershipUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembershipUsageCountAggregateInputType | true
    }

  export interface MembershipUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MembershipUsage'], meta: { name: 'MembershipUsage' } }
    /**
     * Find zero or one MembershipUsage that matches the filter.
     * @param {MembershipUsageFindUniqueArgs} args - Arguments to find a MembershipUsage
     * @example
     * // Get one MembershipUsage
     * const membershipUsage = await prisma.membershipUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipUsageFindUniqueArgs>(args: SelectSubset<T, MembershipUsageFindUniqueArgs<ExtArgs>>): Prisma__MembershipUsageClient<$Result.GetResult<Prisma.$MembershipUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MembershipUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembershipUsageFindUniqueOrThrowArgs} args - Arguments to find a MembershipUsage
     * @example
     * // Get one MembershipUsage
     * const membershipUsage = await prisma.membershipUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipUsageClient<$Result.GetResult<Prisma.$MembershipUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MembershipUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUsageFindFirstArgs} args - Arguments to find a MembershipUsage
     * @example
     * // Get one MembershipUsage
     * const membershipUsage = await prisma.membershipUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipUsageFindFirstArgs>(args?: SelectSubset<T, MembershipUsageFindFirstArgs<ExtArgs>>): Prisma__MembershipUsageClient<$Result.GetResult<Prisma.$MembershipUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MembershipUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUsageFindFirstOrThrowArgs} args - Arguments to find a MembershipUsage
     * @example
     * // Get one MembershipUsage
     * const membershipUsage = await prisma.membershipUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipUsageClient<$Result.GetResult<Prisma.$MembershipUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MembershipUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MembershipUsages
     * const membershipUsages = await prisma.membershipUsage.findMany()
     * 
     * // Get first 10 MembershipUsages
     * const membershipUsages = await prisma.membershipUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipUsageWithIdOnly = await prisma.membershipUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipUsageFindManyArgs>(args?: SelectSubset<T, MembershipUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MembershipUsage.
     * @param {MembershipUsageCreateArgs} args - Arguments to create a MembershipUsage.
     * @example
     * // Create one MembershipUsage
     * const MembershipUsage = await prisma.membershipUsage.create({
     *   data: {
     *     // ... data to create a MembershipUsage
     *   }
     * })
     * 
     */
    create<T extends MembershipUsageCreateArgs>(args: SelectSubset<T, MembershipUsageCreateArgs<ExtArgs>>): Prisma__MembershipUsageClient<$Result.GetResult<Prisma.$MembershipUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MembershipUsages.
     * @param {MembershipUsageCreateManyArgs} args - Arguments to create many MembershipUsages.
     * @example
     * // Create many MembershipUsages
     * const membershipUsage = await prisma.membershipUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipUsageCreateManyArgs>(args?: SelectSubset<T, MembershipUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MembershipUsages and returns the data saved in the database.
     * @param {MembershipUsageCreateManyAndReturnArgs} args - Arguments to create many MembershipUsages.
     * @example
     * // Create many MembershipUsages
     * const membershipUsage = await prisma.membershipUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MembershipUsages and only return the `id`
     * const membershipUsageWithIdOnly = await prisma.membershipUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MembershipUsage.
     * @param {MembershipUsageDeleteArgs} args - Arguments to delete one MembershipUsage.
     * @example
     * // Delete one MembershipUsage
     * const MembershipUsage = await prisma.membershipUsage.delete({
     *   where: {
     *     // ... filter to delete one MembershipUsage
     *   }
     * })
     * 
     */
    delete<T extends MembershipUsageDeleteArgs>(args: SelectSubset<T, MembershipUsageDeleteArgs<ExtArgs>>): Prisma__MembershipUsageClient<$Result.GetResult<Prisma.$MembershipUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MembershipUsage.
     * @param {MembershipUsageUpdateArgs} args - Arguments to update one MembershipUsage.
     * @example
     * // Update one MembershipUsage
     * const membershipUsage = await prisma.membershipUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipUsageUpdateArgs>(args: SelectSubset<T, MembershipUsageUpdateArgs<ExtArgs>>): Prisma__MembershipUsageClient<$Result.GetResult<Prisma.$MembershipUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MembershipUsages.
     * @param {MembershipUsageDeleteManyArgs} args - Arguments to filter MembershipUsages to delete.
     * @example
     * // Delete a few MembershipUsages
     * const { count } = await prisma.membershipUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipUsageDeleteManyArgs>(args?: SelectSubset<T, MembershipUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MembershipUsages
     * const membershipUsage = await prisma.membershipUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipUsageUpdateManyArgs>(args: SelectSubset<T, MembershipUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipUsages and returns the data updated in the database.
     * @param {MembershipUsageUpdateManyAndReturnArgs} args - Arguments to update many MembershipUsages.
     * @example
     * // Update many MembershipUsages
     * const membershipUsage = await prisma.membershipUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MembershipUsages and only return the `id`
     * const membershipUsageWithIdOnly = await prisma.membershipUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MembershipUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, MembershipUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MembershipUsage.
     * @param {MembershipUsageUpsertArgs} args - Arguments to update or create a MembershipUsage.
     * @example
     * // Update or create a MembershipUsage
     * const membershipUsage = await prisma.membershipUsage.upsert({
     *   create: {
     *     // ... data to create a MembershipUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MembershipUsage we want to update
     *   }
     * })
     */
    upsert<T extends MembershipUsageUpsertArgs>(args: SelectSubset<T, MembershipUsageUpsertArgs<ExtArgs>>): Prisma__MembershipUsageClient<$Result.GetResult<Prisma.$MembershipUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MembershipUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUsageCountArgs} args - Arguments to filter MembershipUsages to count.
     * @example
     * // Count the number of MembershipUsages
     * const count = await prisma.membershipUsage.count({
     *   where: {
     *     // ... the filter for the MembershipUsages we want to count
     *   }
     * })
    **/
    count<T extends MembershipUsageCountArgs>(
      args?: Subset<T, MembershipUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MembershipUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipUsageAggregateArgs>(args: Subset<T, MembershipUsageAggregateArgs>): Prisma.PrismaPromise<GetMembershipUsageAggregateType<T>>

    /**
     * Group by MembershipUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipUsageGroupByArgs['orderBy'] }
        : { orderBy?: MembershipUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MembershipUsage model
   */
  readonly fields: MembershipUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MembershipUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MembershipUsage model
   */
  interface MembershipUsageFieldRefs {
    readonly id: FieldRef<"MembershipUsage", 'String'>
    readonly userId: FieldRef<"MembershipUsage", 'String'>
    readonly month: FieldRef<"MembershipUsage", 'String'>
    readonly emailsSent: FieldRef<"MembershipUsage", 'Int'>
    readonly subscribersAdded: FieldRef<"MembershipUsage", 'Int'>
    readonly campaignsCreated: FieldRef<"MembershipUsage", 'Int'>
    readonly blogPostsCreated: FieldRef<"MembershipUsage", 'Int'>
    readonly aiGenerationsUsed: FieldRef<"MembershipUsage", 'Int'>
    readonly createdAt: FieldRef<"MembershipUsage", 'DateTime'>
    readonly updatedAt: FieldRef<"MembershipUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MembershipUsage findUnique
   */
  export type MembershipUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageInclude<ExtArgs> | null
    /**
     * Filter, which MembershipUsage to fetch.
     */
    where: MembershipUsageWhereUniqueInput
  }

  /**
   * MembershipUsage findUniqueOrThrow
   */
  export type MembershipUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageInclude<ExtArgs> | null
    /**
     * Filter, which MembershipUsage to fetch.
     */
    where: MembershipUsageWhereUniqueInput
  }

  /**
   * MembershipUsage findFirst
   */
  export type MembershipUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageInclude<ExtArgs> | null
    /**
     * Filter, which MembershipUsage to fetch.
     */
    where?: MembershipUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipUsages to fetch.
     */
    orderBy?: MembershipUsageOrderByWithRelationInput | MembershipUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipUsages.
     */
    cursor?: MembershipUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipUsages.
     */
    distinct?: MembershipUsageScalarFieldEnum | MembershipUsageScalarFieldEnum[]
  }

  /**
   * MembershipUsage findFirstOrThrow
   */
  export type MembershipUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageInclude<ExtArgs> | null
    /**
     * Filter, which MembershipUsage to fetch.
     */
    where?: MembershipUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipUsages to fetch.
     */
    orderBy?: MembershipUsageOrderByWithRelationInput | MembershipUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipUsages.
     */
    cursor?: MembershipUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipUsages.
     */
    distinct?: MembershipUsageScalarFieldEnum | MembershipUsageScalarFieldEnum[]
  }

  /**
   * MembershipUsage findMany
   */
  export type MembershipUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageInclude<ExtArgs> | null
    /**
     * Filter, which MembershipUsages to fetch.
     */
    where?: MembershipUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipUsages to fetch.
     */
    orderBy?: MembershipUsageOrderByWithRelationInput | MembershipUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MembershipUsages.
     */
    cursor?: MembershipUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipUsages.
     */
    skip?: number
    distinct?: MembershipUsageScalarFieldEnum | MembershipUsageScalarFieldEnum[]
  }

  /**
   * MembershipUsage create
   */
  export type MembershipUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a MembershipUsage.
     */
    data: XOR<MembershipUsageCreateInput, MembershipUsageUncheckedCreateInput>
  }

  /**
   * MembershipUsage createMany
   */
  export type MembershipUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MembershipUsages.
     */
    data: MembershipUsageCreateManyInput | MembershipUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MembershipUsage createManyAndReturn
   */
  export type MembershipUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * The data used to create many MembershipUsages.
     */
    data: MembershipUsageCreateManyInput | MembershipUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MembershipUsage update
   */
  export type MembershipUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a MembershipUsage.
     */
    data: XOR<MembershipUsageUpdateInput, MembershipUsageUncheckedUpdateInput>
    /**
     * Choose, which MembershipUsage to update.
     */
    where: MembershipUsageWhereUniqueInput
  }

  /**
   * MembershipUsage updateMany
   */
  export type MembershipUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MembershipUsages.
     */
    data: XOR<MembershipUsageUpdateManyMutationInput, MembershipUsageUncheckedUpdateManyInput>
    /**
     * Filter which MembershipUsages to update
     */
    where?: MembershipUsageWhereInput
    /**
     * Limit how many MembershipUsages to update.
     */
    limit?: number
  }

  /**
   * MembershipUsage updateManyAndReturn
   */
  export type MembershipUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * The data used to update MembershipUsages.
     */
    data: XOR<MembershipUsageUpdateManyMutationInput, MembershipUsageUncheckedUpdateManyInput>
    /**
     * Filter which MembershipUsages to update
     */
    where?: MembershipUsageWhereInput
    /**
     * Limit how many MembershipUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MembershipUsage upsert
   */
  export type MembershipUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the MembershipUsage to update in case it exists.
     */
    where: MembershipUsageWhereUniqueInput
    /**
     * In case the MembershipUsage found by the `where` argument doesn't exist, create a new MembershipUsage with this data.
     */
    create: XOR<MembershipUsageCreateInput, MembershipUsageUncheckedCreateInput>
    /**
     * In case the MembershipUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipUsageUpdateInput, MembershipUsageUncheckedUpdateInput>
  }

  /**
   * MembershipUsage delete
   */
  export type MembershipUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageInclude<ExtArgs> | null
    /**
     * Filter which MembershipUsage to delete.
     */
    where: MembershipUsageWhereUniqueInput
  }

  /**
   * MembershipUsage deleteMany
   */
  export type MembershipUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipUsages to delete
     */
    where?: MembershipUsageWhereInput
    /**
     * Limit how many MembershipUsages to delete.
     */
    limit?: number
  }

  /**
   * MembershipUsage without action
   */
  export type MembershipUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUsage
     */
    select?: MembershipUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUsage
     */
    omit?: MembershipUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUsageInclude<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostAvgAggregateOutputType = {
    seoScore: number | null
    shares: number | null
    readTime: number | null
    wordCount: number | null
    characterCount: number | null
    likes: number | null
    views: number | null
  }

  export type BlogPostSumAggregateOutputType = {
    seoScore: number | null
    shares: number | null
    readTime: number | null
    wordCount: number | null
    characterCount: number | null
    likes: number | null
    views: number | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    format: $Enums.ContentFormat | null
    status: $Enums.PostStatus | null
    visibility: $Enums.PostVisibility | null
    featuredImage: string | null
    featuredVideo: string | null
    authorId: string | null
    authorBio: string | null
    authorTitle: string | null
    author: string | null
    categoryId: string | null
    seoTitle: string | null
    seoDescription: string | null
    seoScore: number | null
    shares: number | null
    readTime: number | null
    wordCount: number | null
    characterCount: number | null
    likes: number | null
    views: number | null
    flagReason: string | null
    isFlagged: boolean | null
    isFeatured: boolean | null
    isPinned: boolean | null
    allowComments: boolean | null
    publishedAt: Date | null
    flaggedAt: Date | null
    scheduledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    generatedById: string | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    format: $Enums.ContentFormat | null
    status: $Enums.PostStatus | null
    visibility: $Enums.PostVisibility | null
    featuredImage: string | null
    featuredVideo: string | null
    authorId: string | null
    authorBio: string | null
    authorTitle: string | null
    author: string | null
    categoryId: string | null
    seoTitle: string | null
    seoDescription: string | null
    seoScore: number | null
    shares: number | null
    readTime: number | null
    wordCount: number | null
    characterCount: number | null
    likes: number | null
    views: number | null
    flagReason: string | null
    isFlagged: boolean | null
    isFeatured: boolean | null
    isPinned: boolean | null
    allowComments: boolean | null
    publishedAt: Date | null
    flaggedAt: Date | null
    scheduledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    generatedById: string | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    slug: number
    content: number
    excerpt: number
    format: number
    status: number
    visibility: number
    featuredImage: number
    featuredVideo: number
    galleryImages: number
    authorId: number
    authorBio: number
    authorTitle: number
    author: number
    categoryId: number
    seoTitle: number
    seoDescription: number
    seoKeywords: number
    seoScore: number
    shares: number
    readTime: number
    wordCount: number
    characterCount: number
    likes: number
    views: number
    flagReason: number
    isFlagged: number
    isFeatured: number
    isPinned: number
    allowComments: number
    publishedAt: number
    flaggedAt: number
    scheduledAt: number
    createdAt: number
    updatedAt: number
    generatedById: number
    _all: number
  }


  export type BlogPostAvgAggregateInputType = {
    seoScore?: true
    shares?: true
    readTime?: true
    wordCount?: true
    characterCount?: true
    likes?: true
    views?: true
  }

  export type BlogPostSumAggregateInputType = {
    seoScore?: true
    shares?: true
    readTime?: true
    wordCount?: true
    characterCount?: true
    likes?: true
    views?: true
  }

  export type BlogPostMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    slug?: true
    content?: true
    excerpt?: true
    format?: true
    status?: true
    visibility?: true
    featuredImage?: true
    featuredVideo?: true
    authorId?: true
    authorBio?: true
    authorTitle?: true
    author?: true
    categoryId?: true
    seoTitle?: true
    seoDescription?: true
    seoScore?: true
    shares?: true
    readTime?: true
    wordCount?: true
    characterCount?: true
    likes?: true
    views?: true
    flagReason?: true
    isFlagged?: true
    isFeatured?: true
    isPinned?: true
    allowComments?: true
    publishedAt?: true
    flaggedAt?: true
    scheduledAt?: true
    createdAt?: true
    updatedAt?: true
    generatedById?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    slug?: true
    content?: true
    excerpt?: true
    format?: true
    status?: true
    visibility?: true
    featuredImage?: true
    featuredVideo?: true
    authorId?: true
    authorBio?: true
    authorTitle?: true
    author?: true
    categoryId?: true
    seoTitle?: true
    seoDescription?: true
    seoScore?: true
    shares?: true
    readTime?: true
    wordCount?: true
    characterCount?: true
    likes?: true
    views?: true
    flagReason?: true
    isFlagged?: true
    isFeatured?: true
    isPinned?: true
    allowComments?: true
    publishedAt?: true
    flaggedAt?: true
    scheduledAt?: true
    createdAt?: true
    updatedAt?: true
    generatedById?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    slug?: true
    content?: true
    excerpt?: true
    format?: true
    status?: true
    visibility?: true
    featuredImage?: true
    featuredVideo?: true
    galleryImages?: true
    authorId?: true
    authorBio?: true
    authorTitle?: true
    author?: true
    categoryId?: true
    seoTitle?: true
    seoDescription?: true
    seoKeywords?: true
    seoScore?: true
    shares?: true
    readTime?: true
    wordCount?: true
    characterCount?: true
    likes?: true
    views?: true
    flagReason?: true
    isFlagged?: true
    isFeatured?: true
    isPinned?: true
    allowComments?: true
    publishedAt?: true
    flaggedAt?: true
    scheduledAt?: true
    createdAt?: true
    updatedAt?: true
    generatedById?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _avg?: BlogPostAvgAggregateInputType
    _sum?: BlogPostSumAggregateInputType
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    title: string
    subtitle: string | null
    slug: string
    content: string
    excerpt: string | null
    format: $Enums.ContentFormat
    status: $Enums.PostStatus
    visibility: $Enums.PostVisibility
    featuredImage: string
    featuredVideo: string | null
    galleryImages: string[]
    authorId: string
    authorBio: string
    authorTitle: string
    author: string
    categoryId: string | null
    seoTitle: string | null
    seoDescription: string | null
    seoKeywords: string[]
    seoScore: number
    shares: number
    readTime: number
    wordCount: number
    characterCount: number
    likes: number
    views: number
    flagReason: string | null
    isFlagged: boolean
    isFeatured: boolean
    isPinned: boolean
    allowComments: boolean
    publishedAt: Date | null
    flaggedAt: Date | null
    scheduledAt: Date | null
    createdAt: Date
    updatedAt: Date
    generatedById: string | null
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    format?: boolean
    status?: boolean
    visibility?: boolean
    featuredImage?: boolean
    featuredVideo?: boolean
    galleryImages?: boolean
    authorId?: boolean
    authorBio?: boolean
    authorTitle?: boolean
    author?: boolean
    categoryId?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    seoKeywords?: boolean
    seoScore?: boolean
    shares?: boolean
    readTime?: boolean
    wordCount?: boolean
    characterCount?: boolean
    likes?: boolean
    views?: boolean
    flagReason?: boolean
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: boolean
    flaggedAt?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generatedById?: boolean
    comments?: boolean | BlogPost$commentsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    aiGeneration?: boolean | BlogPost$aiGenerationArgs<ExtArgs>
    viewsCount?: boolean | BlogPost$viewsCountArgs<ExtArgs>
    flaggedPosts?: boolean | BlogPost$flaggedPostsArgs<ExtArgs>
    tags?: boolean | BlogPost$tagsArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    format?: boolean
    status?: boolean
    visibility?: boolean
    featuredImage?: boolean
    featuredVideo?: boolean
    galleryImages?: boolean
    authorId?: boolean
    authorBio?: boolean
    authorTitle?: boolean
    author?: boolean
    categoryId?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    seoKeywords?: boolean
    seoScore?: boolean
    shares?: boolean
    readTime?: boolean
    wordCount?: boolean
    characterCount?: boolean
    likes?: boolean
    views?: boolean
    flagReason?: boolean
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: boolean
    flaggedAt?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generatedById?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    aiGeneration?: boolean | BlogPost$aiGenerationArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    format?: boolean
    status?: boolean
    visibility?: boolean
    featuredImage?: boolean
    featuredVideo?: boolean
    galleryImages?: boolean
    authorId?: boolean
    authorBio?: boolean
    authorTitle?: boolean
    author?: boolean
    categoryId?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    seoKeywords?: boolean
    seoScore?: boolean
    shares?: boolean
    readTime?: boolean
    wordCount?: boolean
    characterCount?: boolean
    likes?: boolean
    views?: boolean
    flagReason?: boolean
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: boolean
    flaggedAt?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generatedById?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    aiGeneration?: boolean | BlogPost$aiGenerationArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    format?: boolean
    status?: boolean
    visibility?: boolean
    featuredImage?: boolean
    featuredVideo?: boolean
    galleryImages?: boolean
    authorId?: boolean
    authorBio?: boolean
    authorTitle?: boolean
    author?: boolean
    categoryId?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    seoKeywords?: boolean
    seoScore?: boolean
    shares?: boolean
    readTime?: boolean
    wordCount?: boolean
    characterCount?: boolean
    likes?: boolean
    views?: boolean
    flagReason?: boolean
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: boolean
    flaggedAt?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generatedById?: boolean
  }

  export type BlogPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "subtitle" | "slug" | "content" | "excerpt" | "format" | "status" | "visibility" | "featuredImage" | "featuredVideo" | "galleryImages" | "authorId" | "authorBio" | "authorTitle" | "author" | "categoryId" | "seoTitle" | "seoDescription" | "seoKeywords" | "seoScore" | "shares" | "readTime" | "wordCount" | "characterCount" | "likes" | "views" | "flagReason" | "isFlagged" | "isFeatured" | "isPinned" | "allowComments" | "publishedAt" | "flaggedAt" | "scheduledAt" | "createdAt" | "updatedAt" | "generatedById", ExtArgs["result"]["blogPost"]>
  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | BlogPost$commentsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    aiGeneration?: boolean | BlogPost$aiGenerationArgs<ExtArgs>
    viewsCount?: boolean | BlogPost$viewsCountArgs<ExtArgs>
    flaggedPosts?: boolean | BlogPost$flaggedPostsArgs<ExtArgs>
    tags?: boolean | BlogPost$tagsArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    aiGeneration?: boolean | BlogPost$aiGenerationArgs<ExtArgs>
  }
  export type BlogPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    aiGeneration?: boolean | BlogPost$aiGenerationArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      comments: Prisma.$BlogCommentPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      category: Prisma.$BlogCategoryPayload<ExtArgs> | null
      aiGeneration: Prisma.$BlogAIGenerationPayload<ExtArgs> | null
      viewsCount: Prisma.$BlogPostViewPayload<ExtArgs>[]
      flaggedPosts: Prisma.$FlagedBlogPostPayload<ExtArgs>[]
      tags: Prisma.$BlogTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      subtitle: string | null
      slug: string
      content: string
      excerpt: string | null
      format: $Enums.ContentFormat
      status: $Enums.PostStatus
      visibility: $Enums.PostVisibility
      featuredImage: string
      featuredVideo: string | null
      galleryImages: string[]
      authorId: string
      authorBio: string
      authorTitle: string
      author: string
      categoryId: string | null
      seoTitle: string | null
      seoDescription: string | null
      seoKeywords: string[]
      seoScore: number
      shares: number
      readTime: number
      wordCount: number
      characterCount: number
      likes: number
      views: number
      flagReason: string | null
      isFlagged: boolean
      isFeatured: boolean
      isPinned: boolean
      allowComments: boolean
      publishedAt: Date | null
      flaggedAt: Date | null
      scheduledAt: Date | null
      createdAt: Date
      updatedAt: Date
      generatedById: string | null
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts and returns the data updated in the database.
     * @param {BlogPostUpdateManyAndReturnArgs} args - Arguments to update many BlogPosts.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogPostUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends BlogPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends BlogPost$categoryArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$categoryArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    aiGeneration<T extends BlogPost$aiGenerationArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$aiGenerationArgs<ExtArgs>>): Prisma__BlogAIGenerationClient<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    viewsCount<T extends BlogPost$viewsCountArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$viewsCountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flaggedPosts<T extends BlogPost$flaggedPostsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$flaggedPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends BlogPost$tagsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly subtitle: FieldRef<"BlogPost", 'String'>
    readonly slug: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly format: FieldRef<"BlogPost", 'ContentFormat'>
    readonly status: FieldRef<"BlogPost", 'PostStatus'>
    readonly visibility: FieldRef<"BlogPost", 'PostVisibility'>
    readonly featuredImage: FieldRef<"BlogPost", 'String'>
    readonly featuredVideo: FieldRef<"BlogPost", 'String'>
    readonly galleryImages: FieldRef<"BlogPost", 'String[]'>
    readonly authorId: FieldRef<"BlogPost", 'String'>
    readonly authorBio: FieldRef<"BlogPost", 'String'>
    readonly authorTitle: FieldRef<"BlogPost", 'String'>
    readonly author: FieldRef<"BlogPost", 'String'>
    readonly categoryId: FieldRef<"BlogPost", 'String'>
    readonly seoTitle: FieldRef<"BlogPost", 'String'>
    readonly seoDescription: FieldRef<"BlogPost", 'String'>
    readonly seoKeywords: FieldRef<"BlogPost", 'String[]'>
    readonly seoScore: FieldRef<"BlogPost", 'Int'>
    readonly shares: FieldRef<"BlogPost", 'Int'>
    readonly readTime: FieldRef<"BlogPost", 'Int'>
    readonly wordCount: FieldRef<"BlogPost", 'Int'>
    readonly characterCount: FieldRef<"BlogPost", 'Int'>
    readonly likes: FieldRef<"BlogPost", 'Int'>
    readonly views: FieldRef<"BlogPost", 'Int'>
    readonly flagReason: FieldRef<"BlogPost", 'String'>
    readonly isFlagged: FieldRef<"BlogPost", 'Boolean'>
    readonly isFeatured: FieldRef<"BlogPost", 'Boolean'>
    readonly isPinned: FieldRef<"BlogPost", 'Boolean'>
    readonly allowComments: FieldRef<"BlogPost", 'Boolean'>
    readonly publishedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly flaggedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly scheduledAt: FieldRef<"BlogPost", 'DateTime'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly generatedById: FieldRef<"BlogPost", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
  }

  /**
   * BlogPost updateManyAndReturn
   */
  export type BlogPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to delete.
     */
    limit?: number
  }

  /**
   * BlogPost.comments
   */
  export type BlogPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    where?: BlogCommentWhereInput
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    cursor?: BlogCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogPost.category
   */
  export type BlogPost$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    where?: BlogCategoryWhereInput
  }

  /**
   * BlogPost.aiGeneration
   */
  export type BlogPost$aiGenerationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationInclude<ExtArgs> | null
    where?: BlogAIGenerationWhereInput
  }

  /**
   * BlogPost.viewsCount
   */
  export type BlogPost$viewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewInclude<ExtArgs> | null
    where?: BlogPostViewWhereInput
    orderBy?: BlogPostViewOrderByWithRelationInput | BlogPostViewOrderByWithRelationInput[]
    cursor?: BlogPostViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostViewScalarFieldEnum | BlogPostViewScalarFieldEnum[]
  }

  /**
   * BlogPost.flaggedPosts
   */
  export type BlogPost$flaggedPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostInclude<ExtArgs> | null
    where?: FlagedBlogPostWhereInput
    orderBy?: FlagedBlogPostOrderByWithRelationInput | FlagedBlogPostOrderByWithRelationInput[]
    cursor?: FlagedBlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlagedBlogPostScalarFieldEnum | FlagedBlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost.tags
   */
  export type BlogPost$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    where?: BlogTagWhereInput
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    cursor?: BlogTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model FlagedBlogPost
   */

  export type AggregateFlagedBlogPost = {
    _count: FlagedBlogPostCountAggregateOutputType | null
    _min: FlagedBlogPostMinAggregateOutputType | null
    _max: FlagedBlogPostMaxAggregateOutputType | null
  }

  export type FlagedBlogPostMinAggregateOutputType = {
    id: string | null
    reason: string | null
    comment: string | null
    flaggedBy: string | null
    status: $Enums.FlagStatus | null
    createdAt: Date | null
    reviewedAt: Date | null
    postId: string | null
    userId: string | null
  }

  export type FlagedBlogPostMaxAggregateOutputType = {
    id: string | null
    reason: string | null
    comment: string | null
    flaggedBy: string | null
    status: $Enums.FlagStatus | null
    createdAt: Date | null
    reviewedAt: Date | null
    postId: string | null
    userId: string | null
  }

  export type FlagedBlogPostCountAggregateOutputType = {
    id: number
    reason: number
    comment: number
    flaggedBy: number
    status: number
    createdAt: number
    reviewedAt: number
    postId: number
    userId: number
    _all: number
  }


  export type FlagedBlogPostMinAggregateInputType = {
    id?: true
    reason?: true
    comment?: true
    flaggedBy?: true
    status?: true
    createdAt?: true
    reviewedAt?: true
    postId?: true
    userId?: true
  }

  export type FlagedBlogPostMaxAggregateInputType = {
    id?: true
    reason?: true
    comment?: true
    flaggedBy?: true
    status?: true
    createdAt?: true
    reviewedAt?: true
    postId?: true
    userId?: true
  }

  export type FlagedBlogPostCountAggregateInputType = {
    id?: true
    reason?: true
    comment?: true
    flaggedBy?: true
    status?: true
    createdAt?: true
    reviewedAt?: true
    postId?: true
    userId?: true
    _all?: true
  }

  export type FlagedBlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlagedBlogPost to aggregate.
     */
    where?: FlagedBlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlagedBlogPosts to fetch.
     */
    orderBy?: FlagedBlogPostOrderByWithRelationInput | FlagedBlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlagedBlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlagedBlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlagedBlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlagedBlogPosts
    **/
    _count?: true | FlagedBlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlagedBlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlagedBlogPostMaxAggregateInputType
  }

  export type GetFlagedBlogPostAggregateType<T extends FlagedBlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateFlagedBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlagedBlogPost[P]>
      : GetScalarType<T[P], AggregateFlagedBlogPost[P]>
  }




  export type FlagedBlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagedBlogPostWhereInput
    orderBy?: FlagedBlogPostOrderByWithAggregationInput | FlagedBlogPostOrderByWithAggregationInput[]
    by: FlagedBlogPostScalarFieldEnum[] | FlagedBlogPostScalarFieldEnum
    having?: FlagedBlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlagedBlogPostCountAggregateInputType | true
    _min?: FlagedBlogPostMinAggregateInputType
    _max?: FlagedBlogPostMaxAggregateInputType
  }

  export type FlagedBlogPostGroupByOutputType = {
    id: string
    reason: string
    comment: string
    flaggedBy: string
    status: $Enums.FlagStatus
    createdAt: Date
    reviewedAt: Date | null
    postId: string
    userId: string
    _count: FlagedBlogPostCountAggregateOutputType | null
    _min: FlagedBlogPostMinAggregateOutputType | null
    _max: FlagedBlogPostMaxAggregateOutputType | null
  }

  type GetFlagedBlogPostGroupByPayload<T extends FlagedBlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlagedBlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlagedBlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlagedBlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], FlagedBlogPostGroupByOutputType[P]>
        }
      >
    >


  export type FlagedBlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    comment?: boolean
    flaggedBy?: boolean
    status?: boolean
    createdAt?: boolean
    reviewedAt?: boolean
    postId?: boolean
    userId?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flagedBlogPost"]>

  export type FlagedBlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    comment?: boolean
    flaggedBy?: boolean
    status?: boolean
    createdAt?: boolean
    reviewedAt?: boolean
    postId?: boolean
    userId?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flagedBlogPost"]>

  export type FlagedBlogPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    comment?: boolean
    flaggedBy?: boolean
    status?: boolean
    createdAt?: boolean
    reviewedAt?: boolean
    postId?: boolean
    userId?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flagedBlogPost"]>

  export type FlagedBlogPostSelectScalar = {
    id?: boolean
    reason?: boolean
    comment?: boolean
    flaggedBy?: boolean
    status?: boolean
    createdAt?: boolean
    reviewedAt?: boolean
    postId?: boolean
    userId?: boolean
  }

  export type FlagedBlogPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reason" | "comment" | "flaggedBy" | "status" | "createdAt" | "reviewedAt" | "postId" | "userId", ExtArgs["result"]["flagedBlogPost"]>
  export type FlagedBlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FlagedBlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FlagedBlogPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FlagedBlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlagedBlogPost"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reason: string
      comment: string
      flaggedBy: string
      status: $Enums.FlagStatus
      createdAt: Date
      reviewedAt: Date | null
      postId: string
      userId: string
    }, ExtArgs["result"]["flagedBlogPost"]>
    composites: {}
  }

  type FlagedBlogPostGetPayload<S extends boolean | null | undefined | FlagedBlogPostDefaultArgs> = $Result.GetResult<Prisma.$FlagedBlogPostPayload, S>

  type FlagedBlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlagedBlogPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlagedBlogPostCountAggregateInputType | true
    }

  export interface FlagedBlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlagedBlogPost'], meta: { name: 'FlagedBlogPost' } }
    /**
     * Find zero or one FlagedBlogPost that matches the filter.
     * @param {FlagedBlogPostFindUniqueArgs} args - Arguments to find a FlagedBlogPost
     * @example
     * // Get one FlagedBlogPost
     * const flagedBlogPost = await prisma.flagedBlogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlagedBlogPostFindUniqueArgs>(args: SelectSubset<T, FlagedBlogPostFindUniqueArgs<ExtArgs>>): Prisma__FlagedBlogPostClient<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlagedBlogPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlagedBlogPostFindUniqueOrThrowArgs} args - Arguments to find a FlagedBlogPost
     * @example
     * // Get one FlagedBlogPost
     * const flagedBlogPost = await prisma.flagedBlogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlagedBlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, FlagedBlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlagedBlogPostClient<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlagedBlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagedBlogPostFindFirstArgs} args - Arguments to find a FlagedBlogPost
     * @example
     * // Get one FlagedBlogPost
     * const flagedBlogPost = await prisma.flagedBlogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlagedBlogPostFindFirstArgs>(args?: SelectSubset<T, FlagedBlogPostFindFirstArgs<ExtArgs>>): Prisma__FlagedBlogPostClient<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlagedBlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagedBlogPostFindFirstOrThrowArgs} args - Arguments to find a FlagedBlogPost
     * @example
     * // Get one FlagedBlogPost
     * const flagedBlogPost = await prisma.flagedBlogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlagedBlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, FlagedBlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlagedBlogPostClient<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlagedBlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagedBlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlagedBlogPosts
     * const flagedBlogPosts = await prisma.flagedBlogPost.findMany()
     * 
     * // Get first 10 FlagedBlogPosts
     * const flagedBlogPosts = await prisma.flagedBlogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flagedBlogPostWithIdOnly = await prisma.flagedBlogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlagedBlogPostFindManyArgs>(args?: SelectSubset<T, FlagedBlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlagedBlogPost.
     * @param {FlagedBlogPostCreateArgs} args - Arguments to create a FlagedBlogPost.
     * @example
     * // Create one FlagedBlogPost
     * const FlagedBlogPost = await prisma.flagedBlogPost.create({
     *   data: {
     *     // ... data to create a FlagedBlogPost
     *   }
     * })
     * 
     */
    create<T extends FlagedBlogPostCreateArgs>(args: SelectSubset<T, FlagedBlogPostCreateArgs<ExtArgs>>): Prisma__FlagedBlogPostClient<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlagedBlogPosts.
     * @param {FlagedBlogPostCreateManyArgs} args - Arguments to create many FlagedBlogPosts.
     * @example
     * // Create many FlagedBlogPosts
     * const flagedBlogPost = await prisma.flagedBlogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlagedBlogPostCreateManyArgs>(args?: SelectSubset<T, FlagedBlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlagedBlogPosts and returns the data saved in the database.
     * @param {FlagedBlogPostCreateManyAndReturnArgs} args - Arguments to create many FlagedBlogPosts.
     * @example
     * // Create many FlagedBlogPosts
     * const flagedBlogPost = await prisma.flagedBlogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlagedBlogPosts and only return the `id`
     * const flagedBlogPostWithIdOnly = await prisma.flagedBlogPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlagedBlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, FlagedBlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FlagedBlogPost.
     * @param {FlagedBlogPostDeleteArgs} args - Arguments to delete one FlagedBlogPost.
     * @example
     * // Delete one FlagedBlogPost
     * const FlagedBlogPost = await prisma.flagedBlogPost.delete({
     *   where: {
     *     // ... filter to delete one FlagedBlogPost
     *   }
     * })
     * 
     */
    delete<T extends FlagedBlogPostDeleteArgs>(args: SelectSubset<T, FlagedBlogPostDeleteArgs<ExtArgs>>): Prisma__FlagedBlogPostClient<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlagedBlogPost.
     * @param {FlagedBlogPostUpdateArgs} args - Arguments to update one FlagedBlogPost.
     * @example
     * // Update one FlagedBlogPost
     * const flagedBlogPost = await prisma.flagedBlogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlagedBlogPostUpdateArgs>(args: SelectSubset<T, FlagedBlogPostUpdateArgs<ExtArgs>>): Prisma__FlagedBlogPostClient<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlagedBlogPosts.
     * @param {FlagedBlogPostDeleteManyArgs} args - Arguments to filter FlagedBlogPosts to delete.
     * @example
     * // Delete a few FlagedBlogPosts
     * const { count } = await prisma.flagedBlogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlagedBlogPostDeleteManyArgs>(args?: SelectSubset<T, FlagedBlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlagedBlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagedBlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlagedBlogPosts
     * const flagedBlogPost = await prisma.flagedBlogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlagedBlogPostUpdateManyArgs>(args: SelectSubset<T, FlagedBlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlagedBlogPosts and returns the data updated in the database.
     * @param {FlagedBlogPostUpdateManyAndReturnArgs} args - Arguments to update many FlagedBlogPosts.
     * @example
     * // Update many FlagedBlogPosts
     * const flagedBlogPost = await prisma.flagedBlogPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlagedBlogPosts and only return the `id`
     * const flagedBlogPostWithIdOnly = await prisma.flagedBlogPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlagedBlogPostUpdateManyAndReturnArgs>(args: SelectSubset<T, FlagedBlogPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FlagedBlogPost.
     * @param {FlagedBlogPostUpsertArgs} args - Arguments to update or create a FlagedBlogPost.
     * @example
     * // Update or create a FlagedBlogPost
     * const flagedBlogPost = await prisma.flagedBlogPost.upsert({
     *   create: {
     *     // ... data to create a FlagedBlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlagedBlogPost we want to update
     *   }
     * })
     */
    upsert<T extends FlagedBlogPostUpsertArgs>(args: SelectSubset<T, FlagedBlogPostUpsertArgs<ExtArgs>>): Prisma__FlagedBlogPostClient<$Result.GetResult<Prisma.$FlagedBlogPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlagedBlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagedBlogPostCountArgs} args - Arguments to filter FlagedBlogPosts to count.
     * @example
     * // Count the number of FlagedBlogPosts
     * const count = await prisma.flagedBlogPost.count({
     *   where: {
     *     // ... the filter for the FlagedBlogPosts we want to count
     *   }
     * })
    **/
    count<T extends FlagedBlogPostCountArgs>(
      args?: Subset<T, FlagedBlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlagedBlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlagedBlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagedBlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlagedBlogPostAggregateArgs>(args: Subset<T, FlagedBlogPostAggregateArgs>): Prisma.PrismaPromise<GetFlagedBlogPostAggregateType<T>>

    /**
     * Group by FlagedBlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagedBlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlagedBlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlagedBlogPostGroupByArgs['orderBy'] }
        : { orderBy?: FlagedBlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlagedBlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlagedBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlagedBlogPost model
   */
  readonly fields: FlagedBlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlagedBlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlagedBlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlagedBlogPost model
   */
  interface FlagedBlogPostFieldRefs {
    readonly id: FieldRef<"FlagedBlogPost", 'String'>
    readonly reason: FieldRef<"FlagedBlogPost", 'String'>
    readonly comment: FieldRef<"FlagedBlogPost", 'String'>
    readonly flaggedBy: FieldRef<"FlagedBlogPost", 'String'>
    readonly status: FieldRef<"FlagedBlogPost", 'FlagStatus'>
    readonly createdAt: FieldRef<"FlagedBlogPost", 'DateTime'>
    readonly reviewedAt: FieldRef<"FlagedBlogPost", 'DateTime'>
    readonly postId: FieldRef<"FlagedBlogPost", 'String'>
    readonly userId: FieldRef<"FlagedBlogPost", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FlagedBlogPost findUnique
   */
  export type FlagedBlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostInclude<ExtArgs> | null
    /**
     * Filter, which FlagedBlogPost to fetch.
     */
    where: FlagedBlogPostWhereUniqueInput
  }

  /**
   * FlagedBlogPost findUniqueOrThrow
   */
  export type FlagedBlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostInclude<ExtArgs> | null
    /**
     * Filter, which FlagedBlogPost to fetch.
     */
    where: FlagedBlogPostWhereUniqueInput
  }

  /**
   * FlagedBlogPost findFirst
   */
  export type FlagedBlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostInclude<ExtArgs> | null
    /**
     * Filter, which FlagedBlogPost to fetch.
     */
    where?: FlagedBlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlagedBlogPosts to fetch.
     */
    orderBy?: FlagedBlogPostOrderByWithRelationInput | FlagedBlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlagedBlogPosts.
     */
    cursor?: FlagedBlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlagedBlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlagedBlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlagedBlogPosts.
     */
    distinct?: FlagedBlogPostScalarFieldEnum | FlagedBlogPostScalarFieldEnum[]
  }

  /**
   * FlagedBlogPost findFirstOrThrow
   */
  export type FlagedBlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostInclude<ExtArgs> | null
    /**
     * Filter, which FlagedBlogPost to fetch.
     */
    where?: FlagedBlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlagedBlogPosts to fetch.
     */
    orderBy?: FlagedBlogPostOrderByWithRelationInput | FlagedBlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlagedBlogPosts.
     */
    cursor?: FlagedBlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlagedBlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlagedBlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlagedBlogPosts.
     */
    distinct?: FlagedBlogPostScalarFieldEnum | FlagedBlogPostScalarFieldEnum[]
  }

  /**
   * FlagedBlogPost findMany
   */
  export type FlagedBlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostInclude<ExtArgs> | null
    /**
     * Filter, which FlagedBlogPosts to fetch.
     */
    where?: FlagedBlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlagedBlogPosts to fetch.
     */
    orderBy?: FlagedBlogPostOrderByWithRelationInput | FlagedBlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlagedBlogPosts.
     */
    cursor?: FlagedBlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlagedBlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlagedBlogPosts.
     */
    skip?: number
    distinct?: FlagedBlogPostScalarFieldEnum | FlagedBlogPostScalarFieldEnum[]
  }

  /**
   * FlagedBlogPost create
   */
  export type FlagedBlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a FlagedBlogPost.
     */
    data: XOR<FlagedBlogPostCreateInput, FlagedBlogPostUncheckedCreateInput>
  }

  /**
   * FlagedBlogPost createMany
   */
  export type FlagedBlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlagedBlogPosts.
     */
    data: FlagedBlogPostCreateManyInput | FlagedBlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlagedBlogPost createManyAndReturn
   */
  export type FlagedBlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * The data used to create many FlagedBlogPosts.
     */
    data: FlagedBlogPostCreateManyInput | FlagedBlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlagedBlogPost update
   */
  export type FlagedBlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a FlagedBlogPost.
     */
    data: XOR<FlagedBlogPostUpdateInput, FlagedBlogPostUncheckedUpdateInput>
    /**
     * Choose, which FlagedBlogPost to update.
     */
    where: FlagedBlogPostWhereUniqueInput
  }

  /**
   * FlagedBlogPost updateMany
   */
  export type FlagedBlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlagedBlogPosts.
     */
    data: XOR<FlagedBlogPostUpdateManyMutationInput, FlagedBlogPostUncheckedUpdateManyInput>
    /**
     * Filter which FlagedBlogPosts to update
     */
    where?: FlagedBlogPostWhereInput
    /**
     * Limit how many FlagedBlogPosts to update.
     */
    limit?: number
  }

  /**
   * FlagedBlogPost updateManyAndReturn
   */
  export type FlagedBlogPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * The data used to update FlagedBlogPosts.
     */
    data: XOR<FlagedBlogPostUpdateManyMutationInput, FlagedBlogPostUncheckedUpdateManyInput>
    /**
     * Filter which FlagedBlogPosts to update
     */
    where?: FlagedBlogPostWhereInput
    /**
     * Limit how many FlagedBlogPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlagedBlogPost upsert
   */
  export type FlagedBlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the FlagedBlogPost to update in case it exists.
     */
    where: FlagedBlogPostWhereUniqueInput
    /**
     * In case the FlagedBlogPost found by the `where` argument doesn't exist, create a new FlagedBlogPost with this data.
     */
    create: XOR<FlagedBlogPostCreateInput, FlagedBlogPostUncheckedCreateInput>
    /**
     * In case the FlagedBlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlagedBlogPostUpdateInput, FlagedBlogPostUncheckedUpdateInput>
  }

  /**
   * FlagedBlogPost delete
   */
  export type FlagedBlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostInclude<ExtArgs> | null
    /**
     * Filter which FlagedBlogPost to delete.
     */
    where: FlagedBlogPostWhereUniqueInput
  }

  /**
   * FlagedBlogPost deleteMany
   */
  export type FlagedBlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlagedBlogPosts to delete
     */
    where?: FlagedBlogPostWhereInput
    /**
     * Limit how many FlagedBlogPosts to delete.
     */
    limit?: number
  }

  /**
   * FlagedBlogPost without action
   */
  export type FlagedBlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlagedBlogPost
     */
    select?: FlagedBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlagedBlogPost
     */
    omit?: FlagedBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagedBlogPostInclude<ExtArgs> | null
  }


  /**
   * Model BlogPostView
   */

  export type AggregateBlogPostView = {
    _count: BlogPostViewCountAggregateOutputType | null
    _min: BlogPostViewMinAggregateOutputType | null
    _max: BlogPostViewMaxAggregateOutputType | null
  }

  export type BlogPostViewMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    externalName: string | null
    createdAt: Date | null
  }

  export type BlogPostViewMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    externalName: string | null
    createdAt: Date | null
  }

  export type BlogPostViewCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    externalName: number
    createdAt: number
    _all: number
  }


  export type BlogPostViewMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    externalName?: true
    createdAt?: true
  }

  export type BlogPostViewMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    externalName?: true
    createdAt?: true
  }

  export type BlogPostViewCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    externalName?: true
    createdAt?: true
    _all?: true
  }

  export type BlogPostViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPostView to aggregate.
     */
    where?: BlogPostViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostViews to fetch.
     */
    orderBy?: BlogPostViewOrderByWithRelationInput | BlogPostViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPostViews
    **/
    _count?: true | BlogPostViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostViewMaxAggregateInputType
  }

  export type GetBlogPostViewAggregateType<T extends BlogPostViewAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPostView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPostView[P]>
      : GetScalarType<T[P], AggregateBlogPostView[P]>
  }




  export type BlogPostViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostViewWhereInput
    orderBy?: BlogPostViewOrderByWithAggregationInput | BlogPostViewOrderByWithAggregationInput[]
    by: BlogPostViewScalarFieldEnum[] | BlogPostViewScalarFieldEnum
    having?: BlogPostViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostViewCountAggregateInputType | true
    _min?: BlogPostViewMinAggregateInputType
    _max?: BlogPostViewMaxAggregateInputType
  }

  export type BlogPostViewGroupByOutputType = {
    id: string
    postId: string
    userId: string | null
    externalName: string | null
    createdAt: Date
    _count: BlogPostViewCountAggregateOutputType | null
    _min: BlogPostViewMinAggregateOutputType | null
    _max: BlogPostViewMaxAggregateOutputType | null
  }

  type GetBlogPostViewGroupByPayload<T extends BlogPostViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostViewGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostViewGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    externalName?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | BlogPostView$userArgs<ExtArgs>
  }, ExtArgs["result"]["blogPostView"]>

  export type BlogPostViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    externalName?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | BlogPostView$userArgs<ExtArgs>
  }, ExtArgs["result"]["blogPostView"]>

  export type BlogPostViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    externalName?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | BlogPostView$userArgs<ExtArgs>
  }, ExtArgs["result"]["blogPostView"]>

  export type BlogPostViewSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    externalName?: boolean
    createdAt?: boolean
  }

  export type BlogPostViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "externalName" | "createdAt", ExtArgs["result"]["blogPostView"]>
  export type BlogPostViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | BlogPostView$userArgs<ExtArgs>
  }
  export type BlogPostViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | BlogPostView$userArgs<ExtArgs>
  }
  export type BlogPostViewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | BlogPostView$userArgs<ExtArgs>
  }

  export type $BlogPostViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPostView"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string | null
      externalName: string | null
      createdAt: Date
    }, ExtArgs["result"]["blogPostView"]>
    composites: {}
  }

  type BlogPostViewGetPayload<S extends boolean | null | undefined | BlogPostViewDefaultArgs> = $Result.GetResult<Prisma.$BlogPostViewPayload, S>

  type BlogPostViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogPostViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogPostViewCountAggregateInputType | true
    }

  export interface BlogPostViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPostView'], meta: { name: 'BlogPostView' } }
    /**
     * Find zero or one BlogPostView that matches the filter.
     * @param {BlogPostViewFindUniqueArgs} args - Arguments to find a BlogPostView
     * @example
     * // Get one BlogPostView
     * const blogPostView = await prisma.blogPostView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostViewFindUniqueArgs>(args: SelectSubset<T, BlogPostViewFindUniqueArgs<ExtArgs>>): Prisma__BlogPostViewClient<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogPostView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogPostViewFindUniqueOrThrowArgs} args - Arguments to find a BlogPostView
     * @example
     * // Get one BlogPostView
     * const blogPostView = await prisma.blogPostView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostViewFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostViewClient<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPostView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostViewFindFirstArgs} args - Arguments to find a BlogPostView
     * @example
     * // Get one BlogPostView
     * const blogPostView = await prisma.blogPostView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostViewFindFirstArgs>(args?: SelectSubset<T, BlogPostViewFindFirstArgs<ExtArgs>>): Prisma__BlogPostViewClient<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPostView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostViewFindFirstOrThrowArgs} args - Arguments to find a BlogPostView
     * @example
     * // Get one BlogPostView
     * const blogPostView = await prisma.blogPostView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostViewFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostViewClient<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogPostViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPostViews
     * const blogPostViews = await prisma.blogPostView.findMany()
     * 
     * // Get first 10 BlogPostViews
     * const blogPostViews = await prisma.blogPostView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostViewWithIdOnly = await prisma.blogPostView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostViewFindManyArgs>(args?: SelectSubset<T, BlogPostViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogPostView.
     * @param {BlogPostViewCreateArgs} args - Arguments to create a BlogPostView.
     * @example
     * // Create one BlogPostView
     * const BlogPostView = await prisma.blogPostView.create({
     *   data: {
     *     // ... data to create a BlogPostView
     *   }
     * })
     * 
     */
    create<T extends BlogPostViewCreateArgs>(args: SelectSubset<T, BlogPostViewCreateArgs<ExtArgs>>): Prisma__BlogPostViewClient<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogPostViews.
     * @param {BlogPostViewCreateManyArgs} args - Arguments to create many BlogPostViews.
     * @example
     * // Create many BlogPostViews
     * const blogPostView = await prisma.blogPostView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostViewCreateManyArgs>(args?: SelectSubset<T, BlogPostViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPostViews and returns the data saved in the database.
     * @param {BlogPostViewCreateManyAndReturnArgs} args - Arguments to create many BlogPostViews.
     * @example
     * // Create many BlogPostViews
     * const blogPostView = await prisma.blogPostView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPostViews and only return the `id`
     * const blogPostViewWithIdOnly = await prisma.blogPostView.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostViewCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogPostView.
     * @param {BlogPostViewDeleteArgs} args - Arguments to delete one BlogPostView.
     * @example
     * // Delete one BlogPostView
     * const BlogPostView = await prisma.blogPostView.delete({
     *   where: {
     *     // ... filter to delete one BlogPostView
     *   }
     * })
     * 
     */
    delete<T extends BlogPostViewDeleteArgs>(args: SelectSubset<T, BlogPostViewDeleteArgs<ExtArgs>>): Prisma__BlogPostViewClient<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogPostView.
     * @param {BlogPostViewUpdateArgs} args - Arguments to update one BlogPostView.
     * @example
     * // Update one BlogPostView
     * const blogPostView = await prisma.blogPostView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostViewUpdateArgs>(args: SelectSubset<T, BlogPostViewUpdateArgs<ExtArgs>>): Prisma__BlogPostViewClient<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogPostViews.
     * @param {BlogPostViewDeleteManyArgs} args - Arguments to filter BlogPostViews to delete.
     * @example
     * // Delete a few BlogPostViews
     * const { count } = await prisma.blogPostView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostViewDeleteManyArgs>(args?: SelectSubset<T, BlogPostViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPostViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPostViews
     * const blogPostView = await prisma.blogPostView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostViewUpdateManyArgs>(args: SelectSubset<T, BlogPostViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPostViews and returns the data updated in the database.
     * @param {BlogPostViewUpdateManyAndReturnArgs} args - Arguments to update many BlogPostViews.
     * @example
     * // Update many BlogPostViews
     * const blogPostView = await prisma.blogPostView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogPostViews and only return the `id`
     * const blogPostViewWithIdOnly = await prisma.blogPostView.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogPostViewUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogPostViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogPostView.
     * @param {BlogPostViewUpsertArgs} args - Arguments to update or create a BlogPostView.
     * @example
     * // Update or create a BlogPostView
     * const blogPostView = await prisma.blogPostView.upsert({
     *   create: {
     *     // ... data to create a BlogPostView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPostView we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostViewUpsertArgs>(args: SelectSubset<T, BlogPostViewUpsertArgs<ExtArgs>>): Prisma__BlogPostViewClient<$Result.GetResult<Prisma.$BlogPostViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogPostViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostViewCountArgs} args - Arguments to filter BlogPostViews to count.
     * @example
     * // Count the number of BlogPostViews
     * const count = await prisma.blogPostView.count({
     *   where: {
     *     // ... the filter for the BlogPostViews we want to count
     *   }
     * })
    **/
    count<T extends BlogPostViewCountArgs>(
      args?: Subset<T, BlogPostViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPostView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostViewAggregateArgs>(args: Subset<T, BlogPostViewAggregateArgs>): Prisma.PrismaPromise<GetBlogPostViewAggregateType<T>>

    /**
     * Group by BlogPostView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostViewGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPostView model
   */
  readonly fields: BlogPostViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPostView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends BlogPostView$userArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostView$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPostView model
   */
  interface BlogPostViewFieldRefs {
    readonly id: FieldRef<"BlogPostView", 'String'>
    readonly postId: FieldRef<"BlogPostView", 'String'>
    readonly userId: FieldRef<"BlogPostView", 'String'>
    readonly externalName: FieldRef<"BlogPostView", 'String'>
    readonly createdAt: FieldRef<"BlogPostView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogPostView findUnique
   */
  export type BlogPostViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostView to fetch.
     */
    where: BlogPostViewWhereUniqueInput
  }

  /**
   * BlogPostView findUniqueOrThrow
   */
  export type BlogPostViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostView to fetch.
     */
    where: BlogPostViewWhereUniqueInput
  }

  /**
   * BlogPostView findFirst
   */
  export type BlogPostViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostView to fetch.
     */
    where?: BlogPostViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostViews to fetch.
     */
    orderBy?: BlogPostViewOrderByWithRelationInput | BlogPostViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPostViews.
     */
    cursor?: BlogPostViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPostViews.
     */
    distinct?: BlogPostViewScalarFieldEnum | BlogPostViewScalarFieldEnum[]
  }

  /**
   * BlogPostView findFirstOrThrow
   */
  export type BlogPostViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostView to fetch.
     */
    where?: BlogPostViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostViews to fetch.
     */
    orderBy?: BlogPostViewOrderByWithRelationInput | BlogPostViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPostViews.
     */
    cursor?: BlogPostViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPostViews.
     */
    distinct?: BlogPostViewScalarFieldEnum | BlogPostViewScalarFieldEnum[]
  }

  /**
   * BlogPostView findMany
   */
  export type BlogPostViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostViews to fetch.
     */
    where?: BlogPostViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostViews to fetch.
     */
    orderBy?: BlogPostViewOrderByWithRelationInput | BlogPostViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPostViews.
     */
    cursor?: BlogPostViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostViews.
     */
    skip?: number
    distinct?: BlogPostViewScalarFieldEnum | BlogPostViewScalarFieldEnum[]
  }

  /**
   * BlogPostView create
   */
  export type BlogPostViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPostView.
     */
    data: XOR<BlogPostViewCreateInput, BlogPostViewUncheckedCreateInput>
  }

  /**
   * BlogPostView createMany
   */
  export type BlogPostViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPostViews.
     */
    data: BlogPostViewCreateManyInput | BlogPostViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPostView createManyAndReturn
   */
  export type BlogPostViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * The data used to create many BlogPostViews.
     */
    data: BlogPostViewCreateManyInput | BlogPostViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPostView update
   */
  export type BlogPostViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPostView.
     */
    data: XOR<BlogPostViewUpdateInput, BlogPostViewUncheckedUpdateInput>
    /**
     * Choose, which BlogPostView to update.
     */
    where: BlogPostViewWhereUniqueInput
  }

  /**
   * BlogPostView updateMany
   */
  export type BlogPostViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPostViews.
     */
    data: XOR<BlogPostViewUpdateManyMutationInput, BlogPostViewUncheckedUpdateManyInput>
    /**
     * Filter which BlogPostViews to update
     */
    where?: BlogPostViewWhereInput
    /**
     * Limit how many BlogPostViews to update.
     */
    limit?: number
  }

  /**
   * BlogPostView updateManyAndReturn
   */
  export type BlogPostViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * The data used to update BlogPostViews.
     */
    data: XOR<BlogPostViewUpdateManyMutationInput, BlogPostViewUncheckedUpdateManyInput>
    /**
     * Filter which BlogPostViews to update
     */
    where?: BlogPostViewWhereInput
    /**
     * Limit how many BlogPostViews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPostView upsert
   */
  export type BlogPostViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPostView to update in case it exists.
     */
    where: BlogPostViewWhereUniqueInput
    /**
     * In case the BlogPostView found by the `where` argument doesn't exist, create a new BlogPostView with this data.
     */
    create: XOR<BlogPostViewCreateInput, BlogPostViewUncheckedCreateInput>
    /**
     * In case the BlogPostView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostViewUpdateInput, BlogPostViewUncheckedUpdateInput>
  }

  /**
   * BlogPostView delete
   */
  export type BlogPostViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewInclude<ExtArgs> | null
    /**
     * Filter which BlogPostView to delete.
     */
    where: BlogPostViewWhereUniqueInput
  }

  /**
   * BlogPostView deleteMany
   */
  export type BlogPostViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPostViews to delete
     */
    where?: BlogPostViewWhereInput
    /**
     * Limit how many BlogPostViews to delete.
     */
    limit?: number
  }

  /**
   * BlogPostView.user
   */
  export type BlogPostView$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BlogPostView without action
   */
  export type BlogPostViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostView
     */
    select?: BlogPostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostView
     */
    omit?: BlogPostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostViewInclude<ExtArgs> | null
  }


  /**
   * Model BlogCategory
   */

  export type AggregateBlogCategory = {
    _count: BlogCategoryCountAggregateOutputType | null
    _min: BlogCategoryMinAggregateOutputType | null
    _max: BlogCategoryMaxAggregateOutputType | null
  }

  export type BlogCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogCategory to aggregate.
     */
    where?: BlogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogCategories to fetch.
     */
    orderBy?: BlogCategoryOrderByWithRelationInput | BlogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogCategories
    **/
    _count?: true | BlogCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogCategoryMaxAggregateInputType
  }

  export type GetBlogCategoryAggregateType<T extends BlogCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogCategory[P]>
      : GetScalarType<T[P], AggregateBlogCategory[P]>
  }




  export type BlogCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCategoryWhereInput
    orderBy?: BlogCategoryOrderByWithAggregationInput | BlogCategoryOrderByWithAggregationInput[]
    by: BlogCategoryScalarFieldEnum[] | BlogCategoryScalarFieldEnum
    having?: BlogCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCategoryCountAggregateInputType | true
    _min?: BlogCategoryMinAggregateInputType
    _max?: BlogCategoryMaxAggregateInputType
  }

  export type BlogCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: BlogCategoryCountAggregateOutputType | null
    _min: BlogCategoryMinAggregateOutputType | null
    _max: BlogCategoryMaxAggregateOutputType | null
  }

  type GetBlogCategoryGroupByPayload<T extends BlogCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], BlogCategoryGroupByOutputType[P]>
        }
      >
    >


  export type BlogCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | BlogCategory$postsArgs<ExtArgs>
    _count?: boolean | BlogCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogCategory"]>

  export type BlogCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blogCategory"]>

  export type BlogCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blogCategory"]>

  export type BlogCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["blogCategory"]>
  export type BlogCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | BlogCategory$postsArgs<ExtArgs>
    _count?: boolean | BlogCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BlogCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BlogCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogCategory"
    objects: {
      posts: Prisma.$BlogPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogCategory"]>
    composites: {}
  }

  type BlogCategoryGetPayload<S extends boolean | null | undefined | BlogCategoryDefaultArgs> = $Result.GetResult<Prisma.$BlogCategoryPayload, S>

  type BlogCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogCategoryCountAggregateInputType | true
    }

  export interface BlogCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogCategory'], meta: { name: 'BlogCategory' } }
    /**
     * Find zero or one BlogCategory that matches the filter.
     * @param {BlogCategoryFindUniqueArgs} args - Arguments to find a BlogCategory
     * @example
     * // Get one BlogCategory
     * const blogCategory = await prisma.blogCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogCategoryFindUniqueArgs>(args: SelectSubset<T, BlogCategoryFindUniqueArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogCategoryFindUniqueOrThrowArgs} args - Arguments to find a BlogCategory
     * @example
     * // Get one BlogCategory
     * const blogCategory = await prisma.blogCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryFindFirstArgs} args - Arguments to find a BlogCategory
     * @example
     * // Get one BlogCategory
     * const blogCategory = await prisma.blogCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogCategoryFindFirstArgs>(args?: SelectSubset<T, BlogCategoryFindFirstArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryFindFirstOrThrowArgs} args - Arguments to find a BlogCategory
     * @example
     * // Get one BlogCategory
     * const blogCategory = await prisma.blogCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogCategories
     * const blogCategories = await prisma.blogCategory.findMany()
     * 
     * // Get first 10 BlogCategories
     * const blogCategories = await prisma.blogCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogCategoryWithIdOnly = await prisma.blogCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogCategoryFindManyArgs>(args?: SelectSubset<T, BlogCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogCategory.
     * @param {BlogCategoryCreateArgs} args - Arguments to create a BlogCategory.
     * @example
     * // Create one BlogCategory
     * const BlogCategory = await prisma.blogCategory.create({
     *   data: {
     *     // ... data to create a BlogCategory
     *   }
     * })
     * 
     */
    create<T extends BlogCategoryCreateArgs>(args: SelectSubset<T, BlogCategoryCreateArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogCategories.
     * @param {BlogCategoryCreateManyArgs} args - Arguments to create many BlogCategories.
     * @example
     * // Create many BlogCategories
     * const blogCategory = await prisma.blogCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogCategoryCreateManyArgs>(args?: SelectSubset<T, BlogCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogCategories and returns the data saved in the database.
     * @param {BlogCategoryCreateManyAndReturnArgs} args - Arguments to create many BlogCategories.
     * @example
     * // Create many BlogCategories
     * const blogCategory = await prisma.blogCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogCategories and only return the `id`
     * const blogCategoryWithIdOnly = await prisma.blogCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogCategory.
     * @param {BlogCategoryDeleteArgs} args - Arguments to delete one BlogCategory.
     * @example
     * // Delete one BlogCategory
     * const BlogCategory = await prisma.blogCategory.delete({
     *   where: {
     *     // ... filter to delete one BlogCategory
     *   }
     * })
     * 
     */
    delete<T extends BlogCategoryDeleteArgs>(args: SelectSubset<T, BlogCategoryDeleteArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogCategory.
     * @param {BlogCategoryUpdateArgs} args - Arguments to update one BlogCategory.
     * @example
     * // Update one BlogCategory
     * const blogCategory = await prisma.blogCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogCategoryUpdateArgs>(args: SelectSubset<T, BlogCategoryUpdateArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogCategories.
     * @param {BlogCategoryDeleteManyArgs} args - Arguments to filter BlogCategories to delete.
     * @example
     * // Delete a few BlogCategories
     * const { count } = await prisma.blogCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogCategoryDeleteManyArgs>(args?: SelectSubset<T, BlogCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogCategories
     * const blogCategory = await prisma.blogCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogCategoryUpdateManyArgs>(args: SelectSubset<T, BlogCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogCategories and returns the data updated in the database.
     * @param {BlogCategoryUpdateManyAndReturnArgs} args - Arguments to update many BlogCategories.
     * @example
     * // Update many BlogCategories
     * const blogCategory = await prisma.blogCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogCategories and only return the `id`
     * const blogCategoryWithIdOnly = await prisma.blogCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogCategory.
     * @param {BlogCategoryUpsertArgs} args - Arguments to update or create a BlogCategory.
     * @example
     * // Update or create a BlogCategory
     * const blogCategory = await prisma.blogCategory.upsert({
     *   create: {
     *     // ... data to create a BlogCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogCategory we want to update
     *   }
     * })
     */
    upsert<T extends BlogCategoryUpsertArgs>(args: SelectSubset<T, BlogCategoryUpsertArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryCountArgs} args - Arguments to filter BlogCategories to count.
     * @example
     * // Count the number of BlogCategories
     * const count = await prisma.blogCategory.count({
     *   where: {
     *     // ... the filter for the BlogCategories we want to count
     *   }
     * })
    **/
    count<T extends BlogCategoryCountArgs>(
      args?: Subset<T, BlogCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogCategoryAggregateArgs>(args: Subset<T, BlogCategoryAggregateArgs>): Prisma.PrismaPromise<GetBlogCategoryAggregateType<T>>

    /**
     * Group by BlogCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogCategoryGroupByArgs['orderBy'] }
        : { orderBy?: BlogCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogCategory model
   */
  readonly fields: BlogCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends BlogCategory$postsArgs<ExtArgs> = {}>(args?: Subset<T, BlogCategory$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogCategory model
   */
  interface BlogCategoryFieldRefs {
    readonly id: FieldRef<"BlogCategory", 'String'>
    readonly name: FieldRef<"BlogCategory", 'String'>
    readonly description: FieldRef<"BlogCategory", 'String'>
    readonly createdAt: FieldRef<"BlogCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogCategory findUnique
   */
  export type BlogCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BlogCategory to fetch.
     */
    where: BlogCategoryWhereUniqueInput
  }

  /**
   * BlogCategory findUniqueOrThrow
   */
  export type BlogCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BlogCategory to fetch.
     */
    where: BlogCategoryWhereUniqueInput
  }

  /**
   * BlogCategory findFirst
   */
  export type BlogCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BlogCategory to fetch.
     */
    where?: BlogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogCategories to fetch.
     */
    orderBy?: BlogCategoryOrderByWithRelationInput | BlogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogCategories.
     */
    cursor?: BlogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogCategories.
     */
    distinct?: BlogCategoryScalarFieldEnum | BlogCategoryScalarFieldEnum[]
  }

  /**
   * BlogCategory findFirstOrThrow
   */
  export type BlogCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BlogCategory to fetch.
     */
    where?: BlogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogCategories to fetch.
     */
    orderBy?: BlogCategoryOrderByWithRelationInput | BlogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogCategories.
     */
    cursor?: BlogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogCategories.
     */
    distinct?: BlogCategoryScalarFieldEnum | BlogCategoryScalarFieldEnum[]
  }

  /**
   * BlogCategory findMany
   */
  export type BlogCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BlogCategories to fetch.
     */
    where?: BlogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogCategories to fetch.
     */
    orderBy?: BlogCategoryOrderByWithRelationInput | BlogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogCategories.
     */
    cursor?: BlogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogCategories.
     */
    skip?: number
    distinct?: BlogCategoryScalarFieldEnum | BlogCategoryScalarFieldEnum[]
  }

  /**
   * BlogCategory create
   */
  export type BlogCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogCategory.
     */
    data: XOR<BlogCategoryCreateInput, BlogCategoryUncheckedCreateInput>
  }

  /**
   * BlogCategory createMany
   */
  export type BlogCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogCategories.
     */
    data: BlogCategoryCreateManyInput | BlogCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogCategory createManyAndReturn
   */
  export type BlogCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many BlogCategories.
     */
    data: BlogCategoryCreateManyInput | BlogCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogCategory update
   */
  export type BlogCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogCategory.
     */
    data: XOR<BlogCategoryUpdateInput, BlogCategoryUncheckedUpdateInput>
    /**
     * Choose, which BlogCategory to update.
     */
    where: BlogCategoryWhereUniqueInput
  }

  /**
   * BlogCategory updateMany
   */
  export type BlogCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogCategories.
     */
    data: XOR<BlogCategoryUpdateManyMutationInput, BlogCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BlogCategories to update
     */
    where?: BlogCategoryWhereInput
    /**
     * Limit how many BlogCategories to update.
     */
    limit?: number
  }

  /**
   * BlogCategory updateManyAndReturn
   */
  export type BlogCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * The data used to update BlogCategories.
     */
    data: XOR<BlogCategoryUpdateManyMutationInput, BlogCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BlogCategories to update
     */
    where?: BlogCategoryWhereInput
    /**
     * Limit how many BlogCategories to update.
     */
    limit?: number
  }

  /**
   * BlogCategory upsert
   */
  export type BlogCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogCategory to update in case it exists.
     */
    where: BlogCategoryWhereUniqueInput
    /**
     * In case the BlogCategory found by the `where` argument doesn't exist, create a new BlogCategory with this data.
     */
    create: XOR<BlogCategoryCreateInput, BlogCategoryUncheckedCreateInput>
    /**
     * In case the BlogCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogCategoryUpdateInput, BlogCategoryUncheckedUpdateInput>
  }

  /**
   * BlogCategory delete
   */
  export type BlogCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * Filter which BlogCategory to delete.
     */
    where: BlogCategoryWhereUniqueInput
  }

  /**
   * BlogCategory deleteMany
   */
  export type BlogCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogCategories to delete
     */
    where?: BlogCategoryWhereInput
    /**
     * Limit how many BlogCategories to delete.
     */
    limit?: number
  }

  /**
   * BlogCategory.posts
   */
  export type BlogCategory$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogCategory without action
   */
  export type BlogCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
  }


  /**
   * Model BlogTag
   */

  export type AggregateBlogTag = {
    _count: BlogTagCountAggregateOutputType | null
    _min: BlogTagMinAggregateOutputType | null
    _max: BlogTagMaxAggregateOutputType | null
  }

  export type BlogTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogTagCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogTagMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogTagMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogTagCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogTag to aggregate.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogTags
    **/
    _count?: true | BlogTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogTagMaxAggregateInputType
  }

  export type GetBlogTagAggregateType<T extends BlogTagAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogTag[P]>
      : GetScalarType<T[P], AggregateBlogTag[P]>
  }




  export type BlogTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogTagWhereInput
    orderBy?: BlogTagOrderByWithAggregationInput | BlogTagOrderByWithAggregationInput[]
    by: BlogTagScalarFieldEnum[] | BlogTagScalarFieldEnum
    having?: BlogTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogTagCountAggregateInputType | true
    _min?: BlogTagMinAggregateInputType
    _max?: BlogTagMaxAggregateInputType
  }

  export type BlogTagGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BlogTagCountAggregateOutputType | null
    _min: BlogTagMinAggregateOutputType | null
    _max: BlogTagMaxAggregateOutputType | null
  }

  type GetBlogTagGroupByPayload<T extends BlogTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogTagGroupByOutputType[P]>
            : GetScalarType<T[P], BlogTagGroupByOutputType[P]>
        }
      >
    >


  export type BlogTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | BlogTag$postsArgs<ExtArgs>
    _count?: boolean | BlogTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["blogTag"]>
  export type BlogTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | BlogTag$postsArgs<ExtArgs>
    _count?: boolean | BlogTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BlogTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BlogTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogTag"
    objects: {
      posts: Prisma.$BlogPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogTag"]>
    composites: {}
  }

  type BlogTagGetPayload<S extends boolean | null | undefined | BlogTagDefaultArgs> = $Result.GetResult<Prisma.$BlogTagPayload, S>

  type BlogTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogTagCountAggregateInputType | true
    }

  export interface BlogTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogTag'], meta: { name: 'BlogTag' } }
    /**
     * Find zero or one BlogTag that matches the filter.
     * @param {BlogTagFindUniqueArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogTagFindUniqueArgs>(args: SelectSubset<T, BlogTagFindUniqueArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogTagFindUniqueOrThrowArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogTagFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindFirstArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogTagFindFirstArgs>(args?: SelectSubset<T, BlogTagFindFirstArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindFirstOrThrowArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogTagFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogTags
     * const blogTags = await prisma.blogTag.findMany()
     * 
     * // Get first 10 BlogTags
     * const blogTags = await prisma.blogTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogTagWithIdOnly = await prisma.blogTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogTagFindManyArgs>(args?: SelectSubset<T, BlogTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogTag.
     * @param {BlogTagCreateArgs} args - Arguments to create a BlogTag.
     * @example
     * // Create one BlogTag
     * const BlogTag = await prisma.blogTag.create({
     *   data: {
     *     // ... data to create a BlogTag
     *   }
     * })
     * 
     */
    create<T extends BlogTagCreateArgs>(args: SelectSubset<T, BlogTagCreateArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogTags.
     * @param {BlogTagCreateManyArgs} args - Arguments to create many BlogTags.
     * @example
     * // Create many BlogTags
     * const blogTag = await prisma.blogTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogTagCreateManyArgs>(args?: SelectSubset<T, BlogTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogTags and returns the data saved in the database.
     * @param {BlogTagCreateManyAndReturnArgs} args - Arguments to create many BlogTags.
     * @example
     * // Create many BlogTags
     * const blogTag = await prisma.blogTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogTags and only return the `id`
     * const blogTagWithIdOnly = await prisma.blogTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogTagCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogTag.
     * @param {BlogTagDeleteArgs} args - Arguments to delete one BlogTag.
     * @example
     * // Delete one BlogTag
     * const BlogTag = await prisma.blogTag.delete({
     *   where: {
     *     // ... filter to delete one BlogTag
     *   }
     * })
     * 
     */
    delete<T extends BlogTagDeleteArgs>(args: SelectSubset<T, BlogTagDeleteArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogTag.
     * @param {BlogTagUpdateArgs} args - Arguments to update one BlogTag.
     * @example
     * // Update one BlogTag
     * const blogTag = await prisma.blogTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogTagUpdateArgs>(args: SelectSubset<T, BlogTagUpdateArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogTags.
     * @param {BlogTagDeleteManyArgs} args - Arguments to filter BlogTags to delete.
     * @example
     * // Delete a few BlogTags
     * const { count } = await prisma.blogTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogTagDeleteManyArgs>(args?: SelectSubset<T, BlogTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogTags
     * const blogTag = await prisma.blogTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogTagUpdateManyArgs>(args: SelectSubset<T, BlogTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogTags and returns the data updated in the database.
     * @param {BlogTagUpdateManyAndReturnArgs} args - Arguments to update many BlogTags.
     * @example
     * // Update many BlogTags
     * const blogTag = await prisma.blogTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogTags and only return the `id`
     * const blogTagWithIdOnly = await prisma.blogTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogTagUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogTag.
     * @param {BlogTagUpsertArgs} args - Arguments to update or create a BlogTag.
     * @example
     * // Update or create a BlogTag
     * const blogTag = await prisma.blogTag.upsert({
     *   create: {
     *     // ... data to create a BlogTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogTag we want to update
     *   }
     * })
     */
    upsert<T extends BlogTagUpsertArgs>(args: SelectSubset<T, BlogTagUpsertArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagCountArgs} args - Arguments to filter BlogTags to count.
     * @example
     * // Count the number of BlogTags
     * const count = await prisma.blogTag.count({
     *   where: {
     *     // ... the filter for the BlogTags we want to count
     *   }
     * })
    **/
    count<T extends BlogTagCountArgs>(
      args?: Subset<T, BlogTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogTagAggregateArgs>(args: Subset<T, BlogTagAggregateArgs>): Prisma.PrismaPromise<GetBlogTagAggregateType<T>>

    /**
     * Group by BlogTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogTagGroupByArgs['orderBy'] }
        : { orderBy?: BlogTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogTag model
   */
  readonly fields: BlogTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends BlogTag$postsArgs<ExtArgs> = {}>(args?: Subset<T, BlogTag$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogTag model
   */
  interface BlogTagFieldRefs {
    readonly id: FieldRef<"BlogTag", 'String'>
    readonly name: FieldRef<"BlogTag", 'String'>
    readonly createdAt: FieldRef<"BlogTag", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogTag findUnique
   */
  export type BlogTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag findUniqueOrThrow
   */
  export type BlogTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag findFirst
   */
  export type BlogTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogTags.
     */
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag findFirstOrThrow
   */
  export type BlogTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogTags.
     */
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag findMany
   */
  export type BlogTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTags to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag create
   */
  export type BlogTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogTag.
     */
    data: XOR<BlogTagCreateInput, BlogTagUncheckedCreateInput>
  }

  /**
   * BlogTag createMany
   */
  export type BlogTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogTags.
     */
    data: BlogTagCreateManyInput | BlogTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogTag createManyAndReturn
   */
  export type BlogTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * The data used to create many BlogTags.
     */
    data: BlogTagCreateManyInput | BlogTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogTag update
   */
  export type BlogTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogTag.
     */
    data: XOR<BlogTagUpdateInput, BlogTagUncheckedUpdateInput>
    /**
     * Choose, which BlogTag to update.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag updateMany
   */
  export type BlogTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogTags.
     */
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyInput>
    /**
     * Filter which BlogTags to update
     */
    where?: BlogTagWhereInput
    /**
     * Limit how many BlogTags to update.
     */
    limit?: number
  }

  /**
   * BlogTag updateManyAndReturn
   */
  export type BlogTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * The data used to update BlogTags.
     */
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyInput>
    /**
     * Filter which BlogTags to update
     */
    where?: BlogTagWhereInput
    /**
     * Limit how many BlogTags to update.
     */
    limit?: number
  }

  /**
   * BlogTag upsert
   */
  export type BlogTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogTag to update in case it exists.
     */
    where: BlogTagWhereUniqueInput
    /**
     * In case the BlogTag found by the `where` argument doesn't exist, create a new BlogTag with this data.
     */
    create: XOR<BlogTagCreateInput, BlogTagUncheckedCreateInput>
    /**
     * In case the BlogTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogTagUpdateInput, BlogTagUncheckedUpdateInput>
  }

  /**
   * BlogTag delete
   */
  export type BlogTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter which BlogTag to delete.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag deleteMany
   */
  export type BlogTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogTags to delete
     */
    where?: BlogTagWhereInput
    /**
     * Limit how many BlogTags to delete.
     */
    limit?: number
  }

  /**
   * BlogTag.posts
   */
  export type BlogTag$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogTag without action
   */
  export type BlogTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
  }


  /**
   * Model BlogComment
   */

  export type AggregateBlogComment = {
    _count: BlogCommentCountAggregateOutputType | null
    _avg: BlogCommentAvgAggregateOutputType | null
    _sum: BlogCommentSumAggregateOutputType | null
    _min: BlogCommentMinAggregateOutputType | null
    _max: BlogCommentMaxAggregateOutputType | null
  }

  export type BlogCommentAvgAggregateOutputType = {
    likes: number | null
  }

  export type BlogCommentSumAggregateOutputType = {
    likes: number | null
  }

  export type BlogCommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    authorId: string | null
    postId: string | null
    userId: string | null
    parentId: string | null
    externalName: string | null
    externalAvatar: string | null
    likes: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogCommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    authorId: string | null
    postId: string | null
    userId: string | null
    parentId: string | null
    externalName: string | null
    externalAvatar: string | null
    likes: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogCommentCountAggregateOutputType = {
    id: number
    content: number
    authorId: number
    postId: number
    userId: number
    parentId: number
    externalName: number
    externalAvatar: number
    likes: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogCommentAvgAggregateInputType = {
    likes?: true
  }

  export type BlogCommentSumAggregateInputType = {
    likes?: true
  }

  export type BlogCommentMinAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    postId?: true
    userId?: true
    parentId?: true
    externalName?: true
    externalAvatar?: true
    likes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogCommentMaxAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    postId?: true
    userId?: true
    parentId?: true
    externalName?: true
    externalAvatar?: true
    likes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogCommentCountAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    postId?: true
    userId?: true
    parentId?: true
    externalName?: true
    externalAvatar?: true
    likes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogComment to aggregate.
     */
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     */
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogComments
    **/
    _count?: true | BlogCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogCommentMaxAggregateInputType
  }

  export type GetBlogCommentAggregateType<T extends BlogCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogComment[P]>
      : GetScalarType<T[P], AggregateBlogComment[P]>
  }




  export type BlogCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCommentWhereInput
    orderBy?: BlogCommentOrderByWithAggregationInput | BlogCommentOrderByWithAggregationInput[]
    by: BlogCommentScalarFieldEnum[] | BlogCommentScalarFieldEnum
    having?: BlogCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCommentCountAggregateInputType | true
    _avg?: BlogCommentAvgAggregateInputType
    _sum?: BlogCommentSumAggregateInputType
    _min?: BlogCommentMinAggregateInputType
    _max?: BlogCommentMaxAggregateInputType
  }

  export type BlogCommentGroupByOutputType = {
    id: string
    content: string
    authorId: string
    postId: string
    userId: string | null
    parentId: string | null
    externalName: string | null
    externalAvatar: string | null
    likes: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: BlogCommentCountAggregateOutputType | null
    _avg: BlogCommentAvgAggregateOutputType | null
    _sum: BlogCommentSumAggregateOutputType | null
    _min: BlogCommentMinAggregateOutputType | null
    _max: BlogCommentMaxAggregateOutputType | null
  }

  type GetBlogCommentGroupByPayload<T extends BlogCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogCommentGroupByOutputType[P]>
            : GetScalarType<T[P], BlogCommentGroupByOutputType[P]>
        }
      >
    >


  export type BlogCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    authorId?: boolean
    postId?: boolean
    userId?: boolean
    parentId?: boolean
    externalName?: boolean
    externalAvatar?: boolean
    likes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | BlogComment$parentArgs<ExtArgs>
    replies?: boolean | BlogComment$repliesArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    reportedComments?: boolean | BlogComment$reportedCommentsArgs<ExtArgs>
    _count?: boolean | BlogCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogComment"]>

  export type BlogCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    authorId?: boolean
    postId?: boolean
    userId?: boolean
    parentId?: boolean
    externalName?: boolean
    externalAvatar?: boolean
    likes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | BlogComment$parentArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogComment"]>

  export type BlogCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    authorId?: boolean
    postId?: boolean
    userId?: boolean
    parentId?: boolean
    externalName?: boolean
    externalAvatar?: boolean
    likes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | BlogComment$parentArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogComment"]>

  export type BlogCommentSelectScalar = {
    id?: boolean
    content?: boolean
    authorId?: boolean
    postId?: boolean
    userId?: boolean
    parentId?: boolean
    externalName?: boolean
    externalAvatar?: boolean
    likes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "authorId" | "postId" | "userId" | "parentId" | "externalName" | "externalAvatar" | "likes" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["blogComment"]>
  export type BlogCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | BlogComment$parentArgs<ExtArgs>
    replies?: boolean | BlogComment$repliesArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    reportedComments?: boolean | BlogComment$reportedCommentsArgs<ExtArgs>
    _count?: boolean | BlogCommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | BlogComment$parentArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type BlogCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | BlogComment$parentArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }

  export type $BlogCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogComment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$BlogCommentPayload<ExtArgs> | null
      replies: Prisma.$BlogCommentPayload<ExtArgs>[]
      post: Prisma.$BlogPostPayload<ExtArgs>
      reportedComments: Prisma.$ReportedCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      authorId: string
      postId: string
      userId: string | null
      parentId: string | null
      externalName: string | null
      externalAvatar: string | null
      likes: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogComment"]>
    composites: {}
  }

  type BlogCommentGetPayload<S extends boolean | null | undefined | BlogCommentDefaultArgs> = $Result.GetResult<Prisma.$BlogCommentPayload, S>

  type BlogCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogCommentCountAggregateInputType | true
    }

  export interface BlogCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogComment'], meta: { name: 'BlogComment' } }
    /**
     * Find zero or one BlogComment that matches the filter.
     * @param {BlogCommentFindUniqueArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogCommentFindUniqueArgs>(args: SelectSubset<T, BlogCommentFindUniqueArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogCommentFindUniqueOrThrowArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentFindFirstArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogCommentFindFirstArgs>(args?: SelectSubset<T, BlogCommentFindFirstArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentFindFirstOrThrowArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogComments
     * const blogComments = await prisma.blogComment.findMany()
     * 
     * // Get first 10 BlogComments
     * const blogComments = await prisma.blogComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogCommentWithIdOnly = await prisma.blogComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogCommentFindManyArgs>(args?: SelectSubset<T, BlogCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogComment.
     * @param {BlogCommentCreateArgs} args - Arguments to create a BlogComment.
     * @example
     * // Create one BlogComment
     * const BlogComment = await prisma.blogComment.create({
     *   data: {
     *     // ... data to create a BlogComment
     *   }
     * })
     * 
     */
    create<T extends BlogCommentCreateArgs>(args: SelectSubset<T, BlogCommentCreateArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogComments.
     * @param {BlogCommentCreateManyArgs} args - Arguments to create many BlogComments.
     * @example
     * // Create many BlogComments
     * const blogComment = await prisma.blogComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogCommentCreateManyArgs>(args?: SelectSubset<T, BlogCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogComments and returns the data saved in the database.
     * @param {BlogCommentCreateManyAndReturnArgs} args - Arguments to create many BlogComments.
     * @example
     * // Create many BlogComments
     * const blogComment = await prisma.blogComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogComments and only return the `id`
     * const blogCommentWithIdOnly = await prisma.blogComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogComment.
     * @param {BlogCommentDeleteArgs} args - Arguments to delete one BlogComment.
     * @example
     * // Delete one BlogComment
     * const BlogComment = await prisma.blogComment.delete({
     *   where: {
     *     // ... filter to delete one BlogComment
     *   }
     * })
     * 
     */
    delete<T extends BlogCommentDeleteArgs>(args: SelectSubset<T, BlogCommentDeleteArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogComment.
     * @param {BlogCommentUpdateArgs} args - Arguments to update one BlogComment.
     * @example
     * // Update one BlogComment
     * const blogComment = await prisma.blogComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogCommentUpdateArgs>(args: SelectSubset<T, BlogCommentUpdateArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogComments.
     * @param {BlogCommentDeleteManyArgs} args - Arguments to filter BlogComments to delete.
     * @example
     * // Delete a few BlogComments
     * const { count } = await prisma.blogComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogCommentDeleteManyArgs>(args?: SelectSubset<T, BlogCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogComments
     * const blogComment = await prisma.blogComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogCommentUpdateManyArgs>(args: SelectSubset<T, BlogCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogComments and returns the data updated in the database.
     * @param {BlogCommentUpdateManyAndReturnArgs} args - Arguments to update many BlogComments.
     * @example
     * // Update many BlogComments
     * const blogComment = await prisma.blogComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogComments and only return the `id`
     * const blogCommentWithIdOnly = await prisma.blogComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogComment.
     * @param {BlogCommentUpsertArgs} args - Arguments to update or create a BlogComment.
     * @example
     * // Update or create a BlogComment
     * const blogComment = await prisma.blogComment.upsert({
     *   create: {
     *     // ... data to create a BlogComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogComment we want to update
     *   }
     * })
     */
    upsert<T extends BlogCommentUpsertArgs>(args: SelectSubset<T, BlogCommentUpsertArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentCountArgs} args - Arguments to filter BlogComments to count.
     * @example
     * // Count the number of BlogComments
     * const count = await prisma.blogComment.count({
     *   where: {
     *     // ... the filter for the BlogComments we want to count
     *   }
     * })
    **/
    count<T extends BlogCommentCountArgs>(
      args?: Subset<T, BlogCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogCommentAggregateArgs>(args: Subset<T, BlogCommentAggregateArgs>): Prisma.PrismaPromise<GetBlogCommentAggregateType<T>>

    /**
     * Group by BlogComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogCommentGroupByArgs['orderBy'] }
        : { orderBy?: BlogCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogComment model
   */
  readonly fields: BlogCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends BlogComment$parentArgs<ExtArgs> = {}>(args?: Subset<T, BlogComment$parentArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends BlogComment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, BlogComment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportedComments<T extends BlogComment$reportedCommentsArgs<ExtArgs> = {}>(args?: Subset<T, BlogComment$reportedCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogComment model
   */
  interface BlogCommentFieldRefs {
    readonly id: FieldRef<"BlogComment", 'String'>
    readonly content: FieldRef<"BlogComment", 'String'>
    readonly authorId: FieldRef<"BlogComment", 'String'>
    readonly postId: FieldRef<"BlogComment", 'String'>
    readonly userId: FieldRef<"BlogComment", 'String'>
    readonly parentId: FieldRef<"BlogComment", 'String'>
    readonly externalName: FieldRef<"BlogComment", 'String'>
    readonly externalAvatar: FieldRef<"BlogComment", 'String'>
    readonly likes: FieldRef<"BlogComment", 'Int'>
    readonly status: FieldRef<"BlogComment", 'String'>
    readonly createdAt: FieldRef<"BlogComment", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogComment findUnique
   */
  export type BlogCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComment to fetch.
     */
    where: BlogCommentWhereUniqueInput
  }

  /**
   * BlogComment findUniqueOrThrow
   */
  export type BlogCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComment to fetch.
     */
    where: BlogCommentWhereUniqueInput
  }

  /**
   * BlogComment findFirst
   */
  export type BlogCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComment to fetch.
     */
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     */
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogComments.
     */
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogComments.
     */
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogComment findFirstOrThrow
   */
  export type BlogCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComment to fetch.
     */
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     */
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogComments.
     */
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogComments.
     */
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogComment findMany
   */
  export type BlogCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter, which BlogComments to fetch.
     */
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     */
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogComments.
     */
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     */
    skip?: number
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogComment create
   */
  export type BlogCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogComment.
     */
    data: XOR<BlogCommentCreateInput, BlogCommentUncheckedCreateInput>
  }

  /**
   * BlogComment createMany
   */
  export type BlogCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogComments.
     */
    data: BlogCommentCreateManyInput | BlogCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogComment createManyAndReturn
   */
  export type BlogCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * The data used to create many BlogComments.
     */
    data: BlogCommentCreateManyInput | BlogCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogComment update
   */
  export type BlogCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogComment.
     */
    data: XOR<BlogCommentUpdateInput, BlogCommentUncheckedUpdateInput>
    /**
     * Choose, which BlogComment to update.
     */
    where: BlogCommentWhereUniqueInput
  }

  /**
   * BlogComment updateMany
   */
  export type BlogCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogComments.
     */
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyInput>
    /**
     * Filter which BlogComments to update
     */
    where?: BlogCommentWhereInput
    /**
     * Limit how many BlogComments to update.
     */
    limit?: number
  }

  /**
   * BlogComment updateManyAndReturn
   */
  export type BlogCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * The data used to update BlogComments.
     */
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyInput>
    /**
     * Filter which BlogComments to update
     */
    where?: BlogCommentWhereInput
    /**
     * Limit how many BlogComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogComment upsert
   */
  export type BlogCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogComment to update in case it exists.
     */
    where: BlogCommentWhereUniqueInput
    /**
     * In case the BlogComment found by the `where` argument doesn't exist, create a new BlogComment with this data.
     */
    create: XOR<BlogCommentCreateInput, BlogCommentUncheckedCreateInput>
    /**
     * In case the BlogComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogCommentUpdateInput, BlogCommentUncheckedUpdateInput>
  }

  /**
   * BlogComment delete
   */
  export type BlogCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    /**
     * Filter which BlogComment to delete.
     */
    where: BlogCommentWhereUniqueInput
  }

  /**
   * BlogComment deleteMany
   */
  export type BlogCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogComments to delete
     */
    where?: BlogCommentWhereInput
    /**
     * Limit how many BlogComments to delete.
     */
    limit?: number
  }

  /**
   * BlogComment.parent
   */
  export type BlogComment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    where?: BlogCommentWhereInput
  }

  /**
   * BlogComment.replies
   */
  export type BlogComment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
    where?: BlogCommentWhereInput
    orderBy?: BlogCommentOrderByWithRelationInput | BlogCommentOrderByWithRelationInput[]
    cursor?: BlogCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogCommentScalarFieldEnum | BlogCommentScalarFieldEnum[]
  }

  /**
   * BlogComment.reportedComments
   */
  export type BlogComment$reportedCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentInclude<ExtArgs> | null
    where?: ReportedCommentWhereInput
    orderBy?: ReportedCommentOrderByWithRelationInput | ReportedCommentOrderByWithRelationInput[]
    cursor?: ReportedCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportedCommentScalarFieldEnum | ReportedCommentScalarFieldEnum[]
  }

  /**
   * BlogComment without action
   */
  export type BlogCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogComment
     */
    select?: BlogCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogComment
     */
    omit?: BlogCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCommentInclude<ExtArgs> | null
  }


  /**
   * Model ReportedComment
   */

  export type AggregateReportedComment = {
    _count: ReportedCommentCountAggregateOutputType | null
    _min: ReportedCommentMinAggregateOutputType | null
    _max: ReportedCommentMaxAggregateOutputType | null
  }

  export type ReportedCommentMinAggregateOutputType = {
    id: string | null
    commentId: string | null
    blogSlug: string | null
    blogOwner: string | null
    parentCommentBy: string | null
    reportedBy: string | null
    reason: string | null
    reportedAt: Date | null
    resolved: boolean | null
  }

  export type ReportedCommentMaxAggregateOutputType = {
    id: string | null
    commentId: string | null
    blogSlug: string | null
    blogOwner: string | null
    parentCommentBy: string | null
    reportedBy: string | null
    reason: string | null
    reportedAt: Date | null
    resolved: boolean | null
  }

  export type ReportedCommentCountAggregateOutputType = {
    id: number
    commentId: number
    blogSlug: number
    blogOwner: number
    parentCommentBy: number
    reportedBy: number
    reason: number
    reportedAt: number
    resolved: number
    _all: number
  }


  export type ReportedCommentMinAggregateInputType = {
    id?: true
    commentId?: true
    blogSlug?: true
    blogOwner?: true
    parentCommentBy?: true
    reportedBy?: true
    reason?: true
    reportedAt?: true
    resolved?: true
  }

  export type ReportedCommentMaxAggregateInputType = {
    id?: true
    commentId?: true
    blogSlug?: true
    blogOwner?: true
    parentCommentBy?: true
    reportedBy?: true
    reason?: true
    reportedAt?: true
    resolved?: true
  }

  export type ReportedCommentCountAggregateInputType = {
    id?: true
    commentId?: true
    blogSlug?: true
    blogOwner?: true
    parentCommentBy?: true
    reportedBy?: true
    reason?: true
    reportedAt?: true
    resolved?: true
    _all?: true
  }

  export type ReportedCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportedComment to aggregate.
     */
    where?: ReportedCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportedComments to fetch.
     */
    orderBy?: ReportedCommentOrderByWithRelationInput | ReportedCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportedCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportedComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportedComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportedComments
    **/
    _count?: true | ReportedCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportedCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportedCommentMaxAggregateInputType
  }

  export type GetReportedCommentAggregateType<T extends ReportedCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateReportedComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportedComment[P]>
      : GetScalarType<T[P], AggregateReportedComment[P]>
  }




  export type ReportedCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportedCommentWhereInput
    orderBy?: ReportedCommentOrderByWithAggregationInput | ReportedCommentOrderByWithAggregationInput[]
    by: ReportedCommentScalarFieldEnum[] | ReportedCommentScalarFieldEnum
    having?: ReportedCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportedCommentCountAggregateInputType | true
    _min?: ReportedCommentMinAggregateInputType
    _max?: ReportedCommentMaxAggregateInputType
  }

  export type ReportedCommentGroupByOutputType = {
    id: string
    commentId: string
    blogSlug: string
    blogOwner: string
    parentCommentBy: string
    reportedBy: string
    reason: string | null
    reportedAt: Date
    resolved: boolean
    _count: ReportedCommentCountAggregateOutputType | null
    _min: ReportedCommentMinAggregateOutputType | null
    _max: ReportedCommentMaxAggregateOutputType | null
  }

  type GetReportedCommentGroupByPayload<T extends ReportedCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportedCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportedCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportedCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ReportedCommentGroupByOutputType[P]>
        }
      >
    >


  export type ReportedCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    blogSlug?: boolean
    blogOwner?: boolean
    parentCommentBy?: boolean
    reportedBy?: boolean
    reason?: boolean
    reportedAt?: boolean
    resolved?: boolean
    comment?: boolean | BlogCommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportedComment"]>

  export type ReportedCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    blogSlug?: boolean
    blogOwner?: boolean
    parentCommentBy?: boolean
    reportedBy?: boolean
    reason?: boolean
    reportedAt?: boolean
    resolved?: boolean
    comment?: boolean | BlogCommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportedComment"]>

  export type ReportedCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    blogSlug?: boolean
    blogOwner?: boolean
    parentCommentBy?: boolean
    reportedBy?: boolean
    reason?: boolean
    reportedAt?: boolean
    resolved?: boolean
    comment?: boolean | BlogCommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportedComment"]>

  export type ReportedCommentSelectScalar = {
    id?: boolean
    commentId?: boolean
    blogSlug?: boolean
    blogOwner?: boolean
    parentCommentBy?: boolean
    reportedBy?: boolean
    reason?: boolean
    reportedAt?: boolean
    resolved?: boolean
  }

  export type ReportedCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "commentId" | "blogSlug" | "blogOwner" | "parentCommentBy" | "reportedBy" | "reason" | "reportedAt" | "resolved", ExtArgs["result"]["reportedComment"]>
  export type ReportedCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | BlogCommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportedCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | BlogCommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportedCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | BlogCommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportedCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportedComment"
    objects: {
      comment: Prisma.$BlogCommentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      commentId: string
      blogSlug: string
      blogOwner: string
      parentCommentBy: string
      reportedBy: string
      reason: string | null
      reportedAt: Date
      resolved: boolean
    }, ExtArgs["result"]["reportedComment"]>
    composites: {}
  }

  type ReportedCommentGetPayload<S extends boolean | null | undefined | ReportedCommentDefaultArgs> = $Result.GetResult<Prisma.$ReportedCommentPayload, S>

  type ReportedCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportedCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportedCommentCountAggregateInputType | true
    }

  export interface ReportedCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportedComment'], meta: { name: 'ReportedComment' } }
    /**
     * Find zero or one ReportedComment that matches the filter.
     * @param {ReportedCommentFindUniqueArgs} args - Arguments to find a ReportedComment
     * @example
     * // Get one ReportedComment
     * const reportedComment = await prisma.reportedComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportedCommentFindUniqueArgs>(args: SelectSubset<T, ReportedCommentFindUniqueArgs<ExtArgs>>): Prisma__ReportedCommentClient<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportedComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportedCommentFindUniqueOrThrowArgs} args - Arguments to find a ReportedComment
     * @example
     * // Get one ReportedComment
     * const reportedComment = await prisma.reportedComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportedCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportedCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportedCommentClient<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportedComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportedCommentFindFirstArgs} args - Arguments to find a ReportedComment
     * @example
     * // Get one ReportedComment
     * const reportedComment = await prisma.reportedComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportedCommentFindFirstArgs>(args?: SelectSubset<T, ReportedCommentFindFirstArgs<ExtArgs>>): Prisma__ReportedCommentClient<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportedComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportedCommentFindFirstOrThrowArgs} args - Arguments to find a ReportedComment
     * @example
     * // Get one ReportedComment
     * const reportedComment = await prisma.reportedComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportedCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportedCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportedCommentClient<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportedComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportedCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportedComments
     * const reportedComments = await prisma.reportedComment.findMany()
     * 
     * // Get first 10 ReportedComments
     * const reportedComments = await prisma.reportedComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportedCommentWithIdOnly = await prisma.reportedComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportedCommentFindManyArgs>(args?: SelectSubset<T, ReportedCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportedComment.
     * @param {ReportedCommentCreateArgs} args - Arguments to create a ReportedComment.
     * @example
     * // Create one ReportedComment
     * const ReportedComment = await prisma.reportedComment.create({
     *   data: {
     *     // ... data to create a ReportedComment
     *   }
     * })
     * 
     */
    create<T extends ReportedCommentCreateArgs>(args: SelectSubset<T, ReportedCommentCreateArgs<ExtArgs>>): Prisma__ReportedCommentClient<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportedComments.
     * @param {ReportedCommentCreateManyArgs} args - Arguments to create many ReportedComments.
     * @example
     * // Create many ReportedComments
     * const reportedComment = await prisma.reportedComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportedCommentCreateManyArgs>(args?: SelectSubset<T, ReportedCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportedComments and returns the data saved in the database.
     * @param {ReportedCommentCreateManyAndReturnArgs} args - Arguments to create many ReportedComments.
     * @example
     * // Create many ReportedComments
     * const reportedComment = await prisma.reportedComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportedComments and only return the `id`
     * const reportedCommentWithIdOnly = await prisma.reportedComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportedCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportedCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportedComment.
     * @param {ReportedCommentDeleteArgs} args - Arguments to delete one ReportedComment.
     * @example
     * // Delete one ReportedComment
     * const ReportedComment = await prisma.reportedComment.delete({
     *   where: {
     *     // ... filter to delete one ReportedComment
     *   }
     * })
     * 
     */
    delete<T extends ReportedCommentDeleteArgs>(args: SelectSubset<T, ReportedCommentDeleteArgs<ExtArgs>>): Prisma__ReportedCommentClient<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportedComment.
     * @param {ReportedCommentUpdateArgs} args - Arguments to update one ReportedComment.
     * @example
     * // Update one ReportedComment
     * const reportedComment = await prisma.reportedComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportedCommentUpdateArgs>(args: SelectSubset<T, ReportedCommentUpdateArgs<ExtArgs>>): Prisma__ReportedCommentClient<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportedComments.
     * @param {ReportedCommentDeleteManyArgs} args - Arguments to filter ReportedComments to delete.
     * @example
     * // Delete a few ReportedComments
     * const { count } = await prisma.reportedComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportedCommentDeleteManyArgs>(args?: SelectSubset<T, ReportedCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportedComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportedCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportedComments
     * const reportedComment = await prisma.reportedComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportedCommentUpdateManyArgs>(args: SelectSubset<T, ReportedCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportedComments and returns the data updated in the database.
     * @param {ReportedCommentUpdateManyAndReturnArgs} args - Arguments to update many ReportedComments.
     * @example
     * // Update many ReportedComments
     * const reportedComment = await prisma.reportedComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportedComments and only return the `id`
     * const reportedCommentWithIdOnly = await prisma.reportedComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportedCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportedCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportedComment.
     * @param {ReportedCommentUpsertArgs} args - Arguments to update or create a ReportedComment.
     * @example
     * // Update or create a ReportedComment
     * const reportedComment = await prisma.reportedComment.upsert({
     *   create: {
     *     // ... data to create a ReportedComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportedComment we want to update
     *   }
     * })
     */
    upsert<T extends ReportedCommentUpsertArgs>(args: SelectSubset<T, ReportedCommentUpsertArgs<ExtArgs>>): Prisma__ReportedCommentClient<$Result.GetResult<Prisma.$ReportedCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportedComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportedCommentCountArgs} args - Arguments to filter ReportedComments to count.
     * @example
     * // Count the number of ReportedComments
     * const count = await prisma.reportedComment.count({
     *   where: {
     *     // ... the filter for the ReportedComments we want to count
     *   }
     * })
    **/
    count<T extends ReportedCommentCountArgs>(
      args?: Subset<T, ReportedCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportedCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportedComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportedCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportedCommentAggregateArgs>(args: Subset<T, ReportedCommentAggregateArgs>): Prisma.PrismaPromise<GetReportedCommentAggregateType<T>>

    /**
     * Group by ReportedComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportedCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportedCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportedCommentGroupByArgs['orderBy'] }
        : { orderBy?: ReportedCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportedCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportedCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportedComment model
   */
  readonly fields: ReportedCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportedComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportedCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends BlogCommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogCommentDefaultArgs<ExtArgs>>): Prisma__BlogCommentClient<$Result.GetResult<Prisma.$BlogCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportedComment model
   */
  interface ReportedCommentFieldRefs {
    readonly id: FieldRef<"ReportedComment", 'String'>
    readonly commentId: FieldRef<"ReportedComment", 'String'>
    readonly blogSlug: FieldRef<"ReportedComment", 'String'>
    readonly blogOwner: FieldRef<"ReportedComment", 'String'>
    readonly parentCommentBy: FieldRef<"ReportedComment", 'String'>
    readonly reportedBy: FieldRef<"ReportedComment", 'String'>
    readonly reason: FieldRef<"ReportedComment", 'String'>
    readonly reportedAt: FieldRef<"ReportedComment", 'DateTime'>
    readonly resolved: FieldRef<"ReportedComment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ReportedComment findUnique
   */
  export type ReportedCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReportedComment to fetch.
     */
    where: ReportedCommentWhereUniqueInput
  }

  /**
   * ReportedComment findUniqueOrThrow
   */
  export type ReportedCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReportedComment to fetch.
     */
    where: ReportedCommentWhereUniqueInput
  }

  /**
   * ReportedComment findFirst
   */
  export type ReportedCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReportedComment to fetch.
     */
    where?: ReportedCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportedComments to fetch.
     */
    orderBy?: ReportedCommentOrderByWithRelationInput | ReportedCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportedComments.
     */
    cursor?: ReportedCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportedComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportedComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportedComments.
     */
    distinct?: ReportedCommentScalarFieldEnum | ReportedCommentScalarFieldEnum[]
  }

  /**
   * ReportedComment findFirstOrThrow
   */
  export type ReportedCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReportedComment to fetch.
     */
    where?: ReportedCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportedComments to fetch.
     */
    orderBy?: ReportedCommentOrderByWithRelationInput | ReportedCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportedComments.
     */
    cursor?: ReportedCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportedComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportedComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportedComments.
     */
    distinct?: ReportedCommentScalarFieldEnum | ReportedCommentScalarFieldEnum[]
  }

  /**
   * ReportedComment findMany
   */
  export type ReportedCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReportedComments to fetch.
     */
    where?: ReportedCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportedComments to fetch.
     */
    orderBy?: ReportedCommentOrderByWithRelationInput | ReportedCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportedComments.
     */
    cursor?: ReportedCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportedComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportedComments.
     */
    skip?: number
    distinct?: ReportedCommentScalarFieldEnum | ReportedCommentScalarFieldEnum[]
  }

  /**
   * ReportedComment create
   */
  export type ReportedCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportedComment.
     */
    data: XOR<ReportedCommentCreateInput, ReportedCommentUncheckedCreateInput>
  }

  /**
   * ReportedComment createMany
   */
  export type ReportedCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportedComments.
     */
    data: ReportedCommentCreateManyInput | ReportedCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportedComment createManyAndReturn
   */
  export type ReportedCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * The data used to create many ReportedComments.
     */
    data: ReportedCommentCreateManyInput | ReportedCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportedComment update
   */
  export type ReportedCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportedComment.
     */
    data: XOR<ReportedCommentUpdateInput, ReportedCommentUncheckedUpdateInput>
    /**
     * Choose, which ReportedComment to update.
     */
    where: ReportedCommentWhereUniqueInput
  }

  /**
   * ReportedComment updateMany
   */
  export type ReportedCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportedComments.
     */
    data: XOR<ReportedCommentUpdateManyMutationInput, ReportedCommentUncheckedUpdateManyInput>
    /**
     * Filter which ReportedComments to update
     */
    where?: ReportedCommentWhereInput
    /**
     * Limit how many ReportedComments to update.
     */
    limit?: number
  }

  /**
   * ReportedComment updateManyAndReturn
   */
  export type ReportedCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * The data used to update ReportedComments.
     */
    data: XOR<ReportedCommentUpdateManyMutationInput, ReportedCommentUncheckedUpdateManyInput>
    /**
     * Filter which ReportedComments to update
     */
    where?: ReportedCommentWhereInput
    /**
     * Limit how many ReportedComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportedComment upsert
   */
  export type ReportedCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportedComment to update in case it exists.
     */
    where: ReportedCommentWhereUniqueInput
    /**
     * In case the ReportedComment found by the `where` argument doesn't exist, create a new ReportedComment with this data.
     */
    create: XOR<ReportedCommentCreateInput, ReportedCommentUncheckedCreateInput>
    /**
     * In case the ReportedComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportedCommentUpdateInput, ReportedCommentUncheckedUpdateInput>
  }

  /**
   * ReportedComment delete
   */
  export type ReportedCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentInclude<ExtArgs> | null
    /**
     * Filter which ReportedComment to delete.
     */
    where: ReportedCommentWhereUniqueInput
  }

  /**
   * ReportedComment deleteMany
   */
  export type ReportedCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportedComments to delete
     */
    where?: ReportedCommentWhereInput
    /**
     * Limit how many ReportedComments to delete.
     */
    limit?: number
  }

  /**
   * ReportedComment without action
   */
  export type ReportedCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportedComment
     */
    select?: ReportedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportedComment
     */
    omit?: ReportedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportedCommentInclude<ExtArgs> | null
  }


  /**
   * Model BlogAIGeneration
   */

  export type AggregateBlogAIGeneration = {
    _count: BlogAIGenerationCountAggregateOutputType | null
    _avg: BlogAIGenerationAvgAggregateOutputType | null
    _sum: BlogAIGenerationSumAggregateOutputType | null
    _min: BlogAIGenerationMinAggregateOutputType | null
    _max: BlogAIGenerationMaxAggregateOutputType | null
  }

  export type BlogAIGenerationAvgAggregateOutputType = {
    cost: number | null
    tokensUsed: number | null
  }

  export type BlogAIGenerationSumAggregateOutputType = {
    cost: number | null
    tokensUsed: number | null
  }

  export type BlogAIGenerationMinAggregateOutputType = {
    id: string | null
    prompt: string | null
    status: $Enums.AIGenerationStatus | null
    output: string | null
    format: $Enums.ContentFormat | null
    cost: number | null
    tokensUsed: number | null
    model: string | null
    userId: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type BlogAIGenerationMaxAggregateOutputType = {
    id: string | null
    prompt: string | null
    status: $Enums.AIGenerationStatus | null
    output: string | null
    format: $Enums.ContentFormat | null
    cost: number | null
    tokensUsed: number | null
    model: string | null
    userId: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type BlogAIGenerationCountAggregateOutputType = {
    id: number
    prompt: number
    parameters: number
    status: number
    output: number
    format: number
    cost: number
    tokensUsed: number
    model: number
    userId: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type BlogAIGenerationAvgAggregateInputType = {
    cost?: true
    tokensUsed?: true
  }

  export type BlogAIGenerationSumAggregateInputType = {
    cost?: true
    tokensUsed?: true
  }

  export type BlogAIGenerationMinAggregateInputType = {
    id?: true
    prompt?: true
    status?: true
    output?: true
    format?: true
    cost?: true
    tokensUsed?: true
    model?: true
    userId?: true
    createdAt?: true
    completedAt?: true
  }

  export type BlogAIGenerationMaxAggregateInputType = {
    id?: true
    prompt?: true
    status?: true
    output?: true
    format?: true
    cost?: true
    tokensUsed?: true
    model?: true
    userId?: true
    createdAt?: true
    completedAt?: true
  }

  export type BlogAIGenerationCountAggregateInputType = {
    id?: true
    prompt?: true
    parameters?: true
    status?: true
    output?: true
    format?: true
    cost?: true
    tokensUsed?: true
    model?: true
    userId?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type BlogAIGenerationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogAIGeneration to aggregate.
     */
    where?: BlogAIGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogAIGenerations to fetch.
     */
    orderBy?: BlogAIGenerationOrderByWithRelationInput | BlogAIGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogAIGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogAIGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogAIGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogAIGenerations
    **/
    _count?: true | BlogAIGenerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogAIGenerationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogAIGenerationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogAIGenerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogAIGenerationMaxAggregateInputType
  }

  export type GetBlogAIGenerationAggregateType<T extends BlogAIGenerationAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogAIGeneration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogAIGeneration[P]>
      : GetScalarType<T[P], AggregateBlogAIGeneration[P]>
  }




  export type BlogAIGenerationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogAIGenerationWhereInput
    orderBy?: BlogAIGenerationOrderByWithAggregationInput | BlogAIGenerationOrderByWithAggregationInput[]
    by: BlogAIGenerationScalarFieldEnum[] | BlogAIGenerationScalarFieldEnum
    having?: BlogAIGenerationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogAIGenerationCountAggregateInputType | true
    _avg?: BlogAIGenerationAvgAggregateInputType
    _sum?: BlogAIGenerationSumAggregateInputType
    _min?: BlogAIGenerationMinAggregateInputType
    _max?: BlogAIGenerationMaxAggregateInputType
  }

  export type BlogAIGenerationGroupByOutputType = {
    id: string
    prompt: string
    parameters: JsonValue | null
    status: $Enums.AIGenerationStatus
    output: string
    format: $Enums.ContentFormat
    cost: number | null
    tokensUsed: number | null
    model: string | null
    userId: string
    createdAt: Date
    completedAt: Date | null
    _count: BlogAIGenerationCountAggregateOutputType | null
    _avg: BlogAIGenerationAvgAggregateOutputType | null
    _sum: BlogAIGenerationSumAggregateOutputType | null
    _min: BlogAIGenerationMinAggregateOutputType | null
    _max: BlogAIGenerationMaxAggregateOutputType | null
  }

  type GetBlogAIGenerationGroupByPayload<T extends BlogAIGenerationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogAIGenerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogAIGenerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogAIGenerationGroupByOutputType[P]>
            : GetScalarType<T[P], BlogAIGenerationGroupByOutputType[P]>
        }
      >
    >


  export type BlogAIGenerationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    parameters?: boolean
    status?: boolean
    output?: boolean
    format?: boolean
    cost?: boolean
    tokensUsed?: boolean
    model?: boolean
    userId?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    blogPosts?: boolean | BlogAIGeneration$blogPostsArgs<ExtArgs>
    _count?: boolean | BlogAIGenerationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogAIGeneration"]>

  export type BlogAIGenerationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    parameters?: boolean
    status?: boolean
    output?: boolean
    format?: boolean
    cost?: boolean
    tokensUsed?: boolean
    model?: boolean
    userId?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogAIGeneration"]>

  export type BlogAIGenerationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    parameters?: boolean
    status?: boolean
    output?: boolean
    format?: boolean
    cost?: boolean
    tokensUsed?: boolean
    model?: boolean
    userId?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogAIGeneration"]>

  export type BlogAIGenerationSelectScalar = {
    id?: boolean
    prompt?: boolean
    parameters?: boolean
    status?: boolean
    output?: boolean
    format?: boolean
    cost?: boolean
    tokensUsed?: boolean
    model?: boolean
    userId?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }

  export type BlogAIGenerationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prompt" | "parameters" | "status" | "output" | "format" | "cost" | "tokensUsed" | "model" | "userId" | "createdAt" | "completedAt", ExtArgs["result"]["blogAIGeneration"]>
  export type BlogAIGenerationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    blogPosts?: boolean | BlogAIGeneration$blogPostsArgs<ExtArgs>
    _count?: boolean | BlogAIGenerationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogAIGenerationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlogAIGenerationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogAIGenerationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogAIGeneration"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prompt: string
      parameters: Prisma.JsonValue | null
      status: $Enums.AIGenerationStatus
      output: string
      format: $Enums.ContentFormat
      cost: number | null
      tokensUsed: number | null
      model: string | null
      userId: string
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["blogAIGeneration"]>
    composites: {}
  }

  type BlogAIGenerationGetPayload<S extends boolean | null | undefined | BlogAIGenerationDefaultArgs> = $Result.GetResult<Prisma.$BlogAIGenerationPayload, S>

  type BlogAIGenerationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogAIGenerationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogAIGenerationCountAggregateInputType | true
    }

  export interface BlogAIGenerationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogAIGeneration'], meta: { name: 'BlogAIGeneration' } }
    /**
     * Find zero or one BlogAIGeneration that matches the filter.
     * @param {BlogAIGenerationFindUniqueArgs} args - Arguments to find a BlogAIGeneration
     * @example
     * // Get one BlogAIGeneration
     * const blogAIGeneration = await prisma.blogAIGeneration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogAIGenerationFindUniqueArgs>(args: SelectSubset<T, BlogAIGenerationFindUniqueArgs<ExtArgs>>): Prisma__BlogAIGenerationClient<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogAIGeneration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogAIGenerationFindUniqueOrThrowArgs} args - Arguments to find a BlogAIGeneration
     * @example
     * // Get one BlogAIGeneration
     * const blogAIGeneration = await prisma.blogAIGeneration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogAIGenerationFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogAIGenerationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogAIGenerationClient<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogAIGeneration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAIGenerationFindFirstArgs} args - Arguments to find a BlogAIGeneration
     * @example
     * // Get one BlogAIGeneration
     * const blogAIGeneration = await prisma.blogAIGeneration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogAIGenerationFindFirstArgs>(args?: SelectSubset<T, BlogAIGenerationFindFirstArgs<ExtArgs>>): Prisma__BlogAIGenerationClient<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogAIGeneration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAIGenerationFindFirstOrThrowArgs} args - Arguments to find a BlogAIGeneration
     * @example
     * // Get one BlogAIGeneration
     * const blogAIGeneration = await prisma.blogAIGeneration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogAIGenerationFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogAIGenerationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogAIGenerationClient<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogAIGenerations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAIGenerationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogAIGenerations
     * const blogAIGenerations = await prisma.blogAIGeneration.findMany()
     * 
     * // Get first 10 BlogAIGenerations
     * const blogAIGenerations = await prisma.blogAIGeneration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogAIGenerationWithIdOnly = await prisma.blogAIGeneration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogAIGenerationFindManyArgs>(args?: SelectSubset<T, BlogAIGenerationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogAIGeneration.
     * @param {BlogAIGenerationCreateArgs} args - Arguments to create a BlogAIGeneration.
     * @example
     * // Create one BlogAIGeneration
     * const BlogAIGeneration = await prisma.blogAIGeneration.create({
     *   data: {
     *     // ... data to create a BlogAIGeneration
     *   }
     * })
     * 
     */
    create<T extends BlogAIGenerationCreateArgs>(args: SelectSubset<T, BlogAIGenerationCreateArgs<ExtArgs>>): Prisma__BlogAIGenerationClient<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogAIGenerations.
     * @param {BlogAIGenerationCreateManyArgs} args - Arguments to create many BlogAIGenerations.
     * @example
     * // Create many BlogAIGenerations
     * const blogAIGeneration = await prisma.blogAIGeneration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogAIGenerationCreateManyArgs>(args?: SelectSubset<T, BlogAIGenerationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogAIGenerations and returns the data saved in the database.
     * @param {BlogAIGenerationCreateManyAndReturnArgs} args - Arguments to create many BlogAIGenerations.
     * @example
     * // Create many BlogAIGenerations
     * const blogAIGeneration = await prisma.blogAIGeneration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogAIGenerations and only return the `id`
     * const blogAIGenerationWithIdOnly = await prisma.blogAIGeneration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogAIGenerationCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogAIGenerationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogAIGeneration.
     * @param {BlogAIGenerationDeleteArgs} args - Arguments to delete one BlogAIGeneration.
     * @example
     * // Delete one BlogAIGeneration
     * const BlogAIGeneration = await prisma.blogAIGeneration.delete({
     *   where: {
     *     // ... filter to delete one BlogAIGeneration
     *   }
     * })
     * 
     */
    delete<T extends BlogAIGenerationDeleteArgs>(args: SelectSubset<T, BlogAIGenerationDeleteArgs<ExtArgs>>): Prisma__BlogAIGenerationClient<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogAIGeneration.
     * @param {BlogAIGenerationUpdateArgs} args - Arguments to update one BlogAIGeneration.
     * @example
     * // Update one BlogAIGeneration
     * const blogAIGeneration = await prisma.blogAIGeneration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogAIGenerationUpdateArgs>(args: SelectSubset<T, BlogAIGenerationUpdateArgs<ExtArgs>>): Prisma__BlogAIGenerationClient<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogAIGenerations.
     * @param {BlogAIGenerationDeleteManyArgs} args - Arguments to filter BlogAIGenerations to delete.
     * @example
     * // Delete a few BlogAIGenerations
     * const { count } = await prisma.blogAIGeneration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogAIGenerationDeleteManyArgs>(args?: SelectSubset<T, BlogAIGenerationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogAIGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAIGenerationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogAIGenerations
     * const blogAIGeneration = await prisma.blogAIGeneration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogAIGenerationUpdateManyArgs>(args: SelectSubset<T, BlogAIGenerationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogAIGenerations and returns the data updated in the database.
     * @param {BlogAIGenerationUpdateManyAndReturnArgs} args - Arguments to update many BlogAIGenerations.
     * @example
     * // Update many BlogAIGenerations
     * const blogAIGeneration = await prisma.blogAIGeneration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogAIGenerations and only return the `id`
     * const blogAIGenerationWithIdOnly = await prisma.blogAIGeneration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogAIGenerationUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogAIGenerationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogAIGeneration.
     * @param {BlogAIGenerationUpsertArgs} args - Arguments to update or create a BlogAIGeneration.
     * @example
     * // Update or create a BlogAIGeneration
     * const blogAIGeneration = await prisma.blogAIGeneration.upsert({
     *   create: {
     *     // ... data to create a BlogAIGeneration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogAIGeneration we want to update
     *   }
     * })
     */
    upsert<T extends BlogAIGenerationUpsertArgs>(args: SelectSubset<T, BlogAIGenerationUpsertArgs<ExtArgs>>): Prisma__BlogAIGenerationClient<$Result.GetResult<Prisma.$BlogAIGenerationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogAIGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAIGenerationCountArgs} args - Arguments to filter BlogAIGenerations to count.
     * @example
     * // Count the number of BlogAIGenerations
     * const count = await prisma.blogAIGeneration.count({
     *   where: {
     *     // ... the filter for the BlogAIGenerations we want to count
     *   }
     * })
    **/
    count<T extends BlogAIGenerationCountArgs>(
      args?: Subset<T, BlogAIGenerationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogAIGenerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogAIGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAIGenerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogAIGenerationAggregateArgs>(args: Subset<T, BlogAIGenerationAggregateArgs>): Prisma.PrismaPromise<GetBlogAIGenerationAggregateType<T>>

    /**
     * Group by BlogAIGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAIGenerationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogAIGenerationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogAIGenerationGroupByArgs['orderBy'] }
        : { orderBy?: BlogAIGenerationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogAIGenerationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogAIGenerationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogAIGeneration model
   */
  readonly fields: BlogAIGenerationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogAIGeneration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogAIGenerationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    blogPosts<T extends BlogAIGeneration$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, BlogAIGeneration$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogAIGeneration model
   */
  interface BlogAIGenerationFieldRefs {
    readonly id: FieldRef<"BlogAIGeneration", 'String'>
    readonly prompt: FieldRef<"BlogAIGeneration", 'String'>
    readonly parameters: FieldRef<"BlogAIGeneration", 'Json'>
    readonly status: FieldRef<"BlogAIGeneration", 'AIGenerationStatus'>
    readonly output: FieldRef<"BlogAIGeneration", 'String'>
    readonly format: FieldRef<"BlogAIGeneration", 'ContentFormat'>
    readonly cost: FieldRef<"BlogAIGeneration", 'Float'>
    readonly tokensUsed: FieldRef<"BlogAIGeneration", 'Int'>
    readonly model: FieldRef<"BlogAIGeneration", 'String'>
    readonly userId: FieldRef<"BlogAIGeneration", 'String'>
    readonly createdAt: FieldRef<"BlogAIGeneration", 'DateTime'>
    readonly completedAt: FieldRef<"BlogAIGeneration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogAIGeneration findUnique
   */
  export type BlogAIGenerationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationInclude<ExtArgs> | null
    /**
     * Filter, which BlogAIGeneration to fetch.
     */
    where: BlogAIGenerationWhereUniqueInput
  }

  /**
   * BlogAIGeneration findUniqueOrThrow
   */
  export type BlogAIGenerationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationInclude<ExtArgs> | null
    /**
     * Filter, which BlogAIGeneration to fetch.
     */
    where: BlogAIGenerationWhereUniqueInput
  }

  /**
   * BlogAIGeneration findFirst
   */
  export type BlogAIGenerationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationInclude<ExtArgs> | null
    /**
     * Filter, which BlogAIGeneration to fetch.
     */
    where?: BlogAIGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogAIGenerations to fetch.
     */
    orderBy?: BlogAIGenerationOrderByWithRelationInput | BlogAIGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogAIGenerations.
     */
    cursor?: BlogAIGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogAIGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogAIGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogAIGenerations.
     */
    distinct?: BlogAIGenerationScalarFieldEnum | BlogAIGenerationScalarFieldEnum[]
  }

  /**
   * BlogAIGeneration findFirstOrThrow
   */
  export type BlogAIGenerationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationInclude<ExtArgs> | null
    /**
     * Filter, which BlogAIGeneration to fetch.
     */
    where?: BlogAIGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogAIGenerations to fetch.
     */
    orderBy?: BlogAIGenerationOrderByWithRelationInput | BlogAIGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogAIGenerations.
     */
    cursor?: BlogAIGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogAIGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogAIGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogAIGenerations.
     */
    distinct?: BlogAIGenerationScalarFieldEnum | BlogAIGenerationScalarFieldEnum[]
  }

  /**
   * BlogAIGeneration findMany
   */
  export type BlogAIGenerationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationInclude<ExtArgs> | null
    /**
     * Filter, which BlogAIGenerations to fetch.
     */
    where?: BlogAIGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogAIGenerations to fetch.
     */
    orderBy?: BlogAIGenerationOrderByWithRelationInput | BlogAIGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogAIGenerations.
     */
    cursor?: BlogAIGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogAIGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogAIGenerations.
     */
    skip?: number
    distinct?: BlogAIGenerationScalarFieldEnum | BlogAIGenerationScalarFieldEnum[]
  }

  /**
   * BlogAIGeneration create
   */
  export type BlogAIGenerationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogAIGeneration.
     */
    data: XOR<BlogAIGenerationCreateInput, BlogAIGenerationUncheckedCreateInput>
  }

  /**
   * BlogAIGeneration createMany
   */
  export type BlogAIGenerationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogAIGenerations.
     */
    data: BlogAIGenerationCreateManyInput | BlogAIGenerationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogAIGeneration createManyAndReturn
   */
  export type BlogAIGenerationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * The data used to create many BlogAIGenerations.
     */
    data: BlogAIGenerationCreateManyInput | BlogAIGenerationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogAIGeneration update
   */
  export type BlogAIGenerationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogAIGeneration.
     */
    data: XOR<BlogAIGenerationUpdateInput, BlogAIGenerationUncheckedUpdateInput>
    /**
     * Choose, which BlogAIGeneration to update.
     */
    where: BlogAIGenerationWhereUniqueInput
  }

  /**
   * BlogAIGeneration updateMany
   */
  export type BlogAIGenerationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogAIGenerations.
     */
    data: XOR<BlogAIGenerationUpdateManyMutationInput, BlogAIGenerationUncheckedUpdateManyInput>
    /**
     * Filter which BlogAIGenerations to update
     */
    where?: BlogAIGenerationWhereInput
    /**
     * Limit how many BlogAIGenerations to update.
     */
    limit?: number
  }

  /**
   * BlogAIGeneration updateManyAndReturn
   */
  export type BlogAIGenerationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * The data used to update BlogAIGenerations.
     */
    data: XOR<BlogAIGenerationUpdateManyMutationInput, BlogAIGenerationUncheckedUpdateManyInput>
    /**
     * Filter which BlogAIGenerations to update
     */
    where?: BlogAIGenerationWhereInput
    /**
     * Limit how many BlogAIGenerations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogAIGeneration upsert
   */
  export type BlogAIGenerationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogAIGeneration to update in case it exists.
     */
    where: BlogAIGenerationWhereUniqueInput
    /**
     * In case the BlogAIGeneration found by the `where` argument doesn't exist, create a new BlogAIGeneration with this data.
     */
    create: XOR<BlogAIGenerationCreateInput, BlogAIGenerationUncheckedCreateInput>
    /**
     * In case the BlogAIGeneration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogAIGenerationUpdateInput, BlogAIGenerationUncheckedUpdateInput>
  }

  /**
   * BlogAIGeneration delete
   */
  export type BlogAIGenerationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationInclude<ExtArgs> | null
    /**
     * Filter which BlogAIGeneration to delete.
     */
    where: BlogAIGenerationWhereUniqueInput
  }

  /**
   * BlogAIGeneration deleteMany
   */
  export type BlogAIGenerationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogAIGenerations to delete
     */
    where?: BlogAIGenerationWhereInput
    /**
     * Limit how many BlogAIGenerations to delete.
     */
    limit?: number
  }

  /**
   * BlogAIGeneration.blogPosts
   */
  export type BlogAIGeneration$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogAIGeneration without action
   */
  export type BlogAIGenerationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogAIGeneration
     */
    select?: BlogAIGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogAIGeneration
     */
    omit?: BlogAIGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogAIGenerationInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    emailsSent: number | null
    recipients: number | null
    openRate: number | null
    clickRate: number | null
  }

  export type CampaignSumAggregateOutputType = {
    emailsSent: number | null
    recipients: number | null
    openRate: number | null
    clickRate: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    userId: string | null
    description: string | null
    type: string | null
    status: $Enums.CampaignStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    emailsSent: number | null
    recipients: number | null
    openRate: number | null
    clickRate: number | null
    lastSentAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    userId: string | null
    description: string | null
    type: string | null
    status: $Enums.CampaignStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    emailsSent: number | null
    recipients: number | null
    openRate: number | null
    clickRate: number | null
    lastSentAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    userId: number
    description: number
    type: number
    status: number
    createdAt: number
    updatedAt: number
    emailsSent: number
    recipients: number
    openRate: number
    clickRate: number
    lastSentAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    emailsSent?: true
    recipients?: true
    openRate?: true
    clickRate?: true
  }

  export type CampaignSumAggregateInputType = {
    emailsSent?: true
    recipients?: true
    openRate?: true
    clickRate?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    description?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    emailsSent?: true
    recipients?: true
    openRate?: true
    clickRate?: true
    lastSentAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    description?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    emailsSent?: true
    recipients?: true
    openRate?: true
    clickRate?: true
    lastSentAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    description?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    emailsSent?: true
    recipients?: true
    openRate?: true
    clickRate?: true
    lastSentAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    userId: string
    description: string | null
    type: string | null
    status: $Enums.CampaignStatus
    createdAt: Date
    updatedAt: Date
    emailsSent: number
    recipients: number | null
    openRate: number | null
    clickRate: number | null
    lastSentAt: Date | null
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailsSent?: boolean
    recipients?: boolean
    openRate?: boolean
    clickRate?: boolean
    lastSentAt?: boolean
    emails?: boolean | Campaign$emailsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailsSent?: boolean
    recipients?: boolean
    openRate?: boolean
    clickRate?: boolean
    lastSentAt?: boolean
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailsSent?: boolean
    recipients?: boolean
    openRate?: boolean
    clickRate?: boolean
    lastSentAt?: boolean
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    userId?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailsSent?: boolean
    recipients?: boolean
    openRate?: boolean
    clickRate?: boolean
    lastSentAt?: boolean
  }

  export type CampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "userId" | "description" | "type" | "status" | "createdAt" | "updatedAt" | "emailsSent" | "recipients" | "openRate" | "clickRate" | "lastSentAt", ExtArgs["result"]["campaign"]>
  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emails?: boolean | Campaign$emailsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      emails: Prisma.$EmailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      userId: string
      description: string | null
      type: string | null
      status: $Enums.CampaignStatus
      createdAt: Date
      updatedAt: Date
      emailsSent: number
      recipients: number | null
      openRate: number | null
      clickRate: number | null
      lastSentAt: Date | null
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns and returns the data updated in the database.
     * @param {CampaignUpdateManyAndReturnArgs} args - Arguments to update many Campaigns.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emails<T extends Campaign$emailsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly userId: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly type: FieldRef<"Campaign", 'String'>
    readonly status: FieldRef<"Campaign", 'CampaignStatus'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
    readonly emailsSent: FieldRef<"Campaign", 'Int'>
    readonly recipients: FieldRef<"Campaign", 'Int'>
    readonly openRate: FieldRef<"Campaign", 'Float'>
    readonly clickRate: FieldRef<"Campaign", 'Float'>
    readonly lastSentAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign updateManyAndReturn
   */
  export type CampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to delete.
     */
    limit?: number
  }

  /**
   * Campaign.emails
   */
  export type Campaign$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    cursor?: EmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model Subscriber
   */

  export type AggregateSubscriber = {
    _count: SubscriberCountAggregateOutputType | null
    _min: SubscriberMinAggregateOutputType | null
    _max: SubscriberMaxAggregateOutputType | null
  }

  export type SubscriberMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    newsLetterOwnerId: string | null
    source: string | null
    status: $Enums.SubscriptionStatus | null
    campaignId: string | null
    pageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriberMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    newsLetterOwnerId: string | null
    source: string | null
    status: $Enums.SubscriptionStatus | null
    campaignId: string | null
    pageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriberCountAggregateOutputType = {
    id: number
    email: number
    name: number
    newsLetterOwnerId: number
    source: number
    status: number
    campaignId: number
    pageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriberMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    newsLetterOwnerId?: true
    source?: true
    status?: true
    campaignId?: true
    pageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriberMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    newsLetterOwnerId?: true
    source?: true
    status?: true
    campaignId?: true
    pageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriberCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    newsLetterOwnerId?: true
    source?: true
    status?: true
    campaignId?: true
    pageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriber to aggregate.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscribers
    **/
    _count?: true | SubscriberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriberMaxAggregateInputType
  }

  export type GetSubscriberAggregateType<T extends SubscriberAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriber[P]>
      : GetScalarType<T[P], AggregateSubscriber[P]>
  }




  export type SubscriberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriberWhereInput
    orderBy?: SubscriberOrderByWithAggregationInput | SubscriberOrderByWithAggregationInput[]
    by: SubscriberScalarFieldEnum[] | SubscriberScalarFieldEnum
    having?: SubscriberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriberCountAggregateInputType | true
    _min?: SubscriberMinAggregateInputType
    _max?: SubscriberMaxAggregateInputType
  }

  export type SubscriberGroupByOutputType = {
    id: string
    email: string
    name: string | null
    newsLetterOwnerId: string
    source: string
    status: $Enums.SubscriptionStatus
    campaignId: string | null
    pageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriberCountAggregateOutputType | null
    _min: SubscriberMinAggregateOutputType | null
    _max: SubscriberMaxAggregateOutputType | null
  }

  type GetSubscriberGroupByPayload<T extends SubscriberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriberGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriberGroupByOutputType[P]>
        }
      >
    >


  export type SubscriberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    newsLetterOwnerId?: boolean
    source?: boolean
    status?: boolean
    campaignId?: boolean
    pageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriber"]>

  export type SubscriberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    newsLetterOwnerId?: boolean
    source?: boolean
    status?: boolean
    campaignId?: boolean
    pageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriber"]>

  export type SubscriberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    newsLetterOwnerId?: boolean
    source?: boolean
    status?: boolean
    campaignId?: boolean
    pageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriber"]>

  export type SubscriberSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    newsLetterOwnerId?: boolean
    source?: boolean
    status?: boolean
    campaignId?: boolean
    pageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "newsLetterOwnerId" | "source" | "status" | "campaignId" | "pageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["subscriber"]>

  export type $SubscriberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscriber"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      newsLetterOwnerId: string
      source: string
      status: $Enums.SubscriptionStatus
      campaignId: string | null
      pageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriber"]>
    composites: {}
  }

  type SubscriberGetPayload<S extends boolean | null | undefined | SubscriberDefaultArgs> = $Result.GetResult<Prisma.$SubscriberPayload, S>

  type SubscriberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriberCountAggregateInputType | true
    }

  export interface SubscriberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscriber'], meta: { name: 'Subscriber' } }
    /**
     * Find zero or one Subscriber that matches the filter.
     * @param {SubscriberFindUniqueArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriberFindUniqueArgs>(args: SelectSubset<T, SubscriberFindUniqueArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscriber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriberFindUniqueOrThrowArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriberFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindFirstArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriberFindFirstArgs>(args?: SelectSubset<T, SubscriberFindFirstArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindFirstOrThrowArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriberFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriberFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscribers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscribers
     * const subscribers = await prisma.subscriber.findMany()
     * 
     * // Get first 10 Subscribers
     * const subscribers = await prisma.subscriber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriberWithIdOnly = await prisma.subscriber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriberFindManyArgs>(args?: SelectSubset<T, SubscriberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscriber.
     * @param {SubscriberCreateArgs} args - Arguments to create a Subscriber.
     * @example
     * // Create one Subscriber
     * const Subscriber = await prisma.subscriber.create({
     *   data: {
     *     // ... data to create a Subscriber
     *   }
     * })
     * 
     */
    create<T extends SubscriberCreateArgs>(args: SelectSubset<T, SubscriberCreateArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscribers.
     * @param {SubscriberCreateManyArgs} args - Arguments to create many Subscribers.
     * @example
     * // Create many Subscribers
     * const subscriber = await prisma.subscriber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriberCreateManyArgs>(args?: SelectSubset<T, SubscriberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscribers and returns the data saved in the database.
     * @param {SubscriberCreateManyAndReturnArgs} args - Arguments to create many Subscribers.
     * @example
     * // Create many Subscribers
     * const subscriber = await prisma.subscriber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscribers and only return the `id`
     * const subscriberWithIdOnly = await prisma.subscriber.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriberCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscriber.
     * @param {SubscriberDeleteArgs} args - Arguments to delete one Subscriber.
     * @example
     * // Delete one Subscriber
     * const Subscriber = await prisma.subscriber.delete({
     *   where: {
     *     // ... filter to delete one Subscriber
     *   }
     * })
     * 
     */
    delete<T extends SubscriberDeleteArgs>(args: SelectSubset<T, SubscriberDeleteArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscriber.
     * @param {SubscriberUpdateArgs} args - Arguments to update one Subscriber.
     * @example
     * // Update one Subscriber
     * const subscriber = await prisma.subscriber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriberUpdateArgs>(args: SelectSubset<T, SubscriberUpdateArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscribers.
     * @param {SubscriberDeleteManyArgs} args - Arguments to filter Subscribers to delete.
     * @example
     * // Delete a few Subscribers
     * const { count } = await prisma.subscriber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriberDeleteManyArgs>(args?: SelectSubset<T, SubscriberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscribers
     * const subscriber = await prisma.subscriber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriberUpdateManyArgs>(args: SelectSubset<T, SubscriberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscribers and returns the data updated in the database.
     * @param {SubscriberUpdateManyAndReturnArgs} args - Arguments to update many Subscribers.
     * @example
     * // Update many Subscribers
     * const subscriber = await prisma.subscriber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscribers and only return the `id`
     * const subscriberWithIdOnly = await prisma.subscriber.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriberUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscriber.
     * @param {SubscriberUpsertArgs} args - Arguments to update or create a Subscriber.
     * @example
     * // Update or create a Subscriber
     * const subscriber = await prisma.subscriber.upsert({
     *   create: {
     *     // ... data to create a Subscriber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriber we want to update
     *   }
     * })
     */
    upsert<T extends SubscriberUpsertArgs>(args: SelectSubset<T, SubscriberUpsertArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberCountArgs} args - Arguments to filter Subscribers to count.
     * @example
     * // Count the number of Subscribers
     * const count = await prisma.subscriber.count({
     *   where: {
     *     // ... the filter for the Subscribers we want to count
     *   }
     * })
    **/
    count<T extends SubscriberCountArgs>(
      args?: Subset<T, SubscriberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriberAggregateArgs>(args: Subset<T, SubscriberAggregateArgs>): Prisma.PrismaPromise<GetSubscriberAggregateType<T>>

    /**
     * Group by Subscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriberGroupByArgs['orderBy'] }
        : { orderBy?: SubscriberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscriber model
   */
  readonly fields: SubscriberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscriber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscriber model
   */
  interface SubscriberFieldRefs {
    readonly id: FieldRef<"Subscriber", 'String'>
    readonly email: FieldRef<"Subscriber", 'String'>
    readonly name: FieldRef<"Subscriber", 'String'>
    readonly newsLetterOwnerId: FieldRef<"Subscriber", 'String'>
    readonly source: FieldRef<"Subscriber", 'String'>
    readonly status: FieldRef<"Subscriber", 'SubscriptionStatus'>
    readonly campaignId: FieldRef<"Subscriber", 'String'>
    readonly pageUrl: FieldRef<"Subscriber", 'String'>
    readonly createdAt: FieldRef<"Subscriber", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscriber", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscriber findUnique
   */
  export type SubscriberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber findUniqueOrThrow
   */
  export type SubscriberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber findFirst
   */
  export type SubscriberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscribers.
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscribers.
     */
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Subscriber findFirstOrThrow
   */
  export type SubscriberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscribers.
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscribers.
     */
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Subscriber findMany
   */
  export type SubscriberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * Filter, which Subscribers to fetch.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscribers.
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Subscriber create
   */
  export type SubscriberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * The data needed to create a Subscriber.
     */
    data: XOR<SubscriberCreateInput, SubscriberUncheckedCreateInput>
  }

  /**
   * Subscriber createMany
   */
  export type SubscriberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscribers.
     */
    data: SubscriberCreateManyInput | SubscriberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscriber createManyAndReturn
   */
  export type SubscriberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * The data used to create many Subscribers.
     */
    data: SubscriberCreateManyInput | SubscriberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscriber update
   */
  export type SubscriberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * The data needed to update a Subscriber.
     */
    data: XOR<SubscriberUpdateInput, SubscriberUncheckedUpdateInput>
    /**
     * Choose, which Subscriber to update.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber updateMany
   */
  export type SubscriberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscribers.
     */
    data: XOR<SubscriberUpdateManyMutationInput, SubscriberUncheckedUpdateManyInput>
    /**
     * Filter which Subscribers to update
     */
    where?: SubscriberWhereInput
    /**
     * Limit how many Subscribers to update.
     */
    limit?: number
  }

  /**
   * Subscriber updateManyAndReturn
   */
  export type SubscriberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * The data used to update Subscribers.
     */
    data: XOR<SubscriberUpdateManyMutationInput, SubscriberUncheckedUpdateManyInput>
    /**
     * Filter which Subscribers to update
     */
    where?: SubscriberWhereInput
    /**
     * Limit how many Subscribers to update.
     */
    limit?: number
  }

  /**
   * Subscriber upsert
   */
  export type SubscriberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * The filter to search for the Subscriber to update in case it exists.
     */
    where: SubscriberWhereUniqueInput
    /**
     * In case the Subscriber found by the `where` argument doesn't exist, create a new Subscriber with this data.
     */
    create: XOR<SubscriberCreateInput, SubscriberUncheckedCreateInput>
    /**
     * In case the Subscriber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriberUpdateInput, SubscriberUncheckedUpdateInput>
  }

  /**
   * Subscriber delete
   */
  export type SubscriberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * Filter which Subscriber to delete.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber deleteMany
   */
  export type SubscriberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscribers to delete
     */
    where?: SubscriberWhereInput
    /**
     * Limit how many Subscribers to delete.
     */
    limit?: number
  }

  /**
   * Subscriber without action
   */
  export type SubscriberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
  }


  /**
   * Model EmailNotification
   */

  export type AggregateEmailNotification = {
    _count: EmailNotificationCountAggregateOutputType | null
    _avg: EmailNotificationAvgAggregateOutputType | null
    _sum: EmailNotificationSumAggregateOutputType | null
    _min: EmailNotificationMinAggregateOutputType | null
    _max: EmailNotificationMaxAggregateOutputType | null
  }

  export type EmailNotificationAvgAggregateOutputType = {
    emailsSentCount: number | null
    openCount: number | null
    clickCount: number | null
    recipients: number | null
    bounceCount: number | null
  }

  export type EmailNotificationSumAggregateOutputType = {
    emailsSentCount: number | null
    openCount: number | null
    clickCount: number | null
    recipients: number | null
    bounceCount: number | null
  }

  export type EmailNotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    category: $Enums.NotificationCategory | null
    title: string | null
    textContent: string | null
    htmlContent: string | null
    status: $Enums.NotificationStatus | null
    priority: $Enums.NotificationPriority | null
    userId: string | null
    emailsSentCount: number | null
    openCount: number | null
    clickCount: number | null
    recipients: number | null
    bounceCount: number | null
    lastOpened: Date | null
    lastClicked: Date | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    read: boolean | null
  }

  export type EmailNotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    category: $Enums.NotificationCategory | null
    title: string | null
    textContent: string | null
    htmlContent: string | null
    status: $Enums.NotificationStatus | null
    priority: $Enums.NotificationPriority | null
    userId: string | null
    emailsSentCount: number | null
    openCount: number | null
    clickCount: number | null
    recipients: number | null
    bounceCount: number | null
    lastOpened: Date | null
    lastClicked: Date | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    read: boolean | null
  }

  export type EmailNotificationCountAggregateOutputType = {
    id: number
    type: number
    category: number
    title: number
    content: number
    textContent: number
    htmlContent: number
    status: number
    priority: number
    userId: number
    emailsSentCount: number
    openCount: number
    clickCount: number
    recipients: number
    bounceCount: number
    openedByEmails: number
    clickedByEmails: number
    lastOpened: number
    lastClicked: number
    metadata: number
    sentAt: number
    createdAt: number
    updatedAt: number
    read: number
    _all: number
  }


  export type EmailNotificationAvgAggregateInputType = {
    emailsSentCount?: true
    openCount?: true
    clickCount?: true
    recipients?: true
    bounceCount?: true
  }

  export type EmailNotificationSumAggregateInputType = {
    emailsSentCount?: true
    openCount?: true
    clickCount?: true
    recipients?: true
    bounceCount?: true
  }

  export type EmailNotificationMinAggregateInputType = {
    id?: true
    type?: true
    category?: true
    title?: true
    textContent?: true
    htmlContent?: true
    status?: true
    priority?: true
    userId?: true
    emailsSentCount?: true
    openCount?: true
    clickCount?: true
    recipients?: true
    bounceCount?: true
    lastOpened?: true
    lastClicked?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    read?: true
  }

  export type EmailNotificationMaxAggregateInputType = {
    id?: true
    type?: true
    category?: true
    title?: true
    textContent?: true
    htmlContent?: true
    status?: true
    priority?: true
    userId?: true
    emailsSentCount?: true
    openCount?: true
    clickCount?: true
    recipients?: true
    bounceCount?: true
    lastOpened?: true
    lastClicked?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    read?: true
  }

  export type EmailNotificationCountAggregateInputType = {
    id?: true
    type?: true
    category?: true
    title?: true
    content?: true
    textContent?: true
    htmlContent?: true
    status?: true
    priority?: true
    userId?: true
    emailsSentCount?: true
    openCount?: true
    clickCount?: true
    recipients?: true
    bounceCount?: true
    openedByEmails?: true
    clickedByEmails?: true
    lastOpened?: true
    lastClicked?: true
    metadata?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    read?: true
    _all?: true
  }

  export type EmailNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailNotification to aggregate.
     */
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     */
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailNotifications
    **/
    _count?: true | EmailNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailNotificationMaxAggregateInputType
  }

  export type GetEmailNotificationAggregateType<T extends EmailNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailNotification[P]>
      : GetScalarType<T[P], AggregateEmailNotification[P]>
  }




  export type EmailNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailNotificationWhereInput
    orderBy?: EmailNotificationOrderByWithAggregationInput | EmailNotificationOrderByWithAggregationInput[]
    by: EmailNotificationScalarFieldEnum[] | EmailNotificationScalarFieldEnum
    having?: EmailNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailNotificationCountAggregateInputType | true
    _avg?: EmailNotificationAvgAggregateInputType
    _sum?: EmailNotificationSumAggregateInputType
    _min?: EmailNotificationMinAggregateInputType
    _max?: EmailNotificationMaxAggregateInputType
  }

  export type EmailNotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    title: string
    content: JsonValue
    textContent: string | null
    htmlContent: string | null
    status: $Enums.NotificationStatus
    priority: $Enums.NotificationPriority
    userId: string
    emailsSentCount: number | null
    openCount: number | null
    clickCount: number | null
    recipients: number | null
    bounceCount: number | null
    openedByEmails: string[]
    clickedByEmails: string[]
    lastOpened: Date | null
    lastClicked: Date | null
    metadata: JsonValue | null
    sentAt: Date | null
    createdAt: Date
    updatedAt: Date
    read: boolean
    _count: EmailNotificationCountAggregateOutputType | null
    _avg: EmailNotificationAvgAggregateOutputType | null
    _sum: EmailNotificationSumAggregateOutputType | null
    _min: EmailNotificationMinAggregateOutputType | null
    _max: EmailNotificationMaxAggregateOutputType | null
  }

  type GetEmailNotificationGroupByPayload<T extends EmailNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], EmailNotificationGroupByOutputType[P]>
        }
      >
    >


  export type EmailNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    textContent?: boolean
    htmlContent?: boolean
    status?: boolean
    priority?: boolean
    userId?: boolean
    emailsSentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    recipients?: boolean
    bounceCount?: boolean
    openedByEmails?: boolean
    clickedByEmails?: boolean
    lastOpened?: boolean
    lastClicked?: boolean
    metadata?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    read?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    NotificationEmailClickedLink?: boolean | EmailNotification$NotificationEmailClickedLinkArgs<ExtArgs>
    _count?: boolean | EmailNotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailNotification"]>

  export type EmailNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    textContent?: boolean
    htmlContent?: boolean
    status?: boolean
    priority?: boolean
    userId?: boolean
    emailsSentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    recipients?: boolean
    bounceCount?: boolean
    openedByEmails?: boolean
    clickedByEmails?: boolean
    lastOpened?: boolean
    lastClicked?: boolean
    metadata?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    read?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailNotification"]>

  export type EmailNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    textContent?: boolean
    htmlContent?: boolean
    status?: boolean
    priority?: boolean
    userId?: boolean
    emailsSentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    recipients?: boolean
    bounceCount?: boolean
    openedByEmails?: boolean
    clickedByEmails?: boolean
    lastOpened?: boolean
    lastClicked?: boolean
    metadata?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    read?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailNotification"]>

  export type EmailNotificationSelectScalar = {
    id?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    textContent?: boolean
    htmlContent?: boolean
    status?: boolean
    priority?: boolean
    userId?: boolean
    emailsSentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    recipients?: boolean
    bounceCount?: boolean
    openedByEmails?: boolean
    clickedByEmails?: boolean
    lastOpened?: boolean
    lastClicked?: boolean
    metadata?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    read?: boolean
  }

  export type EmailNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "category" | "title" | "content" | "textContent" | "htmlContent" | "status" | "priority" | "userId" | "emailsSentCount" | "openCount" | "clickCount" | "recipients" | "bounceCount" | "openedByEmails" | "clickedByEmails" | "lastOpened" | "lastClicked" | "metadata" | "sentAt" | "createdAt" | "updatedAt" | "read", ExtArgs["result"]["emailNotification"]>
  export type EmailNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    NotificationEmailClickedLink?: boolean | EmailNotification$NotificationEmailClickedLinkArgs<ExtArgs>
    _count?: boolean | EmailNotificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailNotification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      NotificationEmailClickedLink: Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      category: $Enums.NotificationCategory
      title: string
      content: Prisma.JsonValue
      textContent: string | null
      htmlContent: string | null
      status: $Enums.NotificationStatus
      priority: $Enums.NotificationPriority
      userId: string
      emailsSentCount: number | null
      openCount: number | null
      clickCount: number | null
      recipients: number | null
      bounceCount: number | null
      openedByEmails: string[]
      clickedByEmails: string[]
      lastOpened: Date | null
      lastClicked: Date | null
      metadata: Prisma.JsonValue | null
      sentAt: Date | null
      createdAt: Date
      updatedAt: Date
      read: boolean
    }, ExtArgs["result"]["emailNotification"]>
    composites: {}
  }

  type EmailNotificationGetPayload<S extends boolean | null | undefined | EmailNotificationDefaultArgs> = $Result.GetResult<Prisma.$EmailNotificationPayload, S>

  type EmailNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailNotificationCountAggregateInputType | true
    }

  export interface EmailNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailNotification'], meta: { name: 'EmailNotification' } }
    /**
     * Find zero or one EmailNotification that matches the filter.
     * @param {EmailNotificationFindUniqueArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailNotificationFindUniqueArgs>(args: SelectSubset<T, EmailNotificationFindUniqueArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailNotificationFindUniqueOrThrowArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindFirstArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailNotificationFindFirstArgs>(args?: SelectSubset<T, EmailNotificationFindFirstArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindFirstOrThrowArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailNotifications
     * const emailNotifications = await prisma.emailNotification.findMany()
     * 
     * // Get first 10 EmailNotifications
     * const emailNotifications = await prisma.emailNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailNotificationWithIdOnly = await prisma.emailNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailNotificationFindManyArgs>(args?: SelectSubset<T, EmailNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailNotification.
     * @param {EmailNotificationCreateArgs} args - Arguments to create a EmailNotification.
     * @example
     * // Create one EmailNotification
     * const EmailNotification = await prisma.emailNotification.create({
     *   data: {
     *     // ... data to create a EmailNotification
     *   }
     * })
     * 
     */
    create<T extends EmailNotificationCreateArgs>(args: SelectSubset<T, EmailNotificationCreateArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailNotifications.
     * @param {EmailNotificationCreateManyArgs} args - Arguments to create many EmailNotifications.
     * @example
     * // Create many EmailNotifications
     * const emailNotification = await prisma.emailNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailNotificationCreateManyArgs>(args?: SelectSubset<T, EmailNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailNotifications and returns the data saved in the database.
     * @param {EmailNotificationCreateManyAndReturnArgs} args - Arguments to create many EmailNotifications.
     * @example
     * // Create many EmailNotifications
     * const emailNotification = await prisma.emailNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailNotifications and only return the `id`
     * const emailNotificationWithIdOnly = await prisma.emailNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailNotification.
     * @param {EmailNotificationDeleteArgs} args - Arguments to delete one EmailNotification.
     * @example
     * // Delete one EmailNotification
     * const EmailNotification = await prisma.emailNotification.delete({
     *   where: {
     *     // ... filter to delete one EmailNotification
     *   }
     * })
     * 
     */
    delete<T extends EmailNotificationDeleteArgs>(args: SelectSubset<T, EmailNotificationDeleteArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailNotification.
     * @param {EmailNotificationUpdateArgs} args - Arguments to update one EmailNotification.
     * @example
     * // Update one EmailNotification
     * const emailNotification = await prisma.emailNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailNotificationUpdateArgs>(args: SelectSubset<T, EmailNotificationUpdateArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailNotifications.
     * @param {EmailNotificationDeleteManyArgs} args - Arguments to filter EmailNotifications to delete.
     * @example
     * // Delete a few EmailNotifications
     * const { count } = await prisma.emailNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailNotificationDeleteManyArgs>(args?: SelectSubset<T, EmailNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailNotifications
     * const emailNotification = await prisma.emailNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailNotificationUpdateManyArgs>(args: SelectSubset<T, EmailNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailNotifications and returns the data updated in the database.
     * @param {EmailNotificationUpdateManyAndReturnArgs} args - Arguments to update many EmailNotifications.
     * @example
     * // Update many EmailNotifications
     * const emailNotification = await prisma.emailNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailNotifications and only return the `id`
     * const emailNotificationWithIdOnly = await prisma.emailNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailNotification.
     * @param {EmailNotificationUpsertArgs} args - Arguments to update or create a EmailNotification.
     * @example
     * // Update or create a EmailNotification
     * const emailNotification = await prisma.emailNotification.upsert({
     *   create: {
     *     // ... data to create a EmailNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailNotification we want to update
     *   }
     * })
     */
    upsert<T extends EmailNotificationUpsertArgs>(args: SelectSubset<T, EmailNotificationUpsertArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationCountArgs} args - Arguments to filter EmailNotifications to count.
     * @example
     * // Count the number of EmailNotifications
     * const count = await prisma.emailNotification.count({
     *   where: {
     *     // ... the filter for the EmailNotifications we want to count
     *   }
     * })
    **/
    count<T extends EmailNotificationCountArgs>(
      args?: Subset<T, EmailNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailNotificationAggregateArgs>(args: Subset<T, EmailNotificationAggregateArgs>): Prisma.PrismaPromise<GetEmailNotificationAggregateType<T>>

    /**
     * Group by EmailNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailNotificationGroupByArgs['orderBy'] }
        : { orderBy?: EmailNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailNotification model
   */
  readonly fields: EmailNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    NotificationEmailClickedLink<T extends EmailNotification$NotificationEmailClickedLinkArgs<ExtArgs> = {}>(args?: Subset<T, EmailNotification$NotificationEmailClickedLinkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailNotification model
   */
  interface EmailNotificationFieldRefs {
    readonly id: FieldRef<"EmailNotification", 'String'>
    readonly type: FieldRef<"EmailNotification", 'NotificationType'>
    readonly category: FieldRef<"EmailNotification", 'NotificationCategory'>
    readonly title: FieldRef<"EmailNotification", 'String'>
    readonly content: FieldRef<"EmailNotification", 'Json'>
    readonly textContent: FieldRef<"EmailNotification", 'String'>
    readonly htmlContent: FieldRef<"EmailNotification", 'String'>
    readonly status: FieldRef<"EmailNotification", 'NotificationStatus'>
    readonly priority: FieldRef<"EmailNotification", 'NotificationPriority'>
    readonly userId: FieldRef<"EmailNotification", 'String'>
    readonly emailsSentCount: FieldRef<"EmailNotification", 'Int'>
    readonly openCount: FieldRef<"EmailNotification", 'Int'>
    readonly clickCount: FieldRef<"EmailNotification", 'Int'>
    readonly recipients: FieldRef<"EmailNotification", 'Int'>
    readonly bounceCount: FieldRef<"EmailNotification", 'Int'>
    readonly openedByEmails: FieldRef<"EmailNotification", 'String[]'>
    readonly clickedByEmails: FieldRef<"EmailNotification", 'String[]'>
    readonly lastOpened: FieldRef<"EmailNotification", 'DateTime'>
    readonly lastClicked: FieldRef<"EmailNotification", 'DateTime'>
    readonly metadata: FieldRef<"EmailNotification", 'Json'>
    readonly sentAt: FieldRef<"EmailNotification", 'DateTime'>
    readonly createdAt: FieldRef<"EmailNotification", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailNotification", 'DateTime'>
    readonly read: FieldRef<"EmailNotification", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EmailNotification findUnique
   */
  export type EmailNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailNotification to fetch.
     */
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification findUniqueOrThrow
   */
  export type EmailNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailNotification to fetch.
     */
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification findFirst
   */
  export type EmailNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailNotification to fetch.
     */
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     */
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailNotifications.
     */
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailNotifications.
     */
    distinct?: EmailNotificationScalarFieldEnum | EmailNotificationScalarFieldEnum[]
  }

  /**
   * EmailNotification findFirstOrThrow
   */
  export type EmailNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailNotification to fetch.
     */
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     */
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailNotifications.
     */
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailNotifications.
     */
    distinct?: EmailNotificationScalarFieldEnum | EmailNotificationScalarFieldEnum[]
  }

  /**
   * EmailNotification findMany
   */
  export type EmailNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailNotifications to fetch.
     */
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     */
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailNotifications.
     */
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     */
    skip?: number
    distinct?: EmailNotificationScalarFieldEnum | EmailNotificationScalarFieldEnum[]
  }

  /**
   * EmailNotification create
   */
  export type EmailNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailNotification.
     */
    data: XOR<EmailNotificationCreateInput, EmailNotificationUncheckedCreateInput>
  }

  /**
   * EmailNotification createMany
   */
  export type EmailNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailNotifications.
     */
    data: EmailNotificationCreateManyInput | EmailNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailNotification createManyAndReturn
   */
  export type EmailNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many EmailNotifications.
     */
    data: EmailNotificationCreateManyInput | EmailNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailNotification update
   */
  export type EmailNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailNotification.
     */
    data: XOR<EmailNotificationUpdateInput, EmailNotificationUncheckedUpdateInput>
    /**
     * Choose, which EmailNotification to update.
     */
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification updateMany
   */
  export type EmailNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailNotifications.
     */
    data: XOR<EmailNotificationUpdateManyMutationInput, EmailNotificationUncheckedUpdateManyInput>
    /**
     * Filter which EmailNotifications to update
     */
    where?: EmailNotificationWhereInput
    /**
     * Limit how many EmailNotifications to update.
     */
    limit?: number
  }

  /**
   * EmailNotification updateManyAndReturn
   */
  export type EmailNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * The data used to update EmailNotifications.
     */
    data: XOR<EmailNotificationUpdateManyMutationInput, EmailNotificationUncheckedUpdateManyInput>
    /**
     * Filter which EmailNotifications to update
     */
    where?: EmailNotificationWhereInput
    /**
     * Limit how many EmailNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailNotification upsert
   */
  export type EmailNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailNotification to update in case it exists.
     */
    where: EmailNotificationWhereUniqueInput
    /**
     * In case the EmailNotification found by the `where` argument doesn't exist, create a new EmailNotification with this data.
     */
    create: XOR<EmailNotificationCreateInput, EmailNotificationUncheckedCreateInput>
    /**
     * In case the EmailNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailNotificationUpdateInput, EmailNotificationUncheckedUpdateInput>
  }

  /**
   * EmailNotification delete
   */
  export type EmailNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * Filter which EmailNotification to delete.
     */
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification deleteMany
   */
  export type EmailNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailNotifications to delete
     */
    where?: EmailNotificationWhereInput
    /**
     * Limit how many EmailNotifications to delete.
     */
    limit?: number
  }

  /**
   * EmailNotification.NotificationEmailClickedLink
   */
  export type EmailNotification$NotificationEmailClickedLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkInclude<ExtArgs> | null
    where?: NotificationEmailClickedLinkWhereInput
    orderBy?: NotificationEmailClickedLinkOrderByWithRelationInput | NotificationEmailClickedLinkOrderByWithRelationInput[]
    cursor?: NotificationEmailClickedLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationEmailClickedLinkScalarFieldEnum | NotificationEmailClickedLinkScalarFieldEnum[]
  }

  /**
   * EmailNotification without action
   */
  export type EmailNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
  }


  /**
   * Model ClickedLink
   */

  export type AggregateClickedLink = {
    _count: ClickedLinkCountAggregateOutputType | null
    _min: ClickedLinkMinAggregateOutputType | null
    _max: ClickedLinkMaxAggregateOutputType | null
  }

  export type ClickedLinkMinAggregateOutputType = {
    id: string | null
    emailId: string | null
    url: string | null
    clickedAt: Date | null
    clickedBy: string | null
  }

  export type ClickedLinkMaxAggregateOutputType = {
    id: string | null
    emailId: string | null
    url: string | null
    clickedAt: Date | null
    clickedBy: string | null
  }

  export type ClickedLinkCountAggregateOutputType = {
    id: number
    emailId: number
    url: number
    clickedAt: number
    clickedBy: number
    _all: number
  }


  export type ClickedLinkMinAggregateInputType = {
    id?: true
    emailId?: true
    url?: true
    clickedAt?: true
    clickedBy?: true
  }

  export type ClickedLinkMaxAggregateInputType = {
    id?: true
    emailId?: true
    url?: true
    clickedAt?: true
    clickedBy?: true
  }

  export type ClickedLinkCountAggregateInputType = {
    id?: true
    emailId?: true
    url?: true
    clickedAt?: true
    clickedBy?: true
    _all?: true
  }

  export type ClickedLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClickedLink to aggregate.
     */
    where?: ClickedLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClickedLinks to fetch.
     */
    orderBy?: ClickedLinkOrderByWithRelationInput | ClickedLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClickedLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClickedLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClickedLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClickedLinks
    **/
    _count?: true | ClickedLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClickedLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClickedLinkMaxAggregateInputType
  }

  export type GetClickedLinkAggregateType<T extends ClickedLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateClickedLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClickedLink[P]>
      : GetScalarType<T[P], AggregateClickedLink[P]>
  }




  export type ClickedLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClickedLinkWhereInput
    orderBy?: ClickedLinkOrderByWithAggregationInput | ClickedLinkOrderByWithAggregationInput[]
    by: ClickedLinkScalarFieldEnum[] | ClickedLinkScalarFieldEnum
    having?: ClickedLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClickedLinkCountAggregateInputType | true
    _min?: ClickedLinkMinAggregateInputType
    _max?: ClickedLinkMaxAggregateInputType
  }

  export type ClickedLinkGroupByOutputType = {
    id: string
    emailId: string
    url: string
    clickedAt: Date
    clickedBy: string | null
    _count: ClickedLinkCountAggregateOutputType | null
    _min: ClickedLinkMinAggregateOutputType | null
    _max: ClickedLinkMaxAggregateOutputType | null
  }

  type GetClickedLinkGroupByPayload<T extends ClickedLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClickedLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClickedLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClickedLinkGroupByOutputType[P]>
            : GetScalarType<T[P], ClickedLinkGroupByOutputType[P]>
        }
      >
    >


  export type ClickedLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    url?: boolean
    clickedAt?: boolean
    clickedBy?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clickedLink"]>

  export type ClickedLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    url?: boolean
    clickedAt?: boolean
    clickedBy?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clickedLink"]>

  export type ClickedLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    url?: boolean
    clickedAt?: boolean
    clickedBy?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clickedLink"]>

  export type ClickedLinkSelectScalar = {
    id?: boolean
    emailId?: boolean
    url?: boolean
    clickedAt?: boolean
    clickedBy?: boolean
  }

  export type ClickedLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emailId" | "url" | "clickedAt" | "clickedBy", ExtArgs["result"]["clickedLink"]>
  export type ClickedLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type ClickedLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type ClickedLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }

  export type $ClickedLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClickedLink"
    objects: {
      email: Prisma.$EmailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emailId: string
      url: string
      clickedAt: Date
      clickedBy: string | null
    }, ExtArgs["result"]["clickedLink"]>
    composites: {}
  }

  type ClickedLinkGetPayload<S extends boolean | null | undefined | ClickedLinkDefaultArgs> = $Result.GetResult<Prisma.$ClickedLinkPayload, S>

  type ClickedLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClickedLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClickedLinkCountAggregateInputType | true
    }

  export interface ClickedLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClickedLink'], meta: { name: 'ClickedLink' } }
    /**
     * Find zero or one ClickedLink that matches the filter.
     * @param {ClickedLinkFindUniqueArgs} args - Arguments to find a ClickedLink
     * @example
     * // Get one ClickedLink
     * const clickedLink = await prisma.clickedLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClickedLinkFindUniqueArgs>(args: SelectSubset<T, ClickedLinkFindUniqueArgs<ExtArgs>>): Prisma__ClickedLinkClient<$Result.GetResult<Prisma.$ClickedLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClickedLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClickedLinkFindUniqueOrThrowArgs} args - Arguments to find a ClickedLink
     * @example
     * // Get one ClickedLink
     * const clickedLink = await prisma.clickedLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClickedLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, ClickedLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClickedLinkClient<$Result.GetResult<Prisma.$ClickedLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClickedLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickedLinkFindFirstArgs} args - Arguments to find a ClickedLink
     * @example
     * // Get one ClickedLink
     * const clickedLink = await prisma.clickedLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClickedLinkFindFirstArgs>(args?: SelectSubset<T, ClickedLinkFindFirstArgs<ExtArgs>>): Prisma__ClickedLinkClient<$Result.GetResult<Prisma.$ClickedLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClickedLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickedLinkFindFirstOrThrowArgs} args - Arguments to find a ClickedLink
     * @example
     * // Get one ClickedLink
     * const clickedLink = await prisma.clickedLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClickedLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, ClickedLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClickedLinkClient<$Result.GetResult<Prisma.$ClickedLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClickedLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickedLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClickedLinks
     * const clickedLinks = await prisma.clickedLink.findMany()
     * 
     * // Get first 10 ClickedLinks
     * const clickedLinks = await prisma.clickedLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clickedLinkWithIdOnly = await prisma.clickedLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClickedLinkFindManyArgs>(args?: SelectSubset<T, ClickedLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClickedLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClickedLink.
     * @param {ClickedLinkCreateArgs} args - Arguments to create a ClickedLink.
     * @example
     * // Create one ClickedLink
     * const ClickedLink = await prisma.clickedLink.create({
     *   data: {
     *     // ... data to create a ClickedLink
     *   }
     * })
     * 
     */
    create<T extends ClickedLinkCreateArgs>(args: SelectSubset<T, ClickedLinkCreateArgs<ExtArgs>>): Prisma__ClickedLinkClient<$Result.GetResult<Prisma.$ClickedLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClickedLinks.
     * @param {ClickedLinkCreateManyArgs} args - Arguments to create many ClickedLinks.
     * @example
     * // Create many ClickedLinks
     * const clickedLink = await prisma.clickedLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClickedLinkCreateManyArgs>(args?: SelectSubset<T, ClickedLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClickedLinks and returns the data saved in the database.
     * @param {ClickedLinkCreateManyAndReturnArgs} args - Arguments to create many ClickedLinks.
     * @example
     * // Create many ClickedLinks
     * const clickedLink = await prisma.clickedLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClickedLinks and only return the `id`
     * const clickedLinkWithIdOnly = await prisma.clickedLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClickedLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, ClickedLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClickedLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClickedLink.
     * @param {ClickedLinkDeleteArgs} args - Arguments to delete one ClickedLink.
     * @example
     * // Delete one ClickedLink
     * const ClickedLink = await prisma.clickedLink.delete({
     *   where: {
     *     // ... filter to delete one ClickedLink
     *   }
     * })
     * 
     */
    delete<T extends ClickedLinkDeleteArgs>(args: SelectSubset<T, ClickedLinkDeleteArgs<ExtArgs>>): Prisma__ClickedLinkClient<$Result.GetResult<Prisma.$ClickedLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClickedLink.
     * @param {ClickedLinkUpdateArgs} args - Arguments to update one ClickedLink.
     * @example
     * // Update one ClickedLink
     * const clickedLink = await prisma.clickedLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClickedLinkUpdateArgs>(args: SelectSubset<T, ClickedLinkUpdateArgs<ExtArgs>>): Prisma__ClickedLinkClient<$Result.GetResult<Prisma.$ClickedLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClickedLinks.
     * @param {ClickedLinkDeleteManyArgs} args - Arguments to filter ClickedLinks to delete.
     * @example
     * // Delete a few ClickedLinks
     * const { count } = await prisma.clickedLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClickedLinkDeleteManyArgs>(args?: SelectSubset<T, ClickedLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClickedLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickedLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClickedLinks
     * const clickedLink = await prisma.clickedLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClickedLinkUpdateManyArgs>(args: SelectSubset<T, ClickedLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClickedLinks and returns the data updated in the database.
     * @param {ClickedLinkUpdateManyAndReturnArgs} args - Arguments to update many ClickedLinks.
     * @example
     * // Update many ClickedLinks
     * const clickedLink = await prisma.clickedLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClickedLinks and only return the `id`
     * const clickedLinkWithIdOnly = await prisma.clickedLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClickedLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, ClickedLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClickedLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClickedLink.
     * @param {ClickedLinkUpsertArgs} args - Arguments to update or create a ClickedLink.
     * @example
     * // Update or create a ClickedLink
     * const clickedLink = await prisma.clickedLink.upsert({
     *   create: {
     *     // ... data to create a ClickedLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClickedLink we want to update
     *   }
     * })
     */
    upsert<T extends ClickedLinkUpsertArgs>(args: SelectSubset<T, ClickedLinkUpsertArgs<ExtArgs>>): Prisma__ClickedLinkClient<$Result.GetResult<Prisma.$ClickedLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClickedLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickedLinkCountArgs} args - Arguments to filter ClickedLinks to count.
     * @example
     * // Count the number of ClickedLinks
     * const count = await prisma.clickedLink.count({
     *   where: {
     *     // ... the filter for the ClickedLinks we want to count
     *   }
     * })
    **/
    count<T extends ClickedLinkCountArgs>(
      args?: Subset<T, ClickedLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClickedLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClickedLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickedLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClickedLinkAggregateArgs>(args: Subset<T, ClickedLinkAggregateArgs>): Prisma.PrismaPromise<GetClickedLinkAggregateType<T>>

    /**
     * Group by ClickedLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickedLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClickedLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClickedLinkGroupByArgs['orderBy'] }
        : { orderBy?: ClickedLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClickedLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClickedLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClickedLink model
   */
  readonly fields: ClickedLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClickedLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClickedLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email<T extends EmailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDefaultArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClickedLink model
   */
  interface ClickedLinkFieldRefs {
    readonly id: FieldRef<"ClickedLink", 'String'>
    readonly emailId: FieldRef<"ClickedLink", 'String'>
    readonly url: FieldRef<"ClickedLink", 'String'>
    readonly clickedAt: FieldRef<"ClickedLink", 'DateTime'>
    readonly clickedBy: FieldRef<"ClickedLink", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClickedLink findUnique
   */
  export type ClickedLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkInclude<ExtArgs> | null
    /**
     * Filter, which ClickedLink to fetch.
     */
    where: ClickedLinkWhereUniqueInput
  }

  /**
   * ClickedLink findUniqueOrThrow
   */
  export type ClickedLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkInclude<ExtArgs> | null
    /**
     * Filter, which ClickedLink to fetch.
     */
    where: ClickedLinkWhereUniqueInput
  }

  /**
   * ClickedLink findFirst
   */
  export type ClickedLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkInclude<ExtArgs> | null
    /**
     * Filter, which ClickedLink to fetch.
     */
    where?: ClickedLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClickedLinks to fetch.
     */
    orderBy?: ClickedLinkOrderByWithRelationInput | ClickedLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClickedLinks.
     */
    cursor?: ClickedLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClickedLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClickedLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClickedLinks.
     */
    distinct?: ClickedLinkScalarFieldEnum | ClickedLinkScalarFieldEnum[]
  }

  /**
   * ClickedLink findFirstOrThrow
   */
  export type ClickedLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkInclude<ExtArgs> | null
    /**
     * Filter, which ClickedLink to fetch.
     */
    where?: ClickedLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClickedLinks to fetch.
     */
    orderBy?: ClickedLinkOrderByWithRelationInput | ClickedLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClickedLinks.
     */
    cursor?: ClickedLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClickedLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClickedLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClickedLinks.
     */
    distinct?: ClickedLinkScalarFieldEnum | ClickedLinkScalarFieldEnum[]
  }

  /**
   * ClickedLink findMany
   */
  export type ClickedLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkInclude<ExtArgs> | null
    /**
     * Filter, which ClickedLinks to fetch.
     */
    where?: ClickedLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClickedLinks to fetch.
     */
    orderBy?: ClickedLinkOrderByWithRelationInput | ClickedLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClickedLinks.
     */
    cursor?: ClickedLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClickedLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClickedLinks.
     */
    skip?: number
    distinct?: ClickedLinkScalarFieldEnum | ClickedLinkScalarFieldEnum[]
  }

  /**
   * ClickedLink create
   */
  export type ClickedLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a ClickedLink.
     */
    data: XOR<ClickedLinkCreateInput, ClickedLinkUncheckedCreateInput>
  }

  /**
   * ClickedLink createMany
   */
  export type ClickedLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClickedLinks.
     */
    data: ClickedLinkCreateManyInput | ClickedLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClickedLink createManyAndReturn
   */
  export type ClickedLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * The data used to create many ClickedLinks.
     */
    data: ClickedLinkCreateManyInput | ClickedLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClickedLink update
   */
  export type ClickedLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a ClickedLink.
     */
    data: XOR<ClickedLinkUpdateInput, ClickedLinkUncheckedUpdateInput>
    /**
     * Choose, which ClickedLink to update.
     */
    where: ClickedLinkWhereUniqueInput
  }

  /**
   * ClickedLink updateMany
   */
  export type ClickedLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClickedLinks.
     */
    data: XOR<ClickedLinkUpdateManyMutationInput, ClickedLinkUncheckedUpdateManyInput>
    /**
     * Filter which ClickedLinks to update
     */
    where?: ClickedLinkWhereInput
    /**
     * Limit how many ClickedLinks to update.
     */
    limit?: number
  }

  /**
   * ClickedLink updateManyAndReturn
   */
  export type ClickedLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * The data used to update ClickedLinks.
     */
    data: XOR<ClickedLinkUpdateManyMutationInput, ClickedLinkUncheckedUpdateManyInput>
    /**
     * Filter which ClickedLinks to update
     */
    where?: ClickedLinkWhereInput
    /**
     * Limit how many ClickedLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClickedLink upsert
   */
  export type ClickedLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the ClickedLink to update in case it exists.
     */
    where: ClickedLinkWhereUniqueInput
    /**
     * In case the ClickedLink found by the `where` argument doesn't exist, create a new ClickedLink with this data.
     */
    create: XOR<ClickedLinkCreateInput, ClickedLinkUncheckedCreateInput>
    /**
     * In case the ClickedLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClickedLinkUpdateInput, ClickedLinkUncheckedUpdateInput>
  }

  /**
   * ClickedLink delete
   */
  export type ClickedLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkInclude<ExtArgs> | null
    /**
     * Filter which ClickedLink to delete.
     */
    where: ClickedLinkWhereUniqueInput
  }

  /**
   * ClickedLink deleteMany
   */
  export type ClickedLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClickedLinks to delete
     */
    where?: ClickedLinkWhereInput
    /**
     * Limit how many ClickedLinks to delete.
     */
    limit?: number
  }

  /**
   * ClickedLink without action
   */
  export type ClickedLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkInclude<ExtArgs> | null
  }


  /**
   * Model NotificationEmailClickedLink
   */

  export type AggregateNotificationEmailClickedLink = {
    _count: NotificationEmailClickedLinkCountAggregateOutputType | null
    _min: NotificationEmailClickedLinkMinAggregateOutputType | null
    _max: NotificationEmailClickedLinkMaxAggregateOutputType | null
  }

  export type NotificationEmailClickedLinkMinAggregateOutputType = {
    id: string | null
    notificationEmailId: string | null
    url: string | null
    clickedAt: Date | null
    clickedBy: string | null
  }

  export type NotificationEmailClickedLinkMaxAggregateOutputType = {
    id: string | null
    notificationEmailId: string | null
    url: string | null
    clickedAt: Date | null
    clickedBy: string | null
  }

  export type NotificationEmailClickedLinkCountAggregateOutputType = {
    id: number
    notificationEmailId: number
    url: number
    clickedAt: number
    clickedBy: number
    _all: number
  }


  export type NotificationEmailClickedLinkMinAggregateInputType = {
    id?: true
    notificationEmailId?: true
    url?: true
    clickedAt?: true
    clickedBy?: true
  }

  export type NotificationEmailClickedLinkMaxAggregateInputType = {
    id?: true
    notificationEmailId?: true
    url?: true
    clickedAt?: true
    clickedBy?: true
  }

  export type NotificationEmailClickedLinkCountAggregateInputType = {
    id?: true
    notificationEmailId?: true
    url?: true
    clickedAt?: true
    clickedBy?: true
    _all?: true
  }

  export type NotificationEmailClickedLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationEmailClickedLink to aggregate.
     */
    where?: NotificationEmailClickedLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationEmailClickedLinks to fetch.
     */
    orderBy?: NotificationEmailClickedLinkOrderByWithRelationInput | NotificationEmailClickedLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationEmailClickedLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationEmailClickedLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationEmailClickedLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationEmailClickedLinks
    **/
    _count?: true | NotificationEmailClickedLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationEmailClickedLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationEmailClickedLinkMaxAggregateInputType
  }

  export type GetNotificationEmailClickedLinkAggregateType<T extends NotificationEmailClickedLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationEmailClickedLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationEmailClickedLink[P]>
      : GetScalarType<T[P], AggregateNotificationEmailClickedLink[P]>
  }




  export type NotificationEmailClickedLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationEmailClickedLinkWhereInput
    orderBy?: NotificationEmailClickedLinkOrderByWithAggregationInput | NotificationEmailClickedLinkOrderByWithAggregationInput[]
    by: NotificationEmailClickedLinkScalarFieldEnum[] | NotificationEmailClickedLinkScalarFieldEnum
    having?: NotificationEmailClickedLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationEmailClickedLinkCountAggregateInputType | true
    _min?: NotificationEmailClickedLinkMinAggregateInputType
    _max?: NotificationEmailClickedLinkMaxAggregateInputType
  }

  export type NotificationEmailClickedLinkGroupByOutputType = {
    id: string
    notificationEmailId: string | null
    url: string
    clickedAt: Date
    clickedBy: string | null
    _count: NotificationEmailClickedLinkCountAggregateOutputType | null
    _min: NotificationEmailClickedLinkMinAggregateOutputType | null
    _max: NotificationEmailClickedLinkMaxAggregateOutputType | null
  }

  type GetNotificationEmailClickedLinkGroupByPayload<T extends NotificationEmailClickedLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationEmailClickedLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationEmailClickedLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationEmailClickedLinkGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationEmailClickedLinkGroupByOutputType[P]>
        }
      >
    >


  export type NotificationEmailClickedLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationEmailId?: boolean
    url?: boolean
    clickedAt?: boolean
    clickedBy?: boolean
    notificationEmail?: boolean | NotificationEmailClickedLink$notificationEmailArgs<ExtArgs>
  }, ExtArgs["result"]["notificationEmailClickedLink"]>

  export type NotificationEmailClickedLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationEmailId?: boolean
    url?: boolean
    clickedAt?: boolean
    clickedBy?: boolean
    notificationEmail?: boolean | NotificationEmailClickedLink$notificationEmailArgs<ExtArgs>
  }, ExtArgs["result"]["notificationEmailClickedLink"]>

  export type NotificationEmailClickedLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationEmailId?: boolean
    url?: boolean
    clickedAt?: boolean
    clickedBy?: boolean
    notificationEmail?: boolean | NotificationEmailClickedLink$notificationEmailArgs<ExtArgs>
  }, ExtArgs["result"]["notificationEmailClickedLink"]>

  export type NotificationEmailClickedLinkSelectScalar = {
    id?: boolean
    notificationEmailId?: boolean
    url?: boolean
    clickedAt?: boolean
    clickedBy?: boolean
  }

  export type NotificationEmailClickedLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notificationEmailId" | "url" | "clickedAt" | "clickedBy", ExtArgs["result"]["notificationEmailClickedLink"]>
  export type NotificationEmailClickedLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificationEmail?: boolean | NotificationEmailClickedLink$notificationEmailArgs<ExtArgs>
  }
  export type NotificationEmailClickedLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificationEmail?: boolean | NotificationEmailClickedLink$notificationEmailArgs<ExtArgs>
  }
  export type NotificationEmailClickedLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificationEmail?: boolean | NotificationEmailClickedLink$notificationEmailArgs<ExtArgs>
  }

  export type $NotificationEmailClickedLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationEmailClickedLink"
    objects: {
      notificationEmail: Prisma.$EmailNotificationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      notificationEmailId: string | null
      url: string
      clickedAt: Date
      clickedBy: string | null
    }, ExtArgs["result"]["notificationEmailClickedLink"]>
    composites: {}
  }

  type NotificationEmailClickedLinkGetPayload<S extends boolean | null | undefined | NotificationEmailClickedLinkDefaultArgs> = $Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload, S>

  type NotificationEmailClickedLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationEmailClickedLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationEmailClickedLinkCountAggregateInputType | true
    }

  export interface NotificationEmailClickedLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationEmailClickedLink'], meta: { name: 'NotificationEmailClickedLink' } }
    /**
     * Find zero or one NotificationEmailClickedLink that matches the filter.
     * @param {NotificationEmailClickedLinkFindUniqueArgs} args - Arguments to find a NotificationEmailClickedLink
     * @example
     * // Get one NotificationEmailClickedLink
     * const notificationEmailClickedLink = await prisma.notificationEmailClickedLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationEmailClickedLinkFindUniqueArgs>(args: SelectSubset<T, NotificationEmailClickedLinkFindUniqueArgs<ExtArgs>>): Prisma__NotificationEmailClickedLinkClient<$Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationEmailClickedLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationEmailClickedLinkFindUniqueOrThrowArgs} args - Arguments to find a NotificationEmailClickedLink
     * @example
     * // Get one NotificationEmailClickedLink
     * const notificationEmailClickedLink = await prisma.notificationEmailClickedLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationEmailClickedLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationEmailClickedLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationEmailClickedLinkClient<$Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationEmailClickedLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEmailClickedLinkFindFirstArgs} args - Arguments to find a NotificationEmailClickedLink
     * @example
     * // Get one NotificationEmailClickedLink
     * const notificationEmailClickedLink = await prisma.notificationEmailClickedLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationEmailClickedLinkFindFirstArgs>(args?: SelectSubset<T, NotificationEmailClickedLinkFindFirstArgs<ExtArgs>>): Prisma__NotificationEmailClickedLinkClient<$Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationEmailClickedLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEmailClickedLinkFindFirstOrThrowArgs} args - Arguments to find a NotificationEmailClickedLink
     * @example
     * // Get one NotificationEmailClickedLink
     * const notificationEmailClickedLink = await prisma.notificationEmailClickedLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationEmailClickedLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationEmailClickedLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationEmailClickedLinkClient<$Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationEmailClickedLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEmailClickedLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationEmailClickedLinks
     * const notificationEmailClickedLinks = await prisma.notificationEmailClickedLink.findMany()
     * 
     * // Get first 10 NotificationEmailClickedLinks
     * const notificationEmailClickedLinks = await prisma.notificationEmailClickedLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationEmailClickedLinkWithIdOnly = await prisma.notificationEmailClickedLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationEmailClickedLinkFindManyArgs>(args?: SelectSubset<T, NotificationEmailClickedLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationEmailClickedLink.
     * @param {NotificationEmailClickedLinkCreateArgs} args - Arguments to create a NotificationEmailClickedLink.
     * @example
     * // Create one NotificationEmailClickedLink
     * const NotificationEmailClickedLink = await prisma.notificationEmailClickedLink.create({
     *   data: {
     *     // ... data to create a NotificationEmailClickedLink
     *   }
     * })
     * 
     */
    create<T extends NotificationEmailClickedLinkCreateArgs>(args: SelectSubset<T, NotificationEmailClickedLinkCreateArgs<ExtArgs>>): Prisma__NotificationEmailClickedLinkClient<$Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationEmailClickedLinks.
     * @param {NotificationEmailClickedLinkCreateManyArgs} args - Arguments to create many NotificationEmailClickedLinks.
     * @example
     * // Create many NotificationEmailClickedLinks
     * const notificationEmailClickedLink = await prisma.notificationEmailClickedLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationEmailClickedLinkCreateManyArgs>(args?: SelectSubset<T, NotificationEmailClickedLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationEmailClickedLinks and returns the data saved in the database.
     * @param {NotificationEmailClickedLinkCreateManyAndReturnArgs} args - Arguments to create many NotificationEmailClickedLinks.
     * @example
     * // Create many NotificationEmailClickedLinks
     * const notificationEmailClickedLink = await prisma.notificationEmailClickedLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationEmailClickedLinks and only return the `id`
     * const notificationEmailClickedLinkWithIdOnly = await prisma.notificationEmailClickedLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationEmailClickedLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationEmailClickedLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationEmailClickedLink.
     * @param {NotificationEmailClickedLinkDeleteArgs} args - Arguments to delete one NotificationEmailClickedLink.
     * @example
     * // Delete one NotificationEmailClickedLink
     * const NotificationEmailClickedLink = await prisma.notificationEmailClickedLink.delete({
     *   where: {
     *     // ... filter to delete one NotificationEmailClickedLink
     *   }
     * })
     * 
     */
    delete<T extends NotificationEmailClickedLinkDeleteArgs>(args: SelectSubset<T, NotificationEmailClickedLinkDeleteArgs<ExtArgs>>): Prisma__NotificationEmailClickedLinkClient<$Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationEmailClickedLink.
     * @param {NotificationEmailClickedLinkUpdateArgs} args - Arguments to update one NotificationEmailClickedLink.
     * @example
     * // Update one NotificationEmailClickedLink
     * const notificationEmailClickedLink = await prisma.notificationEmailClickedLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationEmailClickedLinkUpdateArgs>(args: SelectSubset<T, NotificationEmailClickedLinkUpdateArgs<ExtArgs>>): Prisma__NotificationEmailClickedLinkClient<$Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationEmailClickedLinks.
     * @param {NotificationEmailClickedLinkDeleteManyArgs} args - Arguments to filter NotificationEmailClickedLinks to delete.
     * @example
     * // Delete a few NotificationEmailClickedLinks
     * const { count } = await prisma.notificationEmailClickedLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationEmailClickedLinkDeleteManyArgs>(args?: SelectSubset<T, NotificationEmailClickedLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationEmailClickedLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEmailClickedLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationEmailClickedLinks
     * const notificationEmailClickedLink = await prisma.notificationEmailClickedLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationEmailClickedLinkUpdateManyArgs>(args: SelectSubset<T, NotificationEmailClickedLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationEmailClickedLinks and returns the data updated in the database.
     * @param {NotificationEmailClickedLinkUpdateManyAndReturnArgs} args - Arguments to update many NotificationEmailClickedLinks.
     * @example
     * // Update many NotificationEmailClickedLinks
     * const notificationEmailClickedLink = await prisma.notificationEmailClickedLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationEmailClickedLinks and only return the `id`
     * const notificationEmailClickedLinkWithIdOnly = await prisma.notificationEmailClickedLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationEmailClickedLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationEmailClickedLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationEmailClickedLink.
     * @param {NotificationEmailClickedLinkUpsertArgs} args - Arguments to update or create a NotificationEmailClickedLink.
     * @example
     * // Update or create a NotificationEmailClickedLink
     * const notificationEmailClickedLink = await prisma.notificationEmailClickedLink.upsert({
     *   create: {
     *     // ... data to create a NotificationEmailClickedLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationEmailClickedLink we want to update
     *   }
     * })
     */
    upsert<T extends NotificationEmailClickedLinkUpsertArgs>(args: SelectSubset<T, NotificationEmailClickedLinkUpsertArgs<ExtArgs>>): Prisma__NotificationEmailClickedLinkClient<$Result.GetResult<Prisma.$NotificationEmailClickedLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationEmailClickedLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEmailClickedLinkCountArgs} args - Arguments to filter NotificationEmailClickedLinks to count.
     * @example
     * // Count the number of NotificationEmailClickedLinks
     * const count = await prisma.notificationEmailClickedLink.count({
     *   where: {
     *     // ... the filter for the NotificationEmailClickedLinks we want to count
     *   }
     * })
    **/
    count<T extends NotificationEmailClickedLinkCountArgs>(
      args?: Subset<T, NotificationEmailClickedLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationEmailClickedLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationEmailClickedLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEmailClickedLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationEmailClickedLinkAggregateArgs>(args: Subset<T, NotificationEmailClickedLinkAggregateArgs>): Prisma.PrismaPromise<GetNotificationEmailClickedLinkAggregateType<T>>

    /**
     * Group by NotificationEmailClickedLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEmailClickedLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationEmailClickedLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationEmailClickedLinkGroupByArgs['orderBy'] }
        : { orderBy?: NotificationEmailClickedLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationEmailClickedLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationEmailClickedLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationEmailClickedLink model
   */
  readonly fields: NotificationEmailClickedLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationEmailClickedLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationEmailClickedLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notificationEmail<T extends NotificationEmailClickedLink$notificationEmailArgs<ExtArgs> = {}>(args?: Subset<T, NotificationEmailClickedLink$notificationEmailArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationEmailClickedLink model
   */
  interface NotificationEmailClickedLinkFieldRefs {
    readonly id: FieldRef<"NotificationEmailClickedLink", 'String'>
    readonly notificationEmailId: FieldRef<"NotificationEmailClickedLink", 'String'>
    readonly url: FieldRef<"NotificationEmailClickedLink", 'String'>
    readonly clickedAt: FieldRef<"NotificationEmailClickedLink", 'DateTime'>
    readonly clickedBy: FieldRef<"NotificationEmailClickedLink", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NotificationEmailClickedLink findUnique
   */
  export type NotificationEmailClickedLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkInclude<ExtArgs> | null
    /**
     * Filter, which NotificationEmailClickedLink to fetch.
     */
    where: NotificationEmailClickedLinkWhereUniqueInput
  }

  /**
   * NotificationEmailClickedLink findUniqueOrThrow
   */
  export type NotificationEmailClickedLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkInclude<ExtArgs> | null
    /**
     * Filter, which NotificationEmailClickedLink to fetch.
     */
    where: NotificationEmailClickedLinkWhereUniqueInput
  }

  /**
   * NotificationEmailClickedLink findFirst
   */
  export type NotificationEmailClickedLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkInclude<ExtArgs> | null
    /**
     * Filter, which NotificationEmailClickedLink to fetch.
     */
    where?: NotificationEmailClickedLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationEmailClickedLinks to fetch.
     */
    orderBy?: NotificationEmailClickedLinkOrderByWithRelationInput | NotificationEmailClickedLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationEmailClickedLinks.
     */
    cursor?: NotificationEmailClickedLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationEmailClickedLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationEmailClickedLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationEmailClickedLinks.
     */
    distinct?: NotificationEmailClickedLinkScalarFieldEnum | NotificationEmailClickedLinkScalarFieldEnum[]
  }

  /**
   * NotificationEmailClickedLink findFirstOrThrow
   */
  export type NotificationEmailClickedLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkInclude<ExtArgs> | null
    /**
     * Filter, which NotificationEmailClickedLink to fetch.
     */
    where?: NotificationEmailClickedLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationEmailClickedLinks to fetch.
     */
    orderBy?: NotificationEmailClickedLinkOrderByWithRelationInput | NotificationEmailClickedLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationEmailClickedLinks.
     */
    cursor?: NotificationEmailClickedLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationEmailClickedLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationEmailClickedLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationEmailClickedLinks.
     */
    distinct?: NotificationEmailClickedLinkScalarFieldEnum | NotificationEmailClickedLinkScalarFieldEnum[]
  }

  /**
   * NotificationEmailClickedLink findMany
   */
  export type NotificationEmailClickedLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkInclude<ExtArgs> | null
    /**
     * Filter, which NotificationEmailClickedLinks to fetch.
     */
    where?: NotificationEmailClickedLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationEmailClickedLinks to fetch.
     */
    orderBy?: NotificationEmailClickedLinkOrderByWithRelationInput | NotificationEmailClickedLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationEmailClickedLinks.
     */
    cursor?: NotificationEmailClickedLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationEmailClickedLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationEmailClickedLinks.
     */
    skip?: number
    distinct?: NotificationEmailClickedLinkScalarFieldEnum | NotificationEmailClickedLinkScalarFieldEnum[]
  }

  /**
   * NotificationEmailClickedLink create
   */
  export type NotificationEmailClickedLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationEmailClickedLink.
     */
    data: XOR<NotificationEmailClickedLinkCreateInput, NotificationEmailClickedLinkUncheckedCreateInput>
  }

  /**
   * NotificationEmailClickedLink createMany
   */
  export type NotificationEmailClickedLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationEmailClickedLinks.
     */
    data: NotificationEmailClickedLinkCreateManyInput | NotificationEmailClickedLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationEmailClickedLink createManyAndReturn
   */
  export type NotificationEmailClickedLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationEmailClickedLinks.
     */
    data: NotificationEmailClickedLinkCreateManyInput | NotificationEmailClickedLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationEmailClickedLink update
   */
  export type NotificationEmailClickedLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationEmailClickedLink.
     */
    data: XOR<NotificationEmailClickedLinkUpdateInput, NotificationEmailClickedLinkUncheckedUpdateInput>
    /**
     * Choose, which NotificationEmailClickedLink to update.
     */
    where: NotificationEmailClickedLinkWhereUniqueInput
  }

  /**
   * NotificationEmailClickedLink updateMany
   */
  export type NotificationEmailClickedLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationEmailClickedLinks.
     */
    data: XOR<NotificationEmailClickedLinkUpdateManyMutationInput, NotificationEmailClickedLinkUncheckedUpdateManyInput>
    /**
     * Filter which NotificationEmailClickedLinks to update
     */
    where?: NotificationEmailClickedLinkWhereInput
    /**
     * Limit how many NotificationEmailClickedLinks to update.
     */
    limit?: number
  }

  /**
   * NotificationEmailClickedLink updateManyAndReturn
   */
  export type NotificationEmailClickedLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * The data used to update NotificationEmailClickedLinks.
     */
    data: XOR<NotificationEmailClickedLinkUpdateManyMutationInput, NotificationEmailClickedLinkUncheckedUpdateManyInput>
    /**
     * Filter which NotificationEmailClickedLinks to update
     */
    where?: NotificationEmailClickedLinkWhereInput
    /**
     * Limit how many NotificationEmailClickedLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationEmailClickedLink upsert
   */
  export type NotificationEmailClickedLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationEmailClickedLink to update in case it exists.
     */
    where: NotificationEmailClickedLinkWhereUniqueInput
    /**
     * In case the NotificationEmailClickedLink found by the `where` argument doesn't exist, create a new NotificationEmailClickedLink with this data.
     */
    create: XOR<NotificationEmailClickedLinkCreateInput, NotificationEmailClickedLinkUncheckedCreateInput>
    /**
     * In case the NotificationEmailClickedLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationEmailClickedLinkUpdateInput, NotificationEmailClickedLinkUncheckedUpdateInput>
  }

  /**
   * NotificationEmailClickedLink delete
   */
  export type NotificationEmailClickedLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkInclude<ExtArgs> | null
    /**
     * Filter which NotificationEmailClickedLink to delete.
     */
    where: NotificationEmailClickedLinkWhereUniqueInput
  }

  /**
   * NotificationEmailClickedLink deleteMany
   */
  export type NotificationEmailClickedLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationEmailClickedLinks to delete
     */
    where?: NotificationEmailClickedLinkWhereInput
    /**
     * Limit how many NotificationEmailClickedLinks to delete.
     */
    limit?: number
  }

  /**
   * NotificationEmailClickedLink.notificationEmail
   */
  export type NotificationEmailClickedLink$notificationEmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    where?: EmailNotificationWhereInput
  }

  /**
   * NotificationEmailClickedLink without action
   */
  export type NotificationEmailClickedLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEmailClickedLink
     */
    select?: NotificationEmailClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationEmailClickedLink
     */
    omit?: NotificationEmailClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEmailClickedLinkInclude<ExtArgs> | null
  }


  /**
   * Model Email
   */

  export type AggregateEmail = {
    _count: EmailCountAggregateOutputType | null
    _avg: EmailAvgAggregateOutputType | null
    _sum: EmailSumAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  export type EmailAvgAggregateOutputType = {
    emailsSentCount: number | null
    recipients: number | null
    bounceCount: number | null
    openCount: number | null
    clickCount: number | null
  }

  export type EmailSumAggregateOutputType = {
    emailsSentCount: number | null
    recipients: number | null
    bounceCount: number | null
    openCount: number | null
    clickCount: number | null
  }

  export type EmailMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    emailSubject: string | null
    previewText: string | null
    builderMode: string | null
    templateUsed: string | null
    status: $Enums.EmailStatus | null
    emailType: $Enums.EmailType | null
    trackOpens: boolean | null
    trackClicks: boolean | null
    enableUnsubscribe: boolean | null
    scheduleDate: Date | null
    scheduleTime: string | null
    emailsSentCount: number | null
    recipients: number | null
    bounceCount: number | null
    openCount: number | null
    clickCount: number | null
    sentAt: Date | null
    lastOpened: Date | null
    lastClicked: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    newsLetterOwnerId: string | null
    campaignId: string | null
    messageId: string | null
  }

  export type EmailMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    emailSubject: string | null
    previewText: string | null
    builderMode: string | null
    templateUsed: string | null
    status: $Enums.EmailStatus | null
    emailType: $Enums.EmailType | null
    trackOpens: boolean | null
    trackClicks: boolean | null
    enableUnsubscribe: boolean | null
    scheduleDate: Date | null
    scheduleTime: string | null
    emailsSentCount: number | null
    recipients: number | null
    bounceCount: number | null
    openCount: number | null
    clickCount: number | null
    sentAt: Date | null
    lastOpened: Date | null
    lastClicked: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    newsLetterOwnerId: string | null
    campaignId: string | null
    messageId: string | null
  }

  export type EmailCountAggregateOutputType = {
    id: number
    title: number
    content: number
    emailSubject: number
    previewText: number
    builderMode: number
    builderData: number
    templateUsed: number
    status: number
    emailType: number
    trackOpens: number
    trackClicks: number
    enableUnsubscribe: number
    scheduleDate: number
    scheduleTime: number
    emailsSentCount: number
    recipients: number
    bounceCount: number
    openCount: number
    clickCount: number
    sentAt: number
    lastOpened: number
    lastClicked: number
    openedByIps: number
    openedByEmails: number
    clickedByIps: number
    clickedByEmails: number
    createdAt: number
    updatedAt: number
    userId: number
    newsLetterOwnerId: number
    campaignId: number
    messageId: number
    _all: number
  }


  export type EmailAvgAggregateInputType = {
    emailsSentCount?: true
    recipients?: true
    bounceCount?: true
    openCount?: true
    clickCount?: true
  }

  export type EmailSumAggregateInputType = {
    emailsSentCount?: true
    recipients?: true
    bounceCount?: true
    openCount?: true
    clickCount?: true
  }

  export type EmailMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    emailSubject?: true
    previewText?: true
    builderMode?: true
    templateUsed?: true
    status?: true
    emailType?: true
    trackOpens?: true
    trackClicks?: true
    enableUnsubscribe?: true
    scheduleDate?: true
    scheduleTime?: true
    emailsSentCount?: true
    recipients?: true
    bounceCount?: true
    openCount?: true
    clickCount?: true
    sentAt?: true
    lastOpened?: true
    lastClicked?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    newsLetterOwnerId?: true
    campaignId?: true
    messageId?: true
  }

  export type EmailMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    emailSubject?: true
    previewText?: true
    builderMode?: true
    templateUsed?: true
    status?: true
    emailType?: true
    trackOpens?: true
    trackClicks?: true
    enableUnsubscribe?: true
    scheduleDate?: true
    scheduleTime?: true
    emailsSentCount?: true
    recipients?: true
    bounceCount?: true
    openCount?: true
    clickCount?: true
    sentAt?: true
    lastOpened?: true
    lastClicked?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    newsLetterOwnerId?: true
    campaignId?: true
    messageId?: true
  }

  export type EmailCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    emailSubject?: true
    previewText?: true
    builderMode?: true
    builderData?: true
    templateUsed?: true
    status?: true
    emailType?: true
    trackOpens?: true
    trackClicks?: true
    enableUnsubscribe?: true
    scheduleDate?: true
    scheduleTime?: true
    emailsSentCount?: true
    recipients?: true
    bounceCount?: true
    openCount?: true
    clickCount?: true
    sentAt?: true
    lastOpened?: true
    lastClicked?: true
    openedByIps?: true
    openedByEmails?: true
    clickedByIps?: true
    clickedByEmails?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    newsLetterOwnerId?: true
    campaignId?: true
    messageId?: true
    _all?: true
  }

  export type EmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Email to aggregate.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emails
    **/
    _count?: true | EmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailMaxAggregateInputType
  }

  export type GetEmailAggregateType<T extends EmailAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail[P]>
      : GetScalarType<T[P], AggregateEmail[P]>
  }




  export type EmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithAggregationInput | EmailOrderByWithAggregationInput[]
    by: EmailScalarFieldEnum[] | EmailScalarFieldEnum
    having?: EmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCountAggregateInputType | true
    _avg?: EmailAvgAggregateInputType
    _sum?: EmailSumAggregateInputType
    _min?: EmailMinAggregateInputType
    _max?: EmailMaxAggregateInputType
  }

  export type EmailGroupByOutputType = {
    id: string
    title: string
    content: string
    emailSubject: string
    previewText: string | null
    builderMode: string
    builderData: JsonValue | null
    templateUsed: string | null
    status: $Enums.EmailStatus
    emailType: $Enums.EmailType
    trackOpens: boolean
    trackClicks: boolean
    enableUnsubscribe: boolean
    scheduleDate: Date | null
    scheduleTime: string | null
    emailsSentCount: number
    recipients: number
    bounceCount: number
    openCount: number
    clickCount: number
    sentAt: Date | null
    lastOpened: Date | null
    lastClicked: Date | null
    openedByIps: string[]
    openedByEmails: string[]
    clickedByIps: string[]
    clickedByEmails: string[]
    createdAt: Date
    updatedAt: Date
    userId: string
    newsLetterOwnerId: string
    campaignId: string | null
    messageId: string | null
    _count: EmailCountAggregateOutputType | null
    _avg: EmailAvgAggregateOutputType | null
    _sum: EmailSumAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  type GetEmailGroupByPayload<T extends EmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailGroupByOutputType[P]>
            : GetScalarType<T[P], EmailGroupByOutputType[P]>
        }
      >
    >


  export type EmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    emailSubject?: boolean
    previewText?: boolean
    builderMode?: boolean
    builderData?: boolean
    templateUsed?: boolean
    status?: boolean
    emailType?: boolean
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: boolean
    scheduleTime?: boolean
    emailsSentCount?: boolean
    recipients?: boolean
    bounceCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    sentAt?: boolean
    lastOpened?: boolean
    lastClicked?: boolean
    openedByIps?: boolean
    openedByEmails?: boolean
    clickedByIps?: boolean
    clickedByEmails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    newsLetterOwnerId?: boolean
    campaignId?: boolean
    messageId?: boolean
    elements?: boolean | Email$elementsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | Email$campaignArgs<ExtArgs>
    clickedLinks?: boolean | Email$clickedLinksArgs<ExtArgs>
    emailAttachments?: boolean | Email$emailAttachmentsArgs<ExtArgs>
    emailRecipients?: boolean | Email$emailRecipientsArgs<ExtArgs>
    template?: boolean | Email$templateArgs<ExtArgs>
    emailAnalytics?: boolean | Email$emailAnalyticsArgs<ExtArgs>
    _count?: boolean | EmailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>

  export type EmailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    emailSubject?: boolean
    previewText?: boolean
    builderMode?: boolean
    builderData?: boolean
    templateUsed?: boolean
    status?: boolean
    emailType?: boolean
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: boolean
    scheduleTime?: boolean
    emailsSentCount?: boolean
    recipients?: boolean
    bounceCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    sentAt?: boolean
    lastOpened?: boolean
    lastClicked?: boolean
    openedByIps?: boolean
    openedByEmails?: boolean
    clickedByIps?: boolean
    clickedByEmails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    newsLetterOwnerId?: boolean
    campaignId?: boolean
    messageId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | Email$campaignArgs<ExtArgs>
    template?: boolean | Email$templateArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>

  export type EmailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    emailSubject?: boolean
    previewText?: boolean
    builderMode?: boolean
    builderData?: boolean
    templateUsed?: boolean
    status?: boolean
    emailType?: boolean
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: boolean
    scheduleTime?: boolean
    emailsSentCount?: boolean
    recipients?: boolean
    bounceCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    sentAt?: boolean
    lastOpened?: boolean
    lastClicked?: boolean
    openedByIps?: boolean
    openedByEmails?: boolean
    clickedByIps?: boolean
    clickedByEmails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    newsLetterOwnerId?: boolean
    campaignId?: boolean
    messageId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | Email$campaignArgs<ExtArgs>
    template?: boolean | Email$templateArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>

  export type EmailSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    emailSubject?: boolean
    previewText?: boolean
    builderMode?: boolean
    builderData?: boolean
    templateUsed?: boolean
    status?: boolean
    emailType?: boolean
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: boolean
    scheduleTime?: boolean
    emailsSentCount?: boolean
    recipients?: boolean
    bounceCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    sentAt?: boolean
    lastOpened?: boolean
    lastClicked?: boolean
    openedByIps?: boolean
    openedByEmails?: boolean
    clickedByIps?: boolean
    clickedByEmails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    newsLetterOwnerId?: boolean
    campaignId?: boolean
    messageId?: boolean
  }

  export type EmailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "emailSubject" | "previewText" | "builderMode" | "builderData" | "templateUsed" | "status" | "emailType" | "trackOpens" | "trackClicks" | "enableUnsubscribe" | "scheduleDate" | "scheduleTime" | "emailsSentCount" | "recipients" | "bounceCount" | "openCount" | "clickCount" | "sentAt" | "lastOpened" | "lastClicked" | "openedByIps" | "openedByEmails" | "clickedByIps" | "clickedByEmails" | "createdAt" | "updatedAt" | "userId" | "newsLetterOwnerId" | "campaignId" | "messageId", ExtArgs["result"]["email"]>
  export type EmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    elements?: boolean | Email$elementsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | Email$campaignArgs<ExtArgs>
    clickedLinks?: boolean | Email$clickedLinksArgs<ExtArgs>
    emailAttachments?: boolean | Email$emailAttachmentsArgs<ExtArgs>
    emailRecipients?: boolean | Email$emailRecipientsArgs<ExtArgs>
    template?: boolean | Email$templateArgs<ExtArgs>
    emailAnalytics?: boolean | Email$emailAnalyticsArgs<ExtArgs>
    _count?: boolean | EmailCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | Email$campaignArgs<ExtArgs>
    template?: boolean | Email$templateArgs<ExtArgs>
  }
  export type EmailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | Email$campaignArgs<ExtArgs>
    template?: boolean | Email$templateArgs<ExtArgs>
  }

  export type $EmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Email"
    objects: {
      elements: Prisma.$EmailElementPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs> | null
      clickedLinks: Prisma.$ClickedLinkPayload<ExtArgs>[]
      emailAttachments: Prisma.$EmailAttachmentPayload<ExtArgs>[]
      emailRecipients: Prisma.$EmailRecipientPayload<ExtArgs>[]
      template: Prisma.$EmailTemplatePayload<ExtArgs> | null
      emailAnalytics: Prisma.$EmailAnalyticsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      emailSubject: string
      previewText: string | null
      builderMode: string
      builderData: Prisma.JsonValue | null
      templateUsed: string | null
      status: $Enums.EmailStatus
      emailType: $Enums.EmailType
      trackOpens: boolean
      trackClicks: boolean
      enableUnsubscribe: boolean
      scheduleDate: Date | null
      scheduleTime: string | null
      emailsSentCount: number
      recipients: number
      bounceCount: number
      openCount: number
      clickCount: number
      sentAt: Date | null
      lastOpened: Date | null
      lastClicked: Date | null
      openedByIps: string[]
      openedByEmails: string[]
      clickedByIps: string[]
      clickedByEmails: string[]
      createdAt: Date
      updatedAt: Date
      userId: string
      newsLetterOwnerId: string
      campaignId: string | null
      messageId: string | null
    }, ExtArgs["result"]["email"]>
    composites: {}
  }

  type EmailGetPayload<S extends boolean | null | undefined | EmailDefaultArgs> = $Result.GetResult<Prisma.$EmailPayload, S>

  type EmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailCountAggregateInputType | true
    }

  export interface EmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Email'], meta: { name: 'Email' } }
    /**
     * Find zero or one Email that matches the filter.
     * @param {EmailFindUniqueArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailFindUniqueArgs>(args: SelectSubset<T, EmailFindUniqueArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Email that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailFindUniqueOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailFindFirstArgs>(args?: SelectSubset<T, EmailFindFirstArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emails
     * const emails = await prisma.email.findMany()
     * 
     * // Get first 10 Emails
     * const emails = await prisma.email.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailWithIdOnly = await prisma.email.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailFindManyArgs>(args?: SelectSubset<T, EmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Email.
     * @param {EmailCreateArgs} args - Arguments to create a Email.
     * @example
     * // Create one Email
     * const Email = await prisma.email.create({
     *   data: {
     *     // ... data to create a Email
     *   }
     * })
     * 
     */
    create<T extends EmailCreateArgs>(args: SelectSubset<T, EmailCreateArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emails.
     * @param {EmailCreateManyArgs} args - Arguments to create many Emails.
     * @example
     * // Create many Emails
     * const email = await prisma.email.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailCreateManyArgs>(args?: SelectSubset<T, EmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Emails and returns the data saved in the database.
     * @param {EmailCreateManyAndReturnArgs} args - Arguments to create many Emails.
     * @example
     * // Create many Emails
     * const email = await prisma.email.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Emails and only return the `id`
     * const emailWithIdOnly = await prisma.email.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Email.
     * @param {EmailDeleteArgs} args - Arguments to delete one Email.
     * @example
     * // Delete one Email
     * const Email = await prisma.email.delete({
     *   where: {
     *     // ... filter to delete one Email
     *   }
     * })
     * 
     */
    delete<T extends EmailDeleteArgs>(args: SelectSubset<T, EmailDeleteArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Email.
     * @param {EmailUpdateArgs} args - Arguments to update one Email.
     * @example
     * // Update one Email
     * const email = await prisma.email.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailUpdateArgs>(args: SelectSubset<T, EmailUpdateArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emails.
     * @param {EmailDeleteManyArgs} args - Arguments to filter Emails to delete.
     * @example
     * // Delete a few Emails
     * const { count } = await prisma.email.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailDeleteManyArgs>(args?: SelectSubset<T, EmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailUpdateManyArgs>(args: SelectSubset<T, EmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails and returns the data updated in the database.
     * @param {EmailUpdateManyAndReturnArgs} args - Arguments to update many Emails.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Emails and only return the `id`
     * const emailWithIdOnly = await prisma.email.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Email.
     * @param {EmailUpsertArgs} args - Arguments to update or create a Email.
     * @example
     * // Update or create a Email
     * const email = await prisma.email.upsert({
     *   create: {
     *     // ... data to create a Email
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email we want to update
     *   }
     * })
     */
    upsert<T extends EmailUpsertArgs>(args: SelectSubset<T, EmailUpsertArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCountArgs} args - Arguments to filter Emails to count.
     * @example
     * // Count the number of Emails
     * const count = await prisma.email.count({
     *   where: {
     *     // ... the filter for the Emails we want to count
     *   }
     * })
    **/
    count<T extends EmailCountArgs>(
      args?: Subset<T, EmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAggregateArgs>(args: Subset<T, EmailAggregateArgs>): Prisma.PrismaPromise<GetEmailAggregateType<T>>

    /**
     * Group by Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailGroupByArgs['orderBy'] }
        : { orderBy?: EmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Email model
   */
  readonly fields: EmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Email.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    elements<T extends Email$elementsArgs<ExtArgs> = {}>(args?: Subset<T, Email$elementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends Email$campaignArgs<ExtArgs> = {}>(args?: Subset<T, Email$campaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clickedLinks<T extends Email$clickedLinksArgs<ExtArgs> = {}>(args?: Subset<T, Email$clickedLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClickedLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailAttachments<T extends Email$emailAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Email$emailAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailRecipients<T extends Email$emailRecipientsArgs<ExtArgs> = {}>(args?: Subset<T, Email$emailRecipientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    template<T extends Email$templateArgs<ExtArgs> = {}>(args?: Subset<T, Email$templateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emailAnalytics<T extends Email$emailAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, Email$emailAnalyticsArgs<ExtArgs>>): Prisma__EmailAnalyticsClient<$Result.GetResult<Prisma.$EmailAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Email model
   */
  interface EmailFieldRefs {
    readonly id: FieldRef<"Email", 'String'>
    readonly title: FieldRef<"Email", 'String'>
    readonly content: FieldRef<"Email", 'String'>
    readonly emailSubject: FieldRef<"Email", 'String'>
    readonly previewText: FieldRef<"Email", 'String'>
    readonly builderMode: FieldRef<"Email", 'String'>
    readonly builderData: FieldRef<"Email", 'Json'>
    readonly templateUsed: FieldRef<"Email", 'String'>
    readonly status: FieldRef<"Email", 'EmailStatus'>
    readonly emailType: FieldRef<"Email", 'EmailType'>
    readonly trackOpens: FieldRef<"Email", 'Boolean'>
    readonly trackClicks: FieldRef<"Email", 'Boolean'>
    readonly enableUnsubscribe: FieldRef<"Email", 'Boolean'>
    readonly scheduleDate: FieldRef<"Email", 'DateTime'>
    readonly scheduleTime: FieldRef<"Email", 'String'>
    readonly emailsSentCount: FieldRef<"Email", 'Int'>
    readonly recipients: FieldRef<"Email", 'Int'>
    readonly bounceCount: FieldRef<"Email", 'Int'>
    readonly openCount: FieldRef<"Email", 'Int'>
    readonly clickCount: FieldRef<"Email", 'Int'>
    readonly sentAt: FieldRef<"Email", 'DateTime'>
    readonly lastOpened: FieldRef<"Email", 'DateTime'>
    readonly lastClicked: FieldRef<"Email", 'DateTime'>
    readonly openedByIps: FieldRef<"Email", 'String[]'>
    readonly openedByEmails: FieldRef<"Email", 'String[]'>
    readonly clickedByIps: FieldRef<"Email", 'String[]'>
    readonly clickedByEmails: FieldRef<"Email", 'String[]'>
    readonly createdAt: FieldRef<"Email", 'DateTime'>
    readonly updatedAt: FieldRef<"Email", 'DateTime'>
    readonly userId: FieldRef<"Email", 'String'>
    readonly newsLetterOwnerId: FieldRef<"Email", 'String'>
    readonly campaignId: FieldRef<"Email", 'String'>
    readonly messageId: FieldRef<"Email", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Email findUnique
   */
  export type EmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email findUniqueOrThrow
   */
  export type EmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email findFirst
   */
  export type EmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Email findFirstOrThrow
   */
  export type EmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Email findMany
   */
  export type EmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Emails to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Email create
   */
  export type EmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to create a Email.
     */
    data: XOR<EmailCreateInput, EmailUncheckedCreateInput>
  }

  /**
   * Email createMany
   */
  export type EmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emails.
     */
    data: EmailCreateManyInput | EmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Email createManyAndReturn
   */
  export type EmailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * The data used to create many Emails.
     */
    data: EmailCreateManyInput | EmailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Email update
   */
  export type EmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to update a Email.
     */
    data: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
    /**
     * Choose, which Email to update.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email updateMany
   */
  export type EmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emails.
     */
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyInput>
    /**
     * Filter which Emails to update
     */
    where?: EmailWhereInput
    /**
     * Limit how many Emails to update.
     */
    limit?: number
  }

  /**
   * Email updateManyAndReturn
   */
  export type EmailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * The data used to update Emails.
     */
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyInput>
    /**
     * Filter which Emails to update
     */
    where?: EmailWhereInput
    /**
     * Limit how many Emails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Email upsert
   */
  export type EmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The filter to search for the Email to update in case it exists.
     */
    where: EmailWhereUniqueInput
    /**
     * In case the Email found by the `where` argument doesn't exist, create a new Email with this data.
     */
    create: XOR<EmailCreateInput, EmailUncheckedCreateInput>
    /**
     * In case the Email was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
  }

  /**
   * Email delete
   */
  export type EmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter which Email to delete.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email deleteMany
   */
  export type EmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emails to delete
     */
    where?: EmailWhereInput
    /**
     * Limit how many Emails to delete.
     */
    limit?: number
  }

  /**
   * Email.elements
   */
  export type Email$elementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementInclude<ExtArgs> | null
    where?: EmailElementWhereInput
    orderBy?: EmailElementOrderByWithRelationInput | EmailElementOrderByWithRelationInput[]
    cursor?: EmailElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailElementScalarFieldEnum | EmailElementScalarFieldEnum[]
  }

  /**
   * Email.campaign
   */
  export type Email$campaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * Email.clickedLinks
   */
  export type Email$clickedLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClickedLink
     */
    select?: ClickedLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClickedLink
     */
    omit?: ClickedLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickedLinkInclude<ExtArgs> | null
    where?: ClickedLinkWhereInput
    orderBy?: ClickedLinkOrderByWithRelationInput | ClickedLinkOrderByWithRelationInput[]
    cursor?: ClickedLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClickedLinkScalarFieldEnum | ClickedLinkScalarFieldEnum[]
  }

  /**
   * Email.emailAttachments
   */
  export type Email$emailAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    where?: EmailAttachmentWhereInput
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    cursor?: EmailAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAttachmentScalarFieldEnum | EmailAttachmentScalarFieldEnum[]
  }

  /**
   * Email.emailRecipients
   */
  export type Email$emailRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientInclude<ExtArgs> | null
    where?: EmailRecipientWhereInput
    orderBy?: EmailRecipientOrderByWithRelationInput | EmailRecipientOrderByWithRelationInput[]
    cursor?: EmailRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailRecipientScalarFieldEnum | EmailRecipientScalarFieldEnum[]
  }

  /**
   * Email.template
   */
  export type Email$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * Email.emailAnalytics
   */
  export type Email$emailAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsInclude<ExtArgs> | null
    where?: EmailAnalyticsWhereInput
  }

  /**
   * Email without action
   */
  export type EmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
  }


  /**
   * Model EmailElement
   */

  export type AggregateEmailElement = {
    _count: EmailElementCountAggregateOutputType | null
    _avg: EmailElementAvgAggregateOutputType | null
    _sum: EmailElementSumAggregateOutputType | null
    _min: EmailElementMinAggregateOutputType | null
    _max: EmailElementMaxAggregateOutputType | null
  }

  export type EmailElementAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type EmailElementSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type EmailElementMinAggregateOutputType = {
    id: string | null
    emailId: string | null
    elementId: string | null
    type: $Enums.ElementType | null
    content: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailElementMaxAggregateOutputType = {
    id: string | null
    emailId: string | null
    elementId: string | null
    type: $Enums.ElementType | null
    content: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailElementCountAggregateOutputType = {
    id: number
    emailId: number
    elementId: number
    type: number
    content: number
    properties: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailElementAvgAggregateInputType = {
    sortOrder?: true
  }

  export type EmailElementSumAggregateInputType = {
    sortOrder?: true
  }

  export type EmailElementMinAggregateInputType = {
    id?: true
    emailId?: true
    elementId?: true
    type?: true
    content?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailElementMaxAggregateInputType = {
    id?: true
    emailId?: true
    elementId?: true
    type?: true
    content?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailElementCountAggregateInputType = {
    id?: true
    emailId?: true
    elementId?: true
    type?: true
    content?: true
    properties?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailElementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailElement to aggregate.
     */
    where?: EmailElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailElements to fetch.
     */
    orderBy?: EmailElementOrderByWithRelationInput | EmailElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailElements
    **/
    _count?: true | EmailElementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailElementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailElementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailElementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailElementMaxAggregateInputType
  }

  export type GetEmailElementAggregateType<T extends EmailElementAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailElement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailElement[P]>
      : GetScalarType<T[P], AggregateEmailElement[P]>
  }




  export type EmailElementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailElementWhereInput
    orderBy?: EmailElementOrderByWithAggregationInput | EmailElementOrderByWithAggregationInput[]
    by: EmailElementScalarFieldEnum[] | EmailElementScalarFieldEnum
    having?: EmailElementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailElementCountAggregateInputType | true
    _avg?: EmailElementAvgAggregateInputType
    _sum?: EmailElementSumAggregateInputType
    _min?: EmailElementMinAggregateInputType
    _max?: EmailElementMaxAggregateInputType
  }

  export type EmailElementGroupByOutputType = {
    id: string
    emailId: string
    elementId: string
    type: $Enums.ElementType
    content: string | null
    properties: JsonValue
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: EmailElementCountAggregateOutputType | null
    _avg: EmailElementAvgAggregateOutputType | null
    _sum: EmailElementSumAggregateOutputType | null
    _min: EmailElementMinAggregateOutputType | null
    _max: EmailElementMaxAggregateOutputType | null
  }

  type GetEmailElementGroupByPayload<T extends EmailElementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailElementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailElementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailElementGroupByOutputType[P]>
            : GetScalarType<T[P], EmailElementGroupByOutputType[P]>
        }
      >
    >


  export type EmailElementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    elementId?: boolean
    type?: boolean
    content?: boolean
    properties?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailElement"]>

  export type EmailElementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    elementId?: boolean
    type?: boolean
    content?: boolean
    properties?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailElement"]>

  export type EmailElementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    elementId?: boolean
    type?: boolean
    content?: boolean
    properties?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailElement"]>

  export type EmailElementSelectScalar = {
    id?: boolean
    emailId?: boolean
    elementId?: boolean
    type?: boolean
    content?: boolean
    properties?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailElementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emailId" | "elementId" | "type" | "content" | "properties" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["emailElement"]>
  export type EmailElementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type EmailElementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type EmailElementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }

  export type $EmailElementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailElement"
    objects: {
      email: Prisma.$EmailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emailId: string
      elementId: string
      type: $Enums.ElementType
      content: string | null
      properties: Prisma.JsonValue
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailElement"]>
    composites: {}
  }

  type EmailElementGetPayload<S extends boolean | null | undefined | EmailElementDefaultArgs> = $Result.GetResult<Prisma.$EmailElementPayload, S>

  type EmailElementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailElementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailElementCountAggregateInputType | true
    }

  export interface EmailElementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailElement'], meta: { name: 'EmailElement' } }
    /**
     * Find zero or one EmailElement that matches the filter.
     * @param {EmailElementFindUniqueArgs} args - Arguments to find a EmailElement
     * @example
     * // Get one EmailElement
     * const emailElement = await prisma.emailElement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailElementFindUniqueArgs>(args: SelectSubset<T, EmailElementFindUniqueArgs<ExtArgs>>): Prisma__EmailElementClient<$Result.GetResult<Prisma.$EmailElementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailElement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailElementFindUniqueOrThrowArgs} args - Arguments to find a EmailElement
     * @example
     * // Get one EmailElement
     * const emailElement = await prisma.emailElement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailElementFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailElementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailElementClient<$Result.GetResult<Prisma.$EmailElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailElement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailElementFindFirstArgs} args - Arguments to find a EmailElement
     * @example
     * // Get one EmailElement
     * const emailElement = await prisma.emailElement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailElementFindFirstArgs>(args?: SelectSubset<T, EmailElementFindFirstArgs<ExtArgs>>): Prisma__EmailElementClient<$Result.GetResult<Prisma.$EmailElementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailElement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailElementFindFirstOrThrowArgs} args - Arguments to find a EmailElement
     * @example
     * // Get one EmailElement
     * const emailElement = await prisma.emailElement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailElementFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailElementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailElementClient<$Result.GetResult<Prisma.$EmailElementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailElements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailElementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailElements
     * const emailElements = await prisma.emailElement.findMany()
     * 
     * // Get first 10 EmailElements
     * const emailElements = await prisma.emailElement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailElementWithIdOnly = await prisma.emailElement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailElementFindManyArgs>(args?: SelectSubset<T, EmailElementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailElement.
     * @param {EmailElementCreateArgs} args - Arguments to create a EmailElement.
     * @example
     * // Create one EmailElement
     * const EmailElement = await prisma.emailElement.create({
     *   data: {
     *     // ... data to create a EmailElement
     *   }
     * })
     * 
     */
    create<T extends EmailElementCreateArgs>(args: SelectSubset<T, EmailElementCreateArgs<ExtArgs>>): Prisma__EmailElementClient<$Result.GetResult<Prisma.$EmailElementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailElements.
     * @param {EmailElementCreateManyArgs} args - Arguments to create many EmailElements.
     * @example
     * // Create many EmailElements
     * const emailElement = await prisma.emailElement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailElementCreateManyArgs>(args?: SelectSubset<T, EmailElementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailElements and returns the data saved in the database.
     * @param {EmailElementCreateManyAndReturnArgs} args - Arguments to create many EmailElements.
     * @example
     * // Create many EmailElements
     * const emailElement = await prisma.emailElement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailElements and only return the `id`
     * const emailElementWithIdOnly = await prisma.emailElement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailElementCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailElementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailElementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailElement.
     * @param {EmailElementDeleteArgs} args - Arguments to delete one EmailElement.
     * @example
     * // Delete one EmailElement
     * const EmailElement = await prisma.emailElement.delete({
     *   where: {
     *     // ... filter to delete one EmailElement
     *   }
     * })
     * 
     */
    delete<T extends EmailElementDeleteArgs>(args: SelectSubset<T, EmailElementDeleteArgs<ExtArgs>>): Prisma__EmailElementClient<$Result.GetResult<Prisma.$EmailElementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailElement.
     * @param {EmailElementUpdateArgs} args - Arguments to update one EmailElement.
     * @example
     * // Update one EmailElement
     * const emailElement = await prisma.emailElement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailElementUpdateArgs>(args: SelectSubset<T, EmailElementUpdateArgs<ExtArgs>>): Prisma__EmailElementClient<$Result.GetResult<Prisma.$EmailElementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailElements.
     * @param {EmailElementDeleteManyArgs} args - Arguments to filter EmailElements to delete.
     * @example
     * // Delete a few EmailElements
     * const { count } = await prisma.emailElement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailElementDeleteManyArgs>(args?: SelectSubset<T, EmailElementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailElementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailElements
     * const emailElement = await prisma.emailElement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailElementUpdateManyArgs>(args: SelectSubset<T, EmailElementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailElements and returns the data updated in the database.
     * @param {EmailElementUpdateManyAndReturnArgs} args - Arguments to update many EmailElements.
     * @example
     * // Update many EmailElements
     * const emailElement = await prisma.emailElement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailElements and only return the `id`
     * const emailElementWithIdOnly = await prisma.emailElement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailElementUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailElementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailElementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailElement.
     * @param {EmailElementUpsertArgs} args - Arguments to update or create a EmailElement.
     * @example
     * // Update or create a EmailElement
     * const emailElement = await prisma.emailElement.upsert({
     *   create: {
     *     // ... data to create a EmailElement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailElement we want to update
     *   }
     * })
     */
    upsert<T extends EmailElementUpsertArgs>(args: SelectSubset<T, EmailElementUpsertArgs<ExtArgs>>): Prisma__EmailElementClient<$Result.GetResult<Prisma.$EmailElementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailElementCountArgs} args - Arguments to filter EmailElements to count.
     * @example
     * // Count the number of EmailElements
     * const count = await prisma.emailElement.count({
     *   where: {
     *     // ... the filter for the EmailElements we want to count
     *   }
     * })
    **/
    count<T extends EmailElementCountArgs>(
      args?: Subset<T, EmailElementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailElementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailElementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailElementAggregateArgs>(args: Subset<T, EmailElementAggregateArgs>): Prisma.PrismaPromise<GetEmailElementAggregateType<T>>

    /**
     * Group by EmailElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailElementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailElementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailElementGroupByArgs['orderBy'] }
        : { orderBy?: EmailElementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailElementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailElementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailElement model
   */
  readonly fields: EmailElementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailElement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailElementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email<T extends EmailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDefaultArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailElement model
   */
  interface EmailElementFieldRefs {
    readonly id: FieldRef<"EmailElement", 'String'>
    readonly emailId: FieldRef<"EmailElement", 'String'>
    readonly elementId: FieldRef<"EmailElement", 'String'>
    readonly type: FieldRef<"EmailElement", 'ElementType'>
    readonly content: FieldRef<"EmailElement", 'String'>
    readonly properties: FieldRef<"EmailElement", 'Json'>
    readonly sortOrder: FieldRef<"EmailElement", 'Int'>
    readonly createdAt: FieldRef<"EmailElement", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailElement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailElement findUnique
   */
  export type EmailElementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementInclude<ExtArgs> | null
    /**
     * Filter, which EmailElement to fetch.
     */
    where: EmailElementWhereUniqueInput
  }

  /**
   * EmailElement findUniqueOrThrow
   */
  export type EmailElementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementInclude<ExtArgs> | null
    /**
     * Filter, which EmailElement to fetch.
     */
    where: EmailElementWhereUniqueInput
  }

  /**
   * EmailElement findFirst
   */
  export type EmailElementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementInclude<ExtArgs> | null
    /**
     * Filter, which EmailElement to fetch.
     */
    where?: EmailElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailElements to fetch.
     */
    orderBy?: EmailElementOrderByWithRelationInput | EmailElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailElements.
     */
    cursor?: EmailElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailElements.
     */
    distinct?: EmailElementScalarFieldEnum | EmailElementScalarFieldEnum[]
  }

  /**
   * EmailElement findFirstOrThrow
   */
  export type EmailElementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementInclude<ExtArgs> | null
    /**
     * Filter, which EmailElement to fetch.
     */
    where?: EmailElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailElements to fetch.
     */
    orderBy?: EmailElementOrderByWithRelationInput | EmailElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailElements.
     */
    cursor?: EmailElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailElements.
     */
    distinct?: EmailElementScalarFieldEnum | EmailElementScalarFieldEnum[]
  }

  /**
   * EmailElement findMany
   */
  export type EmailElementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementInclude<ExtArgs> | null
    /**
     * Filter, which EmailElements to fetch.
     */
    where?: EmailElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailElements to fetch.
     */
    orderBy?: EmailElementOrderByWithRelationInput | EmailElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailElements.
     */
    cursor?: EmailElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailElements.
     */
    skip?: number
    distinct?: EmailElementScalarFieldEnum | EmailElementScalarFieldEnum[]
  }

  /**
   * EmailElement create
   */
  export type EmailElementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailElement.
     */
    data: XOR<EmailElementCreateInput, EmailElementUncheckedCreateInput>
  }

  /**
   * EmailElement createMany
   */
  export type EmailElementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailElements.
     */
    data: EmailElementCreateManyInput | EmailElementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailElement createManyAndReturn
   */
  export type EmailElementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * The data used to create many EmailElements.
     */
    data: EmailElementCreateManyInput | EmailElementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailElement update
   */
  export type EmailElementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailElement.
     */
    data: XOR<EmailElementUpdateInput, EmailElementUncheckedUpdateInput>
    /**
     * Choose, which EmailElement to update.
     */
    where: EmailElementWhereUniqueInput
  }

  /**
   * EmailElement updateMany
   */
  export type EmailElementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailElements.
     */
    data: XOR<EmailElementUpdateManyMutationInput, EmailElementUncheckedUpdateManyInput>
    /**
     * Filter which EmailElements to update
     */
    where?: EmailElementWhereInput
    /**
     * Limit how many EmailElements to update.
     */
    limit?: number
  }

  /**
   * EmailElement updateManyAndReturn
   */
  export type EmailElementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * The data used to update EmailElements.
     */
    data: XOR<EmailElementUpdateManyMutationInput, EmailElementUncheckedUpdateManyInput>
    /**
     * Filter which EmailElements to update
     */
    where?: EmailElementWhereInput
    /**
     * Limit how many EmailElements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailElement upsert
   */
  export type EmailElementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailElement to update in case it exists.
     */
    where: EmailElementWhereUniqueInput
    /**
     * In case the EmailElement found by the `where` argument doesn't exist, create a new EmailElement with this data.
     */
    create: XOR<EmailElementCreateInput, EmailElementUncheckedCreateInput>
    /**
     * In case the EmailElement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailElementUpdateInput, EmailElementUncheckedUpdateInput>
  }

  /**
   * EmailElement delete
   */
  export type EmailElementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementInclude<ExtArgs> | null
    /**
     * Filter which EmailElement to delete.
     */
    where: EmailElementWhereUniqueInput
  }

  /**
   * EmailElement deleteMany
   */
  export type EmailElementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailElements to delete
     */
    where?: EmailElementWhereInput
    /**
     * Limit how many EmailElements to delete.
     */
    limit?: number
  }

  /**
   * EmailElement without action
   */
  export type EmailElementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailElement
     */
    select?: EmailElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailElement
     */
    omit?: EmailElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailElementInclude<ExtArgs> | null
  }


  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _avg: EmailTemplateAvgAggregateOutputType | null
    _sum: EmailTemplateSumAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type EmailTemplateSumAggregateOutputType = {
    usageCount: number | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    thumbnail: string | null
    category: string | null
    subject: string | null
    isPublic: boolean | null
    isFeatured: boolean | null
    usageCount: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    thumbnail: string | null
    category: string | null
    subject: string | null
    isPublic: boolean | null
    isFeatured: boolean | null
    usageCount: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    thumbnail: number
    category: number
    tags: number
    elements: number
    subject: number
    isPublic: number
    isFeatured: number
    usageCount: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTemplateAvgAggregateInputType = {
    usageCount?: true
  }

  export type EmailTemplateSumAggregateInputType = {
    usageCount?: true
  }

  export type EmailTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    thumbnail?: true
    category?: true
    subject?: true
    isPublic?: true
    isFeatured?: true
    usageCount?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    thumbnail?: true
    category?: true
    subject?: true
    isPublic?: true
    isFeatured?: true
    usageCount?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    thumbnail?: true
    category?: true
    tags?: true
    elements?: true
    subject?: true
    isPublic?: true
    isFeatured?: true
    usageCount?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _avg?: EmailTemplateAvgAggregateInputType
    _sum?: EmailTemplateSumAggregateInputType
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    thumbnail: string | null
    category: string
    tags: string[]
    elements: JsonValue
    subject: string
    isPublic: boolean
    isFeatured: boolean
    usageCount: number
    userId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmailTemplateCountAggregateOutputType | null
    _avg: EmailTemplateAvgAggregateOutputType | null
    _sum: EmailTemplateSumAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    thumbnail?: boolean
    category?: boolean
    tags?: boolean
    elements?: boolean
    subject?: boolean
    isPublic?: boolean
    isFeatured?: boolean
    usageCount?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | EmailTemplate$userArgs<ExtArgs>
    emails?: boolean | EmailTemplate$emailsArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    thumbnail?: boolean
    category?: boolean
    tags?: boolean
    elements?: boolean
    subject?: boolean
    isPublic?: boolean
    isFeatured?: boolean
    usageCount?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | EmailTemplate$userArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    thumbnail?: boolean
    category?: boolean
    tags?: boolean
    elements?: boolean
    subject?: boolean
    isPublic?: boolean
    isFeatured?: boolean
    usageCount?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | EmailTemplate$userArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    thumbnail?: boolean
    category?: boolean
    tags?: boolean
    elements?: boolean
    subject?: boolean
    isPublic?: boolean
    isFeatured?: boolean
    usageCount?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "thumbnail" | "category" | "tags" | "elements" | "subject" | "isPublic" | "isFeatured" | "usageCount" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["emailTemplate"]>
  export type EmailTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | EmailTemplate$userArgs<ExtArgs>
    emails?: boolean | EmailTemplate$emailsArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | EmailTemplate$userArgs<ExtArgs>
  }
  export type EmailTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | EmailTemplate$userArgs<ExtArgs>
  }

  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      emails: Prisma.$EmailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      thumbnail: string | null
      category: string
      tags: string[]
      elements: Prisma.JsonValue
      subject: string
      isPublic: boolean
      isFeatured: boolean
      usageCount: number
      userId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }

  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTemplateFindUniqueArgs>(args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTemplateFindFirstArgs>(args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTemplateFindManyArgs>(args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
     */
    create<T extends EmailTemplateCreateArgs>(args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTemplateCreateManyArgs>(args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends EmailTemplateDeleteArgs>(args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTemplateUpdateArgs>(args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTemplateDeleteManyArgs>(args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTemplateUpdateManyArgs>(args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates and returns the data updated in the database.
     * @param {EmailTemplateUpdateManyAndReturnArgs} args - Arguments to update many EmailTemplates.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EmailTemplateUpsertArgs>(args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends EmailTemplate$userArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emails<T extends EmailTemplate$emailsArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTemplate model
   */
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly description: FieldRef<"EmailTemplate", 'String'>
    readonly thumbnail: FieldRef<"EmailTemplate", 'String'>
    readonly category: FieldRef<"EmailTemplate", 'String'>
    readonly tags: FieldRef<"EmailTemplate", 'String[]'>
    readonly elements: FieldRef<"EmailTemplate", 'Json'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly isPublic: FieldRef<"EmailTemplate", 'Boolean'>
    readonly isFeatured: FieldRef<"EmailTemplate", 'Boolean'>
    readonly usageCount: FieldRef<"EmailTemplate", 'Int'>
    readonly userId: FieldRef<"EmailTemplate", 'String'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate updateManyAndReturn
   */
  export type EmailTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to delete.
     */
    limit?: number
  }

  /**
   * EmailTemplate.user
   */
  export type EmailTemplate$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * EmailTemplate.emails
   */
  export type EmailTemplate$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    cursor?: EmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
  }


  /**
   * Model EmailAttachment
   */

  export type AggregateEmailAttachment = {
    _count: EmailAttachmentCountAggregateOutputType | null
    _avg: EmailAttachmentAvgAggregateOutputType | null
    _sum: EmailAttachmentSumAggregateOutputType | null
    _min: EmailAttachmentMinAggregateOutputType | null
    _max: EmailAttachmentMaxAggregateOutputType | null
  }

  export type EmailAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type EmailAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type EmailAttachmentMinAggregateOutputType = {
    id: string | null
    emailId: string | null
    filename: string | null
    fileSize: number | null
    mimeType: string | null
    url: string | null
    createdAt: Date | null
  }

  export type EmailAttachmentMaxAggregateOutputType = {
    id: string | null
    emailId: string | null
    filename: string | null
    fileSize: number | null
    mimeType: string | null
    url: string | null
    createdAt: Date | null
  }

  export type EmailAttachmentCountAggregateOutputType = {
    id: number
    emailId: number
    filename: number
    fileSize: number
    mimeType: number
    url: number
    createdAt: number
    _all: number
  }


  export type EmailAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type EmailAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type EmailAttachmentMinAggregateInputType = {
    id?: true
    emailId?: true
    filename?: true
    fileSize?: true
    mimeType?: true
    url?: true
    createdAt?: true
  }

  export type EmailAttachmentMaxAggregateInputType = {
    id?: true
    emailId?: true
    filename?: true
    fileSize?: true
    mimeType?: true
    url?: true
    createdAt?: true
  }

  export type EmailAttachmentCountAggregateInputType = {
    id?: true
    emailId?: true
    filename?: true
    fileSize?: true
    mimeType?: true
    url?: true
    createdAt?: true
    _all?: true
  }

  export type EmailAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAttachment to aggregate.
     */
    where?: EmailAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAttachments to fetch.
     */
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAttachments
    **/
    _count?: true | EmailAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAttachmentMaxAggregateInputType
  }

  export type GetEmailAttachmentAggregateType<T extends EmailAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAttachment[P]>
      : GetScalarType<T[P], AggregateEmailAttachment[P]>
  }




  export type EmailAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAttachmentWhereInput
    orderBy?: EmailAttachmentOrderByWithAggregationInput | EmailAttachmentOrderByWithAggregationInput[]
    by: EmailAttachmentScalarFieldEnum[] | EmailAttachmentScalarFieldEnum
    having?: EmailAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAttachmentCountAggregateInputType | true
    _avg?: EmailAttachmentAvgAggregateInputType
    _sum?: EmailAttachmentSumAggregateInputType
    _min?: EmailAttachmentMinAggregateInputType
    _max?: EmailAttachmentMaxAggregateInputType
  }

  export type EmailAttachmentGroupByOutputType = {
    id: string
    emailId: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt: Date
    _count: EmailAttachmentCountAggregateOutputType | null
    _avg: EmailAttachmentAvgAggregateOutputType | null
    _sum: EmailAttachmentSumAggregateOutputType | null
    _min: EmailAttachmentMinAggregateOutputType | null
    _max: EmailAttachmentMaxAggregateOutputType | null
  }

  type GetEmailAttachmentGroupByPayload<T extends EmailAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type EmailAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    filename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    url?: boolean
    createdAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAttachment"]>

  export type EmailAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    filename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    url?: boolean
    createdAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAttachment"]>

  export type EmailAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    filename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    url?: boolean
    createdAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAttachment"]>

  export type EmailAttachmentSelectScalar = {
    id?: boolean
    emailId?: boolean
    filename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    url?: boolean
    createdAt?: boolean
  }

  export type EmailAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emailId" | "filename" | "fileSize" | "mimeType" | "url" | "createdAt", ExtArgs["result"]["emailAttachment"]>
  export type EmailAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type EmailAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type EmailAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }

  export type $EmailAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAttachment"
    objects: {
      email: Prisma.$EmailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emailId: string
      filename: string
      fileSize: number
      mimeType: string
      url: string
      createdAt: Date
    }, ExtArgs["result"]["emailAttachment"]>
    composites: {}
  }

  type EmailAttachmentGetPayload<S extends boolean | null | undefined | EmailAttachmentDefaultArgs> = $Result.GetResult<Prisma.$EmailAttachmentPayload, S>

  type EmailAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailAttachmentCountAggregateInputType | true
    }

  export interface EmailAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAttachment'], meta: { name: 'EmailAttachment' } }
    /**
     * Find zero or one EmailAttachment that matches the filter.
     * @param {EmailAttachmentFindUniqueArgs} args - Arguments to find a EmailAttachment
     * @example
     * // Get one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailAttachmentFindUniqueArgs>(args: SelectSubset<T, EmailAttachmentFindUniqueArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailAttachmentFindUniqueOrThrowArgs} args - Arguments to find a EmailAttachment
     * @example
     * // Get one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentFindFirstArgs} args - Arguments to find a EmailAttachment
     * @example
     * // Get one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailAttachmentFindFirstArgs>(args?: SelectSubset<T, EmailAttachmentFindFirstArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentFindFirstOrThrowArgs} args - Arguments to find a EmailAttachment
     * @example
     * // Get one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAttachments
     * const emailAttachments = await prisma.emailAttachment.findMany()
     * 
     * // Get first 10 EmailAttachments
     * const emailAttachments = await prisma.emailAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailAttachmentWithIdOnly = await prisma.emailAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailAttachmentFindManyArgs>(args?: SelectSubset<T, EmailAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailAttachment.
     * @param {EmailAttachmentCreateArgs} args - Arguments to create a EmailAttachment.
     * @example
     * // Create one EmailAttachment
     * const EmailAttachment = await prisma.emailAttachment.create({
     *   data: {
     *     // ... data to create a EmailAttachment
     *   }
     * })
     * 
     */
    create<T extends EmailAttachmentCreateArgs>(args: SelectSubset<T, EmailAttachmentCreateArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailAttachments.
     * @param {EmailAttachmentCreateManyArgs} args - Arguments to create many EmailAttachments.
     * @example
     * // Create many EmailAttachments
     * const emailAttachment = await prisma.emailAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailAttachmentCreateManyArgs>(args?: SelectSubset<T, EmailAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailAttachments and returns the data saved in the database.
     * @param {EmailAttachmentCreateManyAndReturnArgs} args - Arguments to create many EmailAttachments.
     * @example
     * // Create many EmailAttachments
     * const emailAttachment = await prisma.emailAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailAttachments and only return the `id`
     * const emailAttachmentWithIdOnly = await prisma.emailAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailAttachment.
     * @param {EmailAttachmentDeleteArgs} args - Arguments to delete one EmailAttachment.
     * @example
     * // Delete one EmailAttachment
     * const EmailAttachment = await prisma.emailAttachment.delete({
     *   where: {
     *     // ... filter to delete one EmailAttachment
     *   }
     * })
     * 
     */
    delete<T extends EmailAttachmentDeleteArgs>(args: SelectSubset<T, EmailAttachmentDeleteArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailAttachment.
     * @param {EmailAttachmentUpdateArgs} args - Arguments to update one EmailAttachment.
     * @example
     * // Update one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailAttachmentUpdateArgs>(args: SelectSubset<T, EmailAttachmentUpdateArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailAttachments.
     * @param {EmailAttachmentDeleteManyArgs} args - Arguments to filter EmailAttachments to delete.
     * @example
     * // Delete a few EmailAttachments
     * const { count } = await prisma.emailAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailAttachmentDeleteManyArgs>(args?: SelectSubset<T, EmailAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAttachments
     * const emailAttachment = await prisma.emailAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailAttachmentUpdateManyArgs>(args: SelectSubset<T, EmailAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAttachments and returns the data updated in the database.
     * @param {EmailAttachmentUpdateManyAndReturnArgs} args - Arguments to update many EmailAttachments.
     * @example
     * // Update many EmailAttachments
     * const emailAttachment = await prisma.emailAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailAttachments and only return the `id`
     * const emailAttachmentWithIdOnly = await prisma.emailAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailAttachment.
     * @param {EmailAttachmentUpsertArgs} args - Arguments to update or create a EmailAttachment.
     * @example
     * // Update or create a EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.upsert({
     *   create: {
     *     // ... data to create a EmailAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAttachment we want to update
     *   }
     * })
     */
    upsert<T extends EmailAttachmentUpsertArgs>(args: SelectSubset<T, EmailAttachmentUpsertArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentCountArgs} args - Arguments to filter EmailAttachments to count.
     * @example
     * // Count the number of EmailAttachments
     * const count = await prisma.emailAttachment.count({
     *   where: {
     *     // ... the filter for the EmailAttachments we want to count
     *   }
     * })
    **/
    count<T extends EmailAttachmentCountArgs>(
      args?: Subset<T, EmailAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAttachmentAggregateArgs>(args: Subset<T, EmailAttachmentAggregateArgs>): Prisma.PrismaPromise<GetEmailAttachmentAggregateType<T>>

    /**
     * Group by EmailAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: EmailAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAttachment model
   */
  readonly fields: EmailAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email<T extends EmailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDefaultArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailAttachment model
   */
  interface EmailAttachmentFieldRefs {
    readonly id: FieldRef<"EmailAttachment", 'String'>
    readonly emailId: FieldRef<"EmailAttachment", 'String'>
    readonly filename: FieldRef<"EmailAttachment", 'String'>
    readonly fileSize: FieldRef<"EmailAttachment", 'Int'>
    readonly mimeType: FieldRef<"EmailAttachment", 'String'>
    readonly url: FieldRef<"EmailAttachment", 'String'>
    readonly createdAt: FieldRef<"EmailAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailAttachment findUnique
   */
  export type EmailAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachment to fetch.
     */
    where: EmailAttachmentWhereUniqueInput
  }

  /**
   * EmailAttachment findUniqueOrThrow
   */
  export type EmailAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachment to fetch.
     */
    where: EmailAttachmentWhereUniqueInput
  }

  /**
   * EmailAttachment findFirst
   */
  export type EmailAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachment to fetch.
     */
    where?: EmailAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAttachments to fetch.
     */
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAttachments.
     */
    cursor?: EmailAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAttachments.
     */
    distinct?: EmailAttachmentScalarFieldEnum | EmailAttachmentScalarFieldEnum[]
  }

  /**
   * EmailAttachment findFirstOrThrow
   */
  export type EmailAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachment to fetch.
     */
    where?: EmailAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAttachments to fetch.
     */
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAttachments.
     */
    cursor?: EmailAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAttachments.
     */
    distinct?: EmailAttachmentScalarFieldEnum | EmailAttachmentScalarFieldEnum[]
  }

  /**
   * EmailAttachment findMany
   */
  export type EmailAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachments to fetch.
     */
    where?: EmailAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAttachments to fetch.
     */
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAttachments.
     */
    cursor?: EmailAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAttachments.
     */
    skip?: number
    distinct?: EmailAttachmentScalarFieldEnum | EmailAttachmentScalarFieldEnum[]
  }

  /**
   * EmailAttachment create
   */
  export type EmailAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAttachment.
     */
    data: XOR<EmailAttachmentCreateInput, EmailAttachmentUncheckedCreateInput>
  }

  /**
   * EmailAttachment createMany
   */
  export type EmailAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAttachments.
     */
    data: EmailAttachmentCreateManyInput | EmailAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailAttachment createManyAndReturn
   */
  export type EmailAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many EmailAttachments.
     */
    data: EmailAttachmentCreateManyInput | EmailAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAttachment update
   */
  export type EmailAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAttachment.
     */
    data: XOR<EmailAttachmentUpdateInput, EmailAttachmentUncheckedUpdateInput>
    /**
     * Choose, which EmailAttachment to update.
     */
    where: EmailAttachmentWhereUniqueInput
  }

  /**
   * EmailAttachment updateMany
   */
  export type EmailAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAttachments.
     */
    data: XOR<EmailAttachmentUpdateManyMutationInput, EmailAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which EmailAttachments to update
     */
    where?: EmailAttachmentWhereInput
    /**
     * Limit how many EmailAttachments to update.
     */
    limit?: number
  }

  /**
   * EmailAttachment updateManyAndReturn
   */
  export type EmailAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update EmailAttachments.
     */
    data: XOR<EmailAttachmentUpdateManyMutationInput, EmailAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which EmailAttachments to update
     */
    where?: EmailAttachmentWhereInput
    /**
     * Limit how many EmailAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAttachment upsert
   */
  export type EmailAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAttachment to update in case it exists.
     */
    where: EmailAttachmentWhereUniqueInput
    /**
     * In case the EmailAttachment found by the `where` argument doesn't exist, create a new EmailAttachment with this data.
     */
    create: XOR<EmailAttachmentCreateInput, EmailAttachmentUncheckedCreateInput>
    /**
     * In case the EmailAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAttachmentUpdateInput, EmailAttachmentUncheckedUpdateInput>
  }

  /**
   * EmailAttachment delete
   */
  export type EmailAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter which EmailAttachment to delete.
     */
    where: EmailAttachmentWhereUniqueInput
  }

  /**
   * EmailAttachment deleteMany
   */
  export type EmailAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAttachments to delete
     */
    where?: EmailAttachmentWhereInput
    /**
     * Limit how many EmailAttachments to delete.
     */
    limit?: number
  }

  /**
   * EmailAttachment without action
   */
  export type EmailAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAttachment
     */
    omit?: EmailAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model EmailRecipient
   */

  export type AggregateEmailRecipient = {
    _count: EmailRecipientCountAggregateOutputType | null
    _min: EmailRecipientMinAggregateOutputType | null
    _max: EmailRecipientMaxAggregateOutputType | null
  }

  export type EmailRecipientMinAggregateOutputType = {
    id: string | null
    emailId: string | null
    recipientEmail: string | null
    status: $Enums.RecipientStatus | null
    sentAt: Date | null
    deliveredAt: Date | null
    openedAt: Date | null
    clickedAt: Date | null
    bouncedAt: Date | null
    bounceReason: string | null
    unsubscribeAt: Date | null
  }

  export type EmailRecipientMaxAggregateOutputType = {
    id: string | null
    emailId: string | null
    recipientEmail: string | null
    status: $Enums.RecipientStatus | null
    sentAt: Date | null
    deliveredAt: Date | null
    openedAt: Date | null
    clickedAt: Date | null
    bouncedAt: Date | null
    bounceReason: string | null
    unsubscribeAt: Date | null
  }

  export type EmailRecipientCountAggregateOutputType = {
    id: number
    emailId: number
    recipientEmail: number
    status: number
    sentAt: number
    deliveredAt: number
    openedAt: number
    clickedAt: number
    bouncedAt: number
    bounceReason: number
    unsubscribeAt: number
    _all: number
  }


  export type EmailRecipientMinAggregateInputType = {
    id?: true
    emailId?: true
    recipientEmail?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    openedAt?: true
    clickedAt?: true
    bouncedAt?: true
    bounceReason?: true
    unsubscribeAt?: true
  }

  export type EmailRecipientMaxAggregateInputType = {
    id?: true
    emailId?: true
    recipientEmail?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    openedAt?: true
    clickedAt?: true
    bouncedAt?: true
    bounceReason?: true
    unsubscribeAt?: true
  }

  export type EmailRecipientCountAggregateInputType = {
    id?: true
    emailId?: true
    recipientEmail?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    openedAt?: true
    clickedAt?: true
    bouncedAt?: true
    bounceReason?: true
    unsubscribeAt?: true
    _all?: true
  }

  export type EmailRecipientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailRecipient to aggregate.
     */
    where?: EmailRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailRecipients to fetch.
     */
    orderBy?: EmailRecipientOrderByWithRelationInput | EmailRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailRecipients
    **/
    _count?: true | EmailRecipientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailRecipientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailRecipientMaxAggregateInputType
  }

  export type GetEmailRecipientAggregateType<T extends EmailRecipientAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailRecipient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailRecipient[P]>
      : GetScalarType<T[P], AggregateEmailRecipient[P]>
  }




  export type EmailRecipientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailRecipientWhereInput
    orderBy?: EmailRecipientOrderByWithAggregationInput | EmailRecipientOrderByWithAggregationInput[]
    by: EmailRecipientScalarFieldEnum[] | EmailRecipientScalarFieldEnum
    having?: EmailRecipientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailRecipientCountAggregateInputType | true
    _min?: EmailRecipientMinAggregateInputType
    _max?: EmailRecipientMaxAggregateInputType
  }

  export type EmailRecipientGroupByOutputType = {
    id: string
    emailId: string
    recipientEmail: string
    status: $Enums.RecipientStatus
    sentAt: Date | null
    deliveredAt: Date | null
    openedAt: Date | null
    clickedAt: Date | null
    bouncedAt: Date | null
    bounceReason: string | null
    unsubscribeAt: Date | null
    _count: EmailRecipientCountAggregateOutputType | null
    _min: EmailRecipientMinAggregateOutputType | null
    _max: EmailRecipientMaxAggregateOutputType | null
  }

  type GetEmailRecipientGroupByPayload<T extends EmailRecipientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailRecipientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailRecipientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailRecipientGroupByOutputType[P]>
            : GetScalarType<T[P], EmailRecipientGroupByOutputType[P]>
        }
      >
    >


  export type EmailRecipientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    recipientEmail?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    bouncedAt?: boolean
    bounceReason?: boolean
    unsubscribeAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailRecipient"]>

  export type EmailRecipientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    recipientEmail?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    bouncedAt?: boolean
    bounceReason?: boolean
    unsubscribeAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailRecipient"]>

  export type EmailRecipientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    recipientEmail?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    bouncedAt?: boolean
    bounceReason?: boolean
    unsubscribeAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailRecipient"]>

  export type EmailRecipientSelectScalar = {
    id?: boolean
    emailId?: boolean
    recipientEmail?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    bouncedAt?: boolean
    bounceReason?: boolean
    unsubscribeAt?: boolean
  }

  export type EmailRecipientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emailId" | "recipientEmail" | "status" | "sentAt" | "deliveredAt" | "openedAt" | "clickedAt" | "bouncedAt" | "bounceReason" | "unsubscribeAt", ExtArgs["result"]["emailRecipient"]>
  export type EmailRecipientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type EmailRecipientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type EmailRecipientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }

  export type $EmailRecipientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailRecipient"
    objects: {
      email: Prisma.$EmailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emailId: string
      recipientEmail: string
      status: $Enums.RecipientStatus
      sentAt: Date | null
      deliveredAt: Date | null
      openedAt: Date | null
      clickedAt: Date | null
      bouncedAt: Date | null
      bounceReason: string | null
      unsubscribeAt: Date | null
    }, ExtArgs["result"]["emailRecipient"]>
    composites: {}
  }

  type EmailRecipientGetPayload<S extends boolean | null | undefined | EmailRecipientDefaultArgs> = $Result.GetResult<Prisma.$EmailRecipientPayload, S>

  type EmailRecipientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailRecipientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailRecipientCountAggregateInputType | true
    }

  export interface EmailRecipientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailRecipient'], meta: { name: 'EmailRecipient' } }
    /**
     * Find zero or one EmailRecipient that matches the filter.
     * @param {EmailRecipientFindUniqueArgs} args - Arguments to find a EmailRecipient
     * @example
     * // Get one EmailRecipient
     * const emailRecipient = await prisma.emailRecipient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailRecipientFindUniqueArgs>(args: SelectSubset<T, EmailRecipientFindUniqueArgs<ExtArgs>>): Prisma__EmailRecipientClient<$Result.GetResult<Prisma.$EmailRecipientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailRecipient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailRecipientFindUniqueOrThrowArgs} args - Arguments to find a EmailRecipient
     * @example
     * // Get one EmailRecipient
     * const emailRecipient = await prisma.emailRecipient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailRecipientFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailRecipientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailRecipientClient<$Result.GetResult<Prisma.$EmailRecipientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailRecipient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailRecipientFindFirstArgs} args - Arguments to find a EmailRecipient
     * @example
     * // Get one EmailRecipient
     * const emailRecipient = await prisma.emailRecipient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailRecipientFindFirstArgs>(args?: SelectSubset<T, EmailRecipientFindFirstArgs<ExtArgs>>): Prisma__EmailRecipientClient<$Result.GetResult<Prisma.$EmailRecipientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailRecipient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailRecipientFindFirstOrThrowArgs} args - Arguments to find a EmailRecipient
     * @example
     * // Get one EmailRecipient
     * const emailRecipient = await prisma.emailRecipient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailRecipientFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailRecipientFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailRecipientClient<$Result.GetResult<Prisma.$EmailRecipientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailRecipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailRecipientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailRecipients
     * const emailRecipients = await prisma.emailRecipient.findMany()
     * 
     * // Get first 10 EmailRecipients
     * const emailRecipients = await prisma.emailRecipient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailRecipientWithIdOnly = await prisma.emailRecipient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailRecipientFindManyArgs>(args?: SelectSubset<T, EmailRecipientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailRecipient.
     * @param {EmailRecipientCreateArgs} args - Arguments to create a EmailRecipient.
     * @example
     * // Create one EmailRecipient
     * const EmailRecipient = await prisma.emailRecipient.create({
     *   data: {
     *     // ... data to create a EmailRecipient
     *   }
     * })
     * 
     */
    create<T extends EmailRecipientCreateArgs>(args: SelectSubset<T, EmailRecipientCreateArgs<ExtArgs>>): Prisma__EmailRecipientClient<$Result.GetResult<Prisma.$EmailRecipientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailRecipients.
     * @param {EmailRecipientCreateManyArgs} args - Arguments to create many EmailRecipients.
     * @example
     * // Create many EmailRecipients
     * const emailRecipient = await prisma.emailRecipient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailRecipientCreateManyArgs>(args?: SelectSubset<T, EmailRecipientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailRecipients and returns the data saved in the database.
     * @param {EmailRecipientCreateManyAndReturnArgs} args - Arguments to create many EmailRecipients.
     * @example
     * // Create many EmailRecipients
     * const emailRecipient = await prisma.emailRecipient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailRecipients and only return the `id`
     * const emailRecipientWithIdOnly = await prisma.emailRecipient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailRecipientCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailRecipientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailRecipientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailRecipient.
     * @param {EmailRecipientDeleteArgs} args - Arguments to delete one EmailRecipient.
     * @example
     * // Delete one EmailRecipient
     * const EmailRecipient = await prisma.emailRecipient.delete({
     *   where: {
     *     // ... filter to delete one EmailRecipient
     *   }
     * })
     * 
     */
    delete<T extends EmailRecipientDeleteArgs>(args: SelectSubset<T, EmailRecipientDeleteArgs<ExtArgs>>): Prisma__EmailRecipientClient<$Result.GetResult<Prisma.$EmailRecipientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailRecipient.
     * @param {EmailRecipientUpdateArgs} args - Arguments to update one EmailRecipient.
     * @example
     * // Update one EmailRecipient
     * const emailRecipient = await prisma.emailRecipient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailRecipientUpdateArgs>(args: SelectSubset<T, EmailRecipientUpdateArgs<ExtArgs>>): Prisma__EmailRecipientClient<$Result.GetResult<Prisma.$EmailRecipientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailRecipients.
     * @param {EmailRecipientDeleteManyArgs} args - Arguments to filter EmailRecipients to delete.
     * @example
     * // Delete a few EmailRecipients
     * const { count } = await prisma.emailRecipient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailRecipientDeleteManyArgs>(args?: SelectSubset<T, EmailRecipientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailRecipientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailRecipients
     * const emailRecipient = await prisma.emailRecipient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailRecipientUpdateManyArgs>(args: SelectSubset<T, EmailRecipientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailRecipients and returns the data updated in the database.
     * @param {EmailRecipientUpdateManyAndReturnArgs} args - Arguments to update many EmailRecipients.
     * @example
     * // Update many EmailRecipients
     * const emailRecipient = await prisma.emailRecipient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailRecipients and only return the `id`
     * const emailRecipientWithIdOnly = await prisma.emailRecipient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailRecipientUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailRecipientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailRecipientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailRecipient.
     * @param {EmailRecipientUpsertArgs} args - Arguments to update or create a EmailRecipient.
     * @example
     * // Update or create a EmailRecipient
     * const emailRecipient = await prisma.emailRecipient.upsert({
     *   create: {
     *     // ... data to create a EmailRecipient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailRecipient we want to update
     *   }
     * })
     */
    upsert<T extends EmailRecipientUpsertArgs>(args: SelectSubset<T, EmailRecipientUpsertArgs<ExtArgs>>): Prisma__EmailRecipientClient<$Result.GetResult<Prisma.$EmailRecipientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailRecipientCountArgs} args - Arguments to filter EmailRecipients to count.
     * @example
     * // Count the number of EmailRecipients
     * const count = await prisma.emailRecipient.count({
     *   where: {
     *     // ... the filter for the EmailRecipients we want to count
     *   }
     * })
    **/
    count<T extends EmailRecipientCountArgs>(
      args?: Subset<T, EmailRecipientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailRecipientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailRecipientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailRecipientAggregateArgs>(args: Subset<T, EmailRecipientAggregateArgs>): Prisma.PrismaPromise<GetEmailRecipientAggregateType<T>>

    /**
     * Group by EmailRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailRecipientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailRecipientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailRecipientGroupByArgs['orderBy'] }
        : { orderBy?: EmailRecipientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailRecipientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailRecipientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailRecipient model
   */
  readonly fields: EmailRecipientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailRecipient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailRecipientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email<T extends EmailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDefaultArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailRecipient model
   */
  interface EmailRecipientFieldRefs {
    readonly id: FieldRef<"EmailRecipient", 'String'>
    readonly emailId: FieldRef<"EmailRecipient", 'String'>
    readonly recipientEmail: FieldRef<"EmailRecipient", 'String'>
    readonly status: FieldRef<"EmailRecipient", 'RecipientStatus'>
    readonly sentAt: FieldRef<"EmailRecipient", 'DateTime'>
    readonly deliveredAt: FieldRef<"EmailRecipient", 'DateTime'>
    readonly openedAt: FieldRef<"EmailRecipient", 'DateTime'>
    readonly clickedAt: FieldRef<"EmailRecipient", 'DateTime'>
    readonly bouncedAt: FieldRef<"EmailRecipient", 'DateTime'>
    readonly bounceReason: FieldRef<"EmailRecipient", 'String'>
    readonly unsubscribeAt: FieldRef<"EmailRecipient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailRecipient findUnique
   */
  export type EmailRecipientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientInclude<ExtArgs> | null
    /**
     * Filter, which EmailRecipient to fetch.
     */
    where: EmailRecipientWhereUniqueInput
  }

  /**
   * EmailRecipient findUniqueOrThrow
   */
  export type EmailRecipientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientInclude<ExtArgs> | null
    /**
     * Filter, which EmailRecipient to fetch.
     */
    where: EmailRecipientWhereUniqueInput
  }

  /**
   * EmailRecipient findFirst
   */
  export type EmailRecipientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientInclude<ExtArgs> | null
    /**
     * Filter, which EmailRecipient to fetch.
     */
    where?: EmailRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailRecipients to fetch.
     */
    orderBy?: EmailRecipientOrderByWithRelationInput | EmailRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailRecipients.
     */
    cursor?: EmailRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailRecipients.
     */
    distinct?: EmailRecipientScalarFieldEnum | EmailRecipientScalarFieldEnum[]
  }

  /**
   * EmailRecipient findFirstOrThrow
   */
  export type EmailRecipientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientInclude<ExtArgs> | null
    /**
     * Filter, which EmailRecipient to fetch.
     */
    where?: EmailRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailRecipients to fetch.
     */
    orderBy?: EmailRecipientOrderByWithRelationInput | EmailRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailRecipients.
     */
    cursor?: EmailRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailRecipients.
     */
    distinct?: EmailRecipientScalarFieldEnum | EmailRecipientScalarFieldEnum[]
  }

  /**
   * EmailRecipient findMany
   */
  export type EmailRecipientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientInclude<ExtArgs> | null
    /**
     * Filter, which EmailRecipients to fetch.
     */
    where?: EmailRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailRecipients to fetch.
     */
    orderBy?: EmailRecipientOrderByWithRelationInput | EmailRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailRecipients.
     */
    cursor?: EmailRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailRecipients.
     */
    skip?: number
    distinct?: EmailRecipientScalarFieldEnum | EmailRecipientScalarFieldEnum[]
  }

  /**
   * EmailRecipient create
   */
  export type EmailRecipientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailRecipient.
     */
    data: XOR<EmailRecipientCreateInput, EmailRecipientUncheckedCreateInput>
  }

  /**
   * EmailRecipient createMany
   */
  export type EmailRecipientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailRecipients.
     */
    data: EmailRecipientCreateManyInput | EmailRecipientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailRecipient createManyAndReturn
   */
  export type EmailRecipientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * The data used to create many EmailRecipients.
     */
    data: EmailRecipientCreateManyInput | EmailRecipientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailRecipient update
   */
  export type EmailRecipientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailRecipient.
     */
    data: XOR<EmailRecipientUpdateInput, EmailRecipientUncheckedUpdateInput>
    /**
     * Choose, which EmailRecipient to update.
     */
    where: EmailRecipientWhereUniqueInput
  }

  /**
   * EmailRecipient updateMany
   */
  export type EmailRecipientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailRecipients.
     */
    data: XOR<EmailRecipientUpdateManyMutationInput, EmailRecipientUncheckedUpdateManyInput>
    /**
     * Filter which EmailRecipients to update
     */
    where?: EmailRecipientWhereInput
    /**
     * Limit how many EmailRecipients to update.
     */
    limit?: number
  }

  /**
   * EmailRecipient updateManyAndReturn
   */
  export type EmailRecipientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * The data used to update EmailRecipients.
     */
    data: XOR<EmailRecipientUpdateManyMutationInput, EmailRecipientUncheckedUpdateManyInput>
    /**
     * Filter which EmailRecipients to update
     */
    where?: EmailRecipientWhereInput
    /**
     * Limit how many EmailRecipients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailRecipient upsert
   */
  export type EmailRecipientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailRecipient to update in case it exists.
     */
    where: EmailRecipientWhereUniqueInput
    /**
     * In case the EmailRecipient found by the `where` argument doesn't exist, create a new EmailRecipient with this data.
     */
    create: XOR<EmailRecipientCreateInput, EmailRecipientUncheckedCreateInput>
    /**
     * In case the EmailRecipient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailRecipientUpdateInput, EmailRecipientUncheckedUpdateInput>
  }

  /**
   * EmailRecipient delete
   */
  export type EmailRecipientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientInclude<ExtArgs> | null
    /**
     * Filter which EmailRecipient to delete.
     */
    where: EmailRecipientWhereUniqueInput
  }

  /**
   * EmailRecipient deleteMany
   */
  export type EmailRecipientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailRecipients to delete
     */
    where?: EmailRecipientWhereInput
    /**
     * Limit how many EmailRecipients to delete.
     */
    limit?: number
  }

  /**
   * EmailRecipient without action
   */
  export type EmailRecipientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailRecipient
     */
    select?: EmailRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailRecipient
     */
    omit?: EmailRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailRecipientInclude<ExtArgs> | null
  }


  /**
   * Model EmailAnalytics
   */

  export type AggregateEmailAnalytics = {
    _count: EmailAnalyticsCountAggregateOutputType | null
    _avg: EmailAnalyticsAvgAggregateOutputType | null
    _sum: EmailAnalyticsSumAggregateOutputType | null
    _min: EmailAnalyticsMinAggregateOutputType | null
    _max: EmailAnalyticsMaxAggregateOutputType | null
  }

  export type EmailAnalyticsAvgAggregateOutputType = {
    totalOpens: number | null
    deliveredCount: number | null
    totalRecipients: number | null
    uniqueOpens: number | null
    totalClicks: number | null
    uniqueClicks: number | null
    deliveryRate: number | null
    openRate: number | null
    clickRate: number | null
    bounceRate: number | null
    unsubscribeCount: number | null
    spamReportCount: number | null
    forwardCount: number | null
  }

  export type EmailAnalyticsSumAggregateOutputType = {
    totalOpens: number | null
    deliveredCount: number | null
    totalRecipients: number | null
    uniqueOpens: number | null
    totalClicks: number | null
    uniqueClicks: number | null
    deliveryRate: number | null
    openRate: number | null
    clickRate: number | null
    bounceRate: number | null
    unsubscribeCount: number | null
    spamReportCount: number | null
    forwardCount: number | null
  }

  export type EmailAnalyticsMinAggregateOutputType = {
    id: string | null
    emailId: string | null
    totalOpens: number | null
    deliveredCount: number | null
    totalRecipients: number | null
    uniqueOpens: number | null
    totalClicks: number | null
    uniqueClicks: number | null
    deliveryRate: number | null
    openRate: number | null
    clickRate: number | null
    bounceRate: number | null
    unsubscribeCount: number | null
    spamReportCount: number | null
    forwardCount: number | null
  }

  export type EmailAnalyticsMaxAggregateOutputType = {
    id: string | null
    emailId: string | null
    totalOpens: number | null
    deliveredCount: number | null
    totalRecipients: number | null
    uniqueOpens: number | null
    totalClicks: number | null
    uniqueClicks: number | null
    deliveryRate: number | null
    openRate: number | null
    clickRate: number | null
    bounceRate: number | null
    unsubscribeCount: number | null
    spamReportCount: number | null
    forwardCount: number | null
  }

  export type EmailAnalyticsCountAggregateOutputType = {
    id: number
    emailId: number
    totalOpens: number
    deliveredCount: number
    totalRecipients: number
    uniqueOpens: number
    totalClicks: number
    uniqueClicks: number
    deliveryRate: number
    openRate: number
    clickRate: number
    bounceRate: number
    unsubscribeCount: number
    spamReportCount: number
    forwardCount: number
    deviceBreakdown: number
    locationData: number
    _all: number
  }


  export type EmailAnalyticsAvgAggregateInputType = {
    totalOpens?: true
    deliveredCount?: true
    totalRecipients?: true
    uniqueOpens?: true
    totalClicks?: true
    uniqueClicks?: true
    deliveryRate?: true
    openRate?: true
    clickRate?: true
    bounceRate?: true
    unsubscribeCount?: true
    spamReportCount?: true
    forwardCount?: true
  }

  export type EmailAnalyticsSumAggregateInputType = {
    totalOpens?: true
    deliveredCount?: true
    totalRecipients?: true
    uniqueOpens?: true
    totalClicks?: true
    uniqueClicks?: true
    deliveryRate?: true
    openRate?: true
    clickRate?: true
    bounceRate?: true
    unsubscribeCount?: true
    spamReportCount?: true
    forwardCount?: true
  }

  export type EmailAnalyticsMinAggregateInputType = {
    id?: true
    emailId?: true
    totalOpens?: true
    deliveredCount?: true
    totalRecipients?: true
    uniqueOpens?: true
    totalClicks?: true
    uniqueClicks?: true
    deliveryRate?: true
    openRate?: true
    clickRate?: true
    bounceRate?: true
    unsubscribeCount?: true
    spamReportCount?: true
    forwardCount?: true
  }

  export type EmailAnalyticsMaxAggregateInputType = {
    id?: true
    emailId?: true
    totalOpens?: true
    deliveredCount?: true
    totalRecipients?: true
    uniqueOpens?: true
    totalClicks?: true
    uniqueClicks?: true
    deliveryRate?: true
    openRate?: true
    clickRate?: true
    bounceRate?: true
    unsubscribeCount?: true
    spamReportCount?: true
    forwardCount?: true
  }

  export type EmailAnalyticsCountAggregateInputType = {
    id?: true
    emailId?: true
    totalOpens?: true
    deliveredCount?: true
    totalRecipients?: true
    uniqueOpens?: true
    totalClicks?: true
    uniqueClicks?: true
    deliveryRate?: true
    openRate?: true
    clickRate?: true
    bounceRate?: true
    unsubscribeCount?: true
    spamReportCount?: true
    forwardCount?: true
    deviceBreakdown?: true
    locationData?: true
    _all?: true
  }

  export type EmailAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAnalytics to aggregate.
     */
    where?: EmailAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAnalytics to fetch.
     */
    orderBy?: EmailAnalyticsOrderByWithRelationInput | EmailAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAnalytics
    **/
    _count?: true | EmailAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAnalyticsMaxAggregateInputType
  }

  export type GetEmailAnalyticsAggregateType<T extends EmailAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAnalytics[P]>
      : GetScalarType<T[P], AggregateEmailAnalytics[P]>
  }




  export type EmailAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAnalyticsWhereInput
    orderBy?: EmailAnalyticsOrderByWithAggregationInput | EmailAnalyticsOrderByWithAggregationInput[]
    by: EmailAnalyticsScalarFieldEnum[] | EmailAnalyticsScalarFieldEnum
    having?: EmailAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAnalyticsCountAggregateInputType | true
    _avg?: EmailAnalyticsAvgAggregateInputType
    _sum?: EmailAnalyticsSumAggregateInputType
    _min?: EmailAnalyticsMinAggregateInputType
    _max?: EmailAnalyticsMaxAggregateInputType
  }

  export type EmailAnalyticsGroupByOutputType = {
    id: string
    emailId: string
    totalOpens: number
    deliveredCount: number
    totalRecipients: number
    uniqueOpens: number
    totalClicks: number
    uniqueClicks: number
    deliveryRate: number
    openRate: number
    clickRate: number
    bounceRate: number
    unsubscribeCount: number
    spamReportCount: number
    forwardCount: number
    deviceBreakdown: JsonValue | null
    locationData: JsonValue | null
    _count: EmailAnalyticsCountAggregateOutputType | null
    _avg: EmailAnalyticsAvgAggregateOutputType | null
    _sum: EmailAnalyticsSumAggregateOutputType | null
    _min: EmailAnalyticsMinAggregateOutputType | null
    _max: EmailAnalyticsMaxAggregateOutputType | null
  }

  type GetEmailAnalyticsGroupByPayload<T extends EmailAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type EmailAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    totalOpens?: boolean
    deliveredCount?: boolean
    totalRecipients?: boolean
    uniqueOpens?: boolean
    totalClicks?: boolean
    uniqueClicks?: boolean
    deliveryRate?: boolean
    openRate?: boolean
    clickRate?: boolean
    bounceRate?: boolean
    unsubscribeCount?: boolean
    spamReportCount?: boolean
    forwardCount?: boolean
    deviceBreakdown?: boolean
    locationData?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAnalytics"]>

  export type EmailAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    totalOpens?: boolean
    deliveredCount?: boolean
    totalRecipients?: boolean
    uniqueOpens?: boolean
    totalClicks?: boolean
    uniqueClicks?: boolean
    deliveryRate?: boolean
    openRate?: boolean
    clickRate?: boolean
    bounceRate?: boolean
    unsubscribeCount?: boolean
    spamReportCount?: boolean
    forwardCount?: boolean
    deviceBreakdown?: boolean
    locationData?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAnalytics"]>

  export type EmailAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    totalOpens?: boolean
    deliveredCount?: boolean
    totalRecipients?: boolean
    uniqueOpens?: boolean
    totalClicks?: boolean
    uniqueClicks?: boolean
    deliveryRate?: boolean
    openRate?: boolean
    clickRate?: boolean
    bounceRate?: boolean
    unsubscribeCount?: boolean
    spamReportCount?: boolean
    forwardCount?: boolean
    deviceBreakdown?: boolean
    locationData?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAnalytics"]>

  export type EmailAnalyticsSelectScalar = {
    id?: boolean
    emailId?: boolean
    totalOpens?: boolean
    deliveredCount?: boolean
    totalRecipients?: boolean
    uniqueOpens?: boolean
    totalClicks?: boolean
    uniqueClicks?: boolean
    deliveryRate?: boolean
    openRate?: boolean
    clickRate?: boolean
    bounceRate?: boolean
    unsubscribeCount?: boolean
    spamReportCount?: boolean
    forwardCount?: boolean
    deviceBreakdown?: boolean
    locationData?: boolean
  }

  export type EmailAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emailId" | "totalOpens" | "deliveredCount" | "totalRecipients" | "uniqueOpens" | "totalClicks" | "uniqueClicks" | "deliveryRate" | "openRate" | "clickRate" | "bounceRate" | "unsubscribeCount" | "spamReportCount" | "forwardCount" | "deviceBreakdown" | "locationData", ExtArgs["result"]["emailAnalytics"]>
  export type EmailAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type EmailAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type EmailAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }

  export type $EmailAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAnalytics"
    objects: {
      email: Prisma.$EmailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emailId: string
      totalOpens: number
      deliveredCount: number
      totalRecipients: number
      uniqueOpens: number
      totalClicks: number
      uniqueClicks: number
      deliveryRate: number
      openRate: number
      clickRate: number
      bounceRate: number
      unsubscribeCount: number
      spamReportCount: number
      forwardCount: number
      deviceBreakdown: Prisma.JsonValue | null
      locationData: Prisma.JsonValue | null
    }, ExtArgs["result"]["emailAnalytics"]>
    composites: {}
  }

  type EmailAnalyticsGetPayload<S extends boolean | null | undefined | EmailAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$EmailAnalyticsPayload, S>

  type EmailAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailAnalyticsCountAggregateInputType | true
    }

  export interface EmailAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAnalytics'], meta: { name: 'EmailAnalytics' } }
    /**
     * Find zero or one EmailAnalytics that matches the filter.
     * @param {EmailAnalyticsFindUniqueArgs} args - Arguments to find a EmailAnalytics
     * @example
     * // Get one EmailAnalytics
     * const emailAnalytics = await prisma.emailAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailAnalyticsFindUniqueArgs>(args: SelectSubset<T, EmailAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__EmailAnalyticsClient<$Result.GetResult<Prisma.$EmailAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a EmailAnalytics
     * @example
     * // Get one EmailAnalytics
     * const emailAnalytics = await prisma.emailAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailAnalyticsClient<$Result.GetResult<Prisma.$EmailAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAnalyticsFindFirstArgs} args - Arguments to find a EmailAnalytics
     * @example
     * // Get one EmailAnalytics
     * const emailAnalytics = await prisma.emailAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailAnalyticsFindFirstArgs>(args?: SelectSubset<T, EmailAnalyticsFindFirstArgs<ExtArgs>>): Prisma__EmailAnalyticsClient<$Result.GetResult<Prisma.$EmailAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAnalyticsFindFirstOrThrowArgs} args - Arguments to find a EmailAnalytics
     * @example
     * // Get one EmailAnalytics
     * const emailAnalytics = await prisma.emailAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailAnalyticsClient<$Result.GetResult<Prisma.$EmailAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAnalytics
     * const emailAnalytics = await prisma.emailAnalytics.findMany()
     * 
     * // Get first 10 EmailAnalytics
     * const emailAnalytics = await prisma.emailAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailAnalyticsWithIdOnly = await prisma.emailAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailAnalyticsFindManyArgs>(args?: SelectSubset<T, EmailAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailAnalytics.
     * @param {EmailAnalyticsCreateArgs} args - Arguments to create a EmailAnalytics.
     * @example
     * // Create one EmailAnalytics
     * const EmailAnalytics = await prisma.emailAnalytics.create({
     *   data: {
     *     // ... data to create a EmailAnalytics
     *   }
     * })
     * 
     */
    create<T extends EmailAnalyticsCreateArgs>(args: SelectSubset<T, EmailAnalyticsCreateArgs<ExtArgs>>): Prisma__EmailAnalyticsClient<$Result.GetResult<Prisma.$EmailAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailAnalytics.
     * @param {EmailAnalyticsCreateManyArgs} args - Arguments to create many EmailAnalytics.
     * @example
     * // Create many EmailAnalytics
     * const emailAnalytics = await prisma.emailAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailAnalyticsCreateManyArgs>(args?: SelectSubset<T, EmailAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailAnalytics and returns the data saved in the database.
     * @param {EmailAnalyticsCreateManyAndReturnArgs} args - Arguments to create many EmailAnalytics.
     * @example
     * // Create many EmailAnalytics
     * const emailAnalytics = await prisma.emailAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailAnalytics and only return the `id`
     * const emailAnalyticsWithIdOnly = await prisma.emailAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailAnalytics.
     * @param {EmailAnalyticsDeleteArgs} args - Arguments to delete one EmailAnalytics.
     * @example
     * // Delete one EmailAnalytics
     * const EmailAnalytics = await prisma.emailAnalytics.delete({
     *   where: {
     *     // ... filter to delete one EmailAnalytics
     *   }
     * })
     * 
     */
    delete<T extends EmailAnalyticsDeleteArgs>(args: SelectSubset<T, EmailAnalyticsDeleteArgs<ExtArgs>>): Prisma__EmailAnalyticsClient<$Result.GetResult<Prisma.$EmailAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailAnalytics.
     * @param {EmailAnalyticsUpdateArgs} args - Arguments to update one EmailAnalytics.
     * @example
     * // Update one EmailAnalytics
     * const emailAnalytics = await prisma.emailAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailAnalyticsUpdateArgs>(args: SelectSubset<T, EmailAnalyticsUpdateArgs<ExtArgs>>): Prisma__EmailAnalyticsClient<$Result.GetResult<Prisma.$EmailAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailAnalytics.
     * @param {EmailAnalyticsDeleteManyArgs} args - Arguments to filter EmailAnalytics to delete.
     * @example
     * // Delete a few EmailAnalytics
     * const { count } = await prisma.emailAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailAnalyticsDeleteManyArgs>(args?: SelectSubset<T, EmailAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAnalytics
     * const emailAnalytics = await prisma.emailAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailAnalyticsUpdateManyArgs>(args: SelectSubset<T, EmailAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAnalytics and returns the data updated in the database.
     * @param {EmailAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many EmailAnalytics.
     * @example
     * // Update many EmailAnalytics
     * const emailAnalytics = await prisma.emailAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailAnalytics and only return the `id`
     * const emailAnalyticsWithIdOnly = await prisma.emailAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailAnalytics.
     * @param {EmailAnalyticsUpsertArgs} args - Arguments to update or create a EmailAnalytics.
     * @example
     * // Update or create a EmailAnalytics
     * const emailAnalytics = await prisma.emailAnalytics.upsert({
     *   create: {
     *     // ... data to create a EmailAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends EmailAnalyticsUpsertArgs>(args: SelectSubset<T, EmailAnalyticsUpsertArgs<ExtArgs>>): Prisma__EmailAnalyticsClient<$Result.GetResult<Prisma.$EmailAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAnalyticsCountArgs} args - Arguments to filter EmailAnalytics to count.
     * @example
     * // Count the number of EmailAnalytics
     * const count = await prisma.emailAnalytics.count({
     *   where: {
     *     // ... the filter for the EmailAnalytics we want to count
     *   }
     * })
    **/
    count<T extends EmailAnalyticsCountArgs>(
      args?: Subset<T, EmailAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAnalyticsAggregateArgs>(args: Subset<T, EmailAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetEmailAnalyticsAggregateType<T>>

    /**
     * Group by EmailAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: EmailAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAnalytics model
   */
  readonly fields: EmailAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email<T extends EmailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDefaultArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailAnalytics model
   */
  interface EmailAnalyticsFieldRefs {
    readonly id: FieldRef<"EmailAnalytics", 'String'>
    readonly emailId: FieldRef<"EmailAnalytics", 'String'>
    readonly totalOpens: FieldRef<"EmailAnalytics", 'Int'>
    readonly deliveredCount: FieldRef<"EmailAnalytics", 'Int'>
    readonly totalRecipients: FieldRef<"EmailAnalytics", 'Int'>
    readonly uniqueOpens: FieldRef<"EmailAnalytics", 'Int'>
    readonly totalClicks: FieldRef<"EmailAnalytics", 'Int'>
    readonly uniqueClicks: FieldRef<"EmailAnalytics", 'Int'>
    readonly deliveryRate: FieldRef<"EmailAnalytics", 'Float'>
    readonly openRate: FieldRef<"EmailAnalytics", 'Float'>
    readonly clickRate: FieldRef<"EmailAnalytics", 'Float'>
    readonly bounceRate: FieldRef<"EmailAnalytics", 'Float'>
    readonly unsubscribeCount: FieldRef<"EmailAnalytics", 'Int'>
    readonly spamReportCount: FieldRef<"EmailAnalytics", 'Int'>
    readonly forwardCount: FieldRef<"EmailAnalytics", 'Int'>
    readonly deviceBreakdown: FieldRef<"EmailAnalytics", 'Json'>
    readonly locationData: FieldRef<"EmailAnalytics", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * EmailAnalytics findUnique
   */
  export type EmailAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which EmailAnalytics to fetch.
     */
    where: EmailAnalyticsWhereUniqueInput
  }

  /**
   * EmailAnalytics findUniqueOrThrow
   */
  export type EmailAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which EmailAnalytics to fetch.
     */
    where: EmailAnalyticsWhereUniqueInput
  }

  /**
   * EmailAnalytics findFirst
   */
  export type EmailAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which EmailAnalytics to fetch.
     */
    where?: EmailAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAnalytics to fetch.
     */
    orderBy?: EmailAnalyticsOrderByWithRelationInput | EmailAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAnalytics.
     */
    cursor?: EmailAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAnalytics.
     */
    distinct?: EmailAnalyticsScalarFieldEnum | EmailAnalyticsScalarFieldEnum[]
  }

  /**
   * EmailAnalytics findFirstOrThrow
   */
  export type EmailAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which EmailAnalytics to fetch.
     */
    where?: EmailAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAnalytics to fetch.
     */
    orderBy?: EmailAnalyticsOrderByWithRelationInput | EmailAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAnalytics.
     */
    cursor?: EmailAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAnalytics.
     */
    distinct?: EmailAnalyticsScalarFieldEnum | EmailAnalyticsScalarFieldEnum[]
  }

  /**
   * EmailAnalytics findMany
   */
  export type EmailAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which EmailAnalytics to fetch.
     */
    where?: EmailAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAnalytics to fetch.
     */
    orderBy?: EmailAnalyticsOrderByWithRelationInput | EmailAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAnalytics.
     */
    cursor?: EmailAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAnalytics.
     */
    skip?: number
    distinct?: EmailAnalyticsScalarFieldEnum | EmailAnalyticsScalarFieldEnum[]
  }

  /**
   * EmailAnalytics create
   */
  export type EmailAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAnalytics.
     */
    data: XOR<EmailAnalyticsCreateInput, EmailAnalyticsUncheckedCreateInput>
  }

  /**
   * EmailAnalytics createMany
   */
  export type EmailAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAnalytics.
     */
    data: EmailAnalyticsCreateManyInput | EmailAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailAnalytics createManyAndReturn
   */
  export type EmailAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many EmailAnalytics.
     */
    data: EmailAnalyticsCreateManyInput | EmailAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAnalytics update
   */
  export type EmailAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAnalytics.
     */
    data: XOR<EmailAnalyticsUpdateInput, EmailAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which EmailAnalytics to update.
     */
    where: EmailAnalyticsWhereUniqueInput
  }

  /**
   * EmailAnalytics updateMany
   */
  export type EmailAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAnalytics.
     */
    data: XOR<EmailAnalyticsUpdateManyMutationInput, EmailAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which EmailAnalytics to update
     */
    where?: EmailAnalyticsWhereInput
    /**
     * Limit how many EmailAnalytics to update.
     */
    limit?: number
  }

  /**
   * EmailAnalytics updateManyAndReturn
   */
  export type EmailAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update EmailAnalytics.
     */
    data: XOR<EmailAnalyticsUpdateManyMutationInput, EmailAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which EmailAnalytics to update
     */
    where?: EmailAnalyticsWhereInput
    /**
     * Limit how many EmailAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAnalytics upsert
   */
  export type EmailAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAnalytics to update in case it exists.
     */
    where: EmailAnalyticsWhereUniqueInput
    /**
     * In case the EmailAnalytics found by the `where` argument doesn't exist, create a new EmailAnalytics with this data.
     */
    create: XOR<EmailAnalyticsCreateInput, EmailAnalyticsUncheckedCreateInput>
    /**
     * In case the EmailAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAnalyticsUpdateInput, EmailAnalyticsUncheckedUpdateInput>
  }

  /**
   * EmailAnalytics delete
   */
  export type EmailAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which EmailAnalytics to delete.
     */
    where: EmailAnalyticsWhereUniqueInput
  }

  /**
   * EmailAnalytics deleteMany
   */
  export type EmailAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAnalytics to delete
     */
    where?: EmailAnalyticsWhereInput
    /**
     * Limit how many EmailAnalytics to delete.
     */
    limit?: number
  }

  /**
   * EmailAnalytics without action
   */
  export type EmailAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAnalytics
     */
    select?: EmailAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAnalytics
     */
    omit?: EmailAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    fullName: 'fullName',
    userName: 'userName',
    password: 'password',
    imageUrl: 'imageUrl',
    paystackCustomerId: 'paystackCustomerId',
    paystackSubscriptionId: 'paystackSubscriptionId',
    plan: 'plan',
    role: 'role',
    subscriptionStatus: 'subscriptionStatus',
    accType: 'accType',
    currentPeriodEnd: 'currentPeriodEnd',
    organization: 'organization',
    website: 'website',
    kycStatus: 'kycStatus',
    SenderName: 'SenderName',
    amount: 'amount',
    currency: 'currency',
    lastPaymentDate: 'lastPaymentDate',
    nextPaymentDate: 'nextPaymentDate',
    successfulPayments: 'successfulPayments',
    failedAttempts: 'failedAttempts',
    subscriberLimit: 'subscriberLimit',
    emailLimit: 'emailLimit',
    blogPostLimit: 'blogPostLimit',
    aiGenerationLimit: 'aiGenerationLimit',
    termsAndConditionsAccepted: 'termsAndConditionsAccepted',
    approvedKYC: 'approvedKYC',
    isEmailVerified: 'isEmailVerified',
    isLoggedIn: 'isLoggedIn',
    is2FAEnabled: 'is2FAEnabled',
    createdAt: 'createdAt',
    loggedInAt: 'loggedInAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    jti: 'jti',
    userId: 'userId',
    hashed: 'hashed',
    userAgent: 'userAgent',
    ip: 'ip',
    revoked: 'revoked',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const OTPScalarFieldEnum: {
    id: 'id',
    email: 'email',
    otp: 'otp',
    attempts: 'attempts',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OTPScalarFieldEnum = (typeof OTPScalarFieldEnum)[keyof typeof OTPScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    description: 'description',
    amount: 'amount',
    status: 'status',
    invoiceUrl: 'invoiceUrl',
    date: 'date',
    externalId: 'externalId'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const ThirdPartyOTPScalarFieldEnum: {
    email: 'email',
    code: 'code',
    otpType: 'otpType',
    expiresAt: 'expiresAt',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    attempts: 'attempts'
  };

  export type ThirdPartyOTPScalarFieldEnum = (typeof ThirdPartyOTPScalarFieldEnum)[keyof typeof ThirdPartyOTPScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    keyHash: 'keyHash',
    jwt: 'jwt',
    createdAt: 'createdAt',
    isTrial: 'isTrial',
    expiresAt: 'expiresAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const KycScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountType: 'accountType',
    status: 'status',
    levels: 'levels',
    documents: 'documents',
    livePhoto: 'livePhoto',
    reviewedTime: 'reviewedTime',
    reviewedBy: 'reviewedBy',
    rejectedResponse: 'rejectedResponse',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KycScalarFieldEnum = (typeof KycScalarFieldEnum)[keyof typeof KycScalarFieldEnum]


  export const KYCDocumentScalarFieldEnum: {
    id: 'id',
    kycId: 'kycId',
    type: 'type',
    url: 'url',
    key: 'key',
    uploadedAt: 'uploadedAt'
  };

  export type KYCDocumentScalarFieldEnum = (typeof KYCDocumentScalarFieldEnum)[keyof typeof KYCDocumentScalarFieldEnum]


  export const MembershipUsageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    month: 'month',
    emailsSent: 'emailsSent',
    subscribersAdded: 'subscribersAdded',
    campaignsCreated: 'campaignsCreated',
    blogPostsCreated: 'blogPostsCreated',
    aiGenerationsUsed: 'aiGenerationsUsed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MembershipUsageScalarFieldEnum = (typeof MembershipUsageScalarFieldEnum)[keyof typeof MembershipUsageScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    slug: 'slug',
    content: 'content',
    excerpt: 'excerpt',
    format: 'format',
    status: 'status',
    visibility: 'visibility',
    featuredImage: 'featuredImage',
    featuredVideo: 'featuredVideo',
    galleryImages: 'galleryImages',
    authorId: 'authorId',
    authorBio: 'authorBio',
    authorTitle: 'authorTitle',
    author: 'author',
    categoryId: 'categoryId',
    seoTitle: 'seoTitle',
    seoDescription: 'seoDescription',
    seoKeywords: 'seoKeywords',
    seoScore: 'seoScore',
    shares: 'shares',
    readTime: 'readTime',
    wordCount: 'wordCount',
    characterCount: 'characterCount',
    likes: 'likes',
    views: 'views',
    flagReason: 'flagReason',
    isFlagged: 'isFlagged',
    isFeatured: 'isFeatured',
    isPinned: 'isPinned',
    allowComments: 'allowComments',
    publishedAt: 'publishedAt',
    flaggedAt: 'flaggedAt',
    scheduledAt: 'scheduledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    generatedById: 'generatedById'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const FlagedBlogPostScalarFieldEnum: {
    id: 'id',
    reason: 'reason',
    comment: 'comment',
    flaggedBy: 'flaggedBy',
    status: 'status',
    createdAt: 'createdAt',
    reviewedAt: 'reviewedAt',
    postId: 'postId',
    userId: 'userId'
  };

  export type FlagedBlogPostScalarFieldEnum = (typeof FlagedBlogPostScalarFieldEnum)[keyof typeof FlagedBlogPostScalarFieldEnum]


  export const BlogPostViewScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    externalName: 'externalName',
    createdAt: 'createdAt'
  };

  export type BlogPostViewScalarFieldEnum = (typeof BlogPostViewScalarFieldEnum)[keyof typeof BlogPostViewScalarFieldEnum]


  export const BlogCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogCategoryScalarFieldEnum = (typeof BlogCategoryScalarFieldEnum)[keyof typeof BlogCategoryScalarFieldEnum]


  export const BlogTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogTagScalarFieldEnum = (typeof BlogTagScalarFieldEnum)[keyof typeof BlogTagScalarFieldEnum]


  export const BlogCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    authorId: 'authorId',
    postId: 'postId',
    userId: 'userId',
    parentId: 'parentId',
    externalName: 'externalName',
    externalAvatar: 'externalAvatar',
    likes: 'likes',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogCommentScalarFieldEnum = (typeof BlogCommentScalarFieldEnum)[keyof typeof BlogCommentScalarFieldEnum]


  export const ReportedCommentScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    blogSlug: 'blogSlug',
    blogOwner: 'blogOwner',
    parentCommentBy: 'parentCommentBy',
    reportedBy: 'reportedBy',
    reason: 'reason',
    reportedAt: 'reportedAt',
    resolved: 'resolved'
  };

  export type ReportedCommentScalarFieldEnum = (typeof ReportedCommentScalarFieldEnum)[keyof typeof ReportedCommentScalarFieldEnum]


  export const BlogAIGenerationScalarFieldEnum: {
    id: 'id',
    prompt: 'prompt',
    parameters: 'parameters',
    status: 'status',
    output: 'output',
    format: 'format',
    cost: 'cost',
    tokensUsed: 'tokensUsed',
    model: 'model',
    userId: 'userId',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type BlogAIGenerationScalarFieldEnum = (typeof BlogAIGenerationScalarFieldEnum)[keyof typeof BlogAIGenerationScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    userId: 'userId',
    description: 'description',
    type: 'type',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    emailsSent: 'emailsSent',
    recipients: 'recipients',
    openRate: 'openRate',
    clickRate: 'clickRate',
    lastSentAt: 'lastSentAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const SubscriberScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    newsLetterOwnerId: 'newsLetterOwnerId',
    source: 'source',
    status: 'status',
    campaignId: 'campaignId',
    pageUrl: 'pageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriberScalarFieldEnum = (typeof SubscriberScalarFieldEnum)[keyof typeof SubscriberScalarFieldEnum]


  export const EmailNotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    category: 'category',
    title: 'title',
    content: 'content',
    textContent: 'textContent',
    htmlContent: 'htmlContent',
    status: 'status',
    priority: 'priority',
    userId: 'userId',
    emailsSentCount: 'emailsSentCount',
    openCount: 'openCount',
    clickCount: 'clickCount',
    recipients: 'recipients',
    bounceCount: 'bounceCount',
    openedByEmails: 'openedByEmails',
    clickedByEmails: 'clickedByEmails',
    lastOpened: 'lastOpened',
    lastClicked: 'lastClicked',
    metadata: 'metadata',
    sentAt: 'sentAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    read: 'read'
  };

  export type EmailNotificationScalarFieldEnum = (typeof EmailNotificationScalarFieldEnum)[keyof typeof EmailNotificationScalarFieldEnum]


  export const ClickedLinkScalarFieldEnum: {
    id: 'id',
    emailId: 'emailId',
    url: 'url',
    clickedAt: 'clickedAt',
    clickedBy: 'clickedBy'
  };

  export type ClickedLinkScalarFieldEnum = (typeof ClickedLinkScalarFieldEnum)[keyof typeof ClickedLinkScalarFieldEnum]


  export const NotificationEmailClickedLinkScalarFieldEnum: {
    id: 'id',
    notificationEmailId: 'notificationEmailId',
    url: 'url',
    clickedAt: 'clickedAt',
    clickedBy: 'clickedBy'
  };

  export type NotificationEmailClickedLinkScalarFieldEnum = (typeof NotificationEmailClickedLinkScalarFieldEnum)[keyof typeof NotificationEmailClickedLinkScalarFieldEnum]


  export const EmailScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    emailSubject: 'emailSubject',
    previewText: 'previewText',
    builderMode: 'builderMode',
    builderData: 'builderData',
    templateUsed: 'templateUsed',
    status: 'status',
    emailType: 'emailType',
    trackOpens: 'trackOpens',
    trackClicks: 'trackClicks',
    enableUnsubscribe: 'enableUnsubscribe',
    scheduleDate: 'scheduleDate',
    scheduleTime: 'scheduleTime',
    emailsSentCount: 'emailsSentCount',
    recipients: 'recipients',
    bounceCount: 'bounceCount',
    openCount: 'openCount',
    clickCount: 'clickCount',
    sentAt: 'sentAt',
    lastOpened: 'lastOpened',
    lastClicked: 'lastClicked',
    openedByIps: 'openedByIps',
    openedByEmails: 'openedByEmails',
    clickedByIps: 'clickedByIps',
    clickedByEmails: 'clickedByEmails',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    newsLetterOwnerId: 'newsLetterOwnerId',
    campaignId: 'campaignId',
    messageId: 'messageId'
  };

  export type EmailScalarFieldEnum = (typeof EmailScalarFieldEnum)[keyof typeof EmailScalarFieldEnum]


  export const EmailElementScalarFieldEnum: {
    id: 'id',
    emailId: 'emailId',
    elementId: 'elementId',
    type: 'type',
    content: 'content',
    properties: 'properties',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailElementScalarFieldEnum = (typeof EmailElementScalarFieldEnum)[keyof typeof EmailElementScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    thumbnail: 'thumbnail',
    category: 'category',
    tags: 'tags',
    elements: 'elements',
    subject: 'subject',
    isPublic: 'isPublic',
    isFeatured: 'isFeatured',
    usageCount: 'usageCount',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const EmailAttachmentScalarFieldEnum: {
    id: 'id',
    emailId: 'emailId',
    filename: 'filename',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    url: 'url',
    createdAt: 'createdAt'
  };

  export type EmailAttachmentScalarFieldEnum = (typeof EmailAttachmentScalarFieldEnum)[keyof typeof EmailAttachmentScalarFieldEnum]


  export const EmailRecipientScalarFieldEnum: {
    id: 'id',
    emailId: 'emailId',
    recipientEmail: 'recipientEmail',
    status: 'status',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    openedAt: 'openedAt',
    clickedAt: 'clickedAt',
    bouncedAt: 'bouncedAt',
    bounceReason: 'bounceReason',
    unsubscribeAt: 'unsubscribeAt'
  };

  export type EmailRecipientScalarFieldEnum = (typeof EmailRecipientScalarFieldEnum)[keyof typeof EmailRecipientScalarFieldEnum]


  export const EmailAnalyticsScalarFieldEnum: {
    id: 'id',
    emailId: 'emailId',
    totalOpens: 'totalOpens',
    deliveredCount: 'deliveredCount',
    totalRecipients: 'totalRecipients',
    uniqueOpens: 'uniqueOpens',
    totalClicks: 'totalClicks',
    uniqueClicks: 'uniqueClicks',
    deliveryRate: 'deliveryRate',
    openRate: 'openRate',
    clickRate: 'clickRate',
    bounceRate: 'bounceRate',
    unsubscribeCount: 'unsubscribeCount',
    spamReportCount: 'spamReportCount',
    forwardCount: 'forwardCount',
    deviceBreakdown: 'deviceBreakdown',
    locationData: 'locationData'
  };

  export type EmailAnalyticsScalarFieldEnum = (typeof EmailAnalyticsScalarFieldEnum)[keyof typeof EmailAnalyticsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Plan'
   */
  export type EnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan'>
    


  /**
   * Reference to a field of type 'Plan[]'
   */
  export type ListEnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'PlanSubscriptionStatus'
   */
  export type EnumPlanSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanSubscriptionStatus'>
    


  /**
   * Reference to a field of type 'PlanSubscriptionStatus[]'
   */
  export type ListEnumPlanSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanSubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'KYCStatus'
   */
  export type EnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus'>
    


  /**
   * Reference to a field of type 'KYCStatus[]'
   */
  export type ListEnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'KYCAccountType'
   */
  export type EnumKYCAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCAccountType'>
    


  /**
   * Reference to a field of type 'KYCAccountType[]'
   */
  export type ListEnumKYCAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCAccountType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ContentFormat'
   */
  export type EnumContentFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentFormat'>
    


  /**
   * Reference to a field of type 'ContentFormat[]'
   */
  export type ListEnumContentFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentFormat[]'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'PostVisibility'
   */
  export type EnumPostVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostVisibility'>
    


  /**
   * Reference to a field of type 'PostVisibility[]'
   */
  export type ListEnumPostVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostVisibility[]'>
    


  /**
   * Reference to a field of type 'FlagStatus'
   */
  export type EnumFlagStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlagStatus'>
    


  /**
   * Reference to a field of type 'FlagStatus[]'
   */
  export type ListEnumFlagStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlagStatus[]'>
    


  /**
   * Reference to a field of type 'AIGenerationStatus'
   */
  export type EnumAIGenerationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIGenerationStatus'>
    


  /**
   * Reference to a field of type 'AIGenerationStatus[]'
   */
  export type ListEnumAIGenerationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIGenerationStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'CampaignStatus[]'
   */
  export type ListEnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationCategory'
   */
  export type EnumNotificationCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationCategory'>
    


  /**
   * Reference to a field of type 'NotificationCategory[]'
   */
  export type ListEnumNotificationCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationCategory[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    


  /**
   * Reference to a field of type 'NotificationPriority[]'
   */
  export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority[]'>
    


  /**
   * Reference to a field of type 'EmailStatus'
   */
  export type EnumEmailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailStatus'>
    


  /**
   * Reference to a field of type 'EmailStatus[]'
   */
  export type ListEnumEmailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailStatus[]'>
    


  /**
   * Reference to a field of type 'EmailType'
   */
  export type EnumEmailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailType'>
    


  /**
   * Reference to a field of type 'EmailType[]'
   */
  export type ListEnumEmailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailType[]'>
    


  /**
   * Reference to a field of type 'ElementType'
   */
  export type EnumElementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ElementType'>
    


  /**
   * Reference to a field of type 'ElementType[]'
   */
  export type ListEnumElementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ElementType[]'>
    


  /**
   * Reference to a field of type 'RecipientStatus'
   */
  export type EnumRecipientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecipientStatus'>
    


  /**
   * Reference to a field of type 'RecipientStatus[]'
   */
  export type ListEnumRecipientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecipientStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    userId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    userName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    imageUrl?: StringNullableFilter<"User"> | string | null
    paystackCustomerId?: StringNullableFilter<"User"> | string | null
    paystackSubscriptionId?: StringNullableFilter<"User"> | string | null
    plan?: EnumPlanFilter<"User"> | $Enums.Plan
    role?: EnumRoleFilter<"User"> | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFilter<"User"> | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    currentPeriodEnd?: DateTimeNullableFilter<"User"> | Date | string | null
    organization?: StringNullableFilter<"User"> | string | null
    website?: StringNullableFilter<"User"> | string | null
    kycStatus?: EnumKYCStatusFilter<"User"> | $Enums.KYCStatus
    SenderName?: StringNullableFilter<"User"> | string | null
    amount?: IntFilter<"User"> | number
    currency?: StringFilter<"User"> | string
    lastPaymentDate?: DateTimeNullableFilter<"User"> | Date | string | null
    nextPaymentDate?: DateTimeNullableFilter<"User"> | Date | string | null
    successfulPayments?: IntFilter<"User"> | number
    failedAttempts?: IntFilter<"User"> | number
    subscriberLimit?: IntFilter<"User"> | number
    emailLimit?: IntFilter<"User"> | number
    blogPostLimit?: IntFilter<"User"> | number
    aiGenerationLimit?: IntFilter<"User"> | number
    termsAndConditionsAccepted?: BoolFilter<"User"> | boolean
    approvedKYC?: BoolFilter<"User"> | boolean
    isEmailVerified?: BoolFilter<"User"> | boolean
    isLoggedIn?: BoolFilter<"User"> | boolean
    is2FAEnabled?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    loggedInAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    apiKeys?: ApiKeyListRelationFilter
    aIContentGenerationToExcerpt?: BlogAIGenerationListRelationFilter
    blogComments?: BlogCommentListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    postViews?: BlogPostViewListRelationFilter
    emails?: EmailListRelationFilter
    flagedPosts?: FlagedBlogPostListRelationFilter
    invoices?: InvoiceListRelationFilter
    kyc?: XOR<KycNullableScalarRelationFilter, KycWhereInput> | null
    usage?: MembershipUsageListRelationFilter
    notificationEmails?: EmailNotificationListRelationFilter
    tokens?: RefreshTokenListRelationFilter
    reportedComments?: ReportedCommentListRelationFilter
    template?: EmailTemplateListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    paystackCustomerId?: SortOrderInput | SortOrder
    paystackSubscriptionId?: SortOrderInput | SortOrder
    plan?: SortOrder
    role?: SortOrder
    subscriptionStatus?: SortOrder
    accType?: SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    kycStatus?: SortOrder
    SenderName?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    nextPaymentDate?: SortOrderInput | SortOrder
    successfulPayments?: SortOrder
    failedAttempts?: SortOrder
    subscriberLimit?: SortOrder
    emailLimit?: SortOrder
    blogPostLimit?: SortOrder
    aiGenerationLimit?: SortOrder
    termsAndConditionsAccepted?: SortOrder
    approvedKYC?: SortOrder
    isEmailVerified?: SortOrder
    isLoggedIn?: SortOrder
    is2FAEnabled?: SortOrder
    createdAt?: SortOrder
    loggedInAt?: SortOrder
    updatedAt?: SortOrder
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    aIContentGenerationToExcerpt?: BlogAIGenerationOrderByRelationAggregateInput
    blogComments?: BlogCommentOrderByRelationAggregateInput
    blogPosts?: BlogPostOrderByRelationAggregateInput
    postViews?: BlogPostViewOrderByRelationAggregateInput
    emails?: EmailOrderByRelationAggregateInput
    flagedPosts?: FlagedBlogPostOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    kyc?: KycOrderByWithRelationInput
    usage?: MembershipUsageOrderByRelationAggregateInput
    notificationEmails?: EmailNotificationOrderByRelationAggregateInput
    tokens?: RefreshTokenOrderByRelationAggregateInput
    reportedComments?: ReportedCommentOrderByRelationAggregateInput
    template?: EmailTemplateOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullName?: StringFilter<"User"> | string
    userName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    imageUrl?: StringNullableFilter<"User"> | string | null
    paystackCustomerId?: StringNullableFilter<"User"> | string | null
    paystackSubscriptionId?: StringNullableFilter<"User"> | string | null
    plan?: EnumPlanFilter<"User"> | $Enums.Plan
    role?: EnumRoleFilter<"User"> | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFilter<"User"> | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    currentPeriodEnd?: DateTimeNullableFilter<"User"> | Date | string | null
    organization?: StringNullableFilter<"User"> | string | null
    website?: StringNullableFilter<"User"> | string | null
    kycStatus?: EnumKYCStatusFilter<"User"> | $Enums.KYCStatus
    SenderName?: StringNullableFilter<"User"> | string | null
    amount?: IntFilter<"User"> | number
    currency?: StringFilter<"User"> | string
    lastPaymentDate?: DateTimeNullableFilter<"User"> | Date | string | null
    nextPaymentDate?: DateTimeNullableFilter<"User"> | Date | string | null
    successfulPayments?: IntFilter<"User"> | number
    failedAttempts?: IntFilter<"User"> | number
    subscriberLimit?: IntFilter<"User"> | number
    emailLimit?: IntFilter<"User"> | number
    blogPostLimit?: IntFilter<"User"> | number
    aiGenerationLimit?: IntFilter<"User"> | number
    termsAndConditionsAccepted?: BoolFilter<"User"> | boolean
    approvedKYC?: BoolFilter<"User"> | boolean
    isEmailVerified?: BoolFilter<"User"> | boolean
    isLoggedIn?: BoolFilter<"User"> | boolean
    is2FAEnabled?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    loggedInAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    apiKeys?: ApiKeyListRelationFilter
    aIContentGenerationToExcerpt?: BlogAIGenerationListRelationFilter
    blogComments?: BlogCommentListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    postViews?: BlogPostViewListRelationFilter
    emails?: EmailListRelationFilter
    flagedPosts?: FlagedBlogPostListRelationFilter
    invoices?: InvoiceListRelationFilter
    kyc?: XOR<KycNullableScalarRelationFilter, KycWhereInput> | null
    usage?: MembershipUsageListRelationFilter
    notificationEmails?: EmailNotificationListRelationFilter
    tokens?: RefreshTokenListRelationFilter
    reportedComments?: ReportedCommentListRelationFilter
    template?: EmailTemplateListRelationFilter
  }, "id" | "userId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    paystackCustomerId?: SortOrderInput | SortOrder
    paystackSubscriptionId?: SortOrderInput | SortOrder
    plan?: SortOrder
    role?: SortOrder
    subscriptionStatus?: SortOrder
    accType?: SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    kycStatus?: SortOrder
    SenderName?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    nextPaymentDate?: SortOrderInput | SortOrder
    successfulPayments?: SortOrder
    failedAttempts?: SortOrder
    subscriberLimit?: SortOrder
    emailLimit?: SortOrder
    blogPostLimit?: SortOrder
    aiGenerationLimit?: SortOrder
    termsAndConditionsAccepted?: SortOrder
    approvedKYC?: SortOrder
    isEmailVerified?: SortOrder
    isLoggedIn?: SortOrder
    is2FAEnabled?: SortOrder
    createdAt?: SortOrder
    loggedInAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    userId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    userName?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    paystackCustomerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    paystackSubscriptionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    plan?: EnumPlanWithAggregatesFilter<"User"> | $Enums.Plan
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusWithAggregatesFilter<"User"> | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeWithAggregatesFilter<"User"> | $Enums.AccountType
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    organization?: StringNullableWithAggregatesFilter<"User"> | string | null
    website?: StringNullableWithAggregatesFilter<"User"> | string | null
    kycStatus?: EnumKYCStatusWithAggregatesFilter<"User"> | $Enums.KYCStatus
    SenderName?: StringNullableWithAggregatesFilter<"User"> | string | null
    amount?: IntWithAggregatesFilter<"User"> | number
    currency?: StringWithAggregatesFilter<"User"> | string
    lastPaymentDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    nextPaymentDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    successfulPayments?: IntWithAggregatesFilter<"User"> | number
    failedAttempts?: IntWithAggregatesFilter<"User"> | number
    subscriberLimit?: IntWithAggregatesFilter<"User"> | number
    emailLimit?: IntWithAggregatesFilter<"User"> | number
    blogPostLimit?: IntWithAggregatesFilter<"User"> | number
    aiGenerationLimit?: IntWithAggregatesFilter<"User"> | number
    termsAndConditionsAccepted?: BoolWithAggregatesFilter<"User"> | boolean
    approvedKYC?: BoolWithAggregatesFilter<"User"> | boolean
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isLoggedIn?: BoolWithAggregatesFilter<"User"> | boolean
    is2FAEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    loggedInAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    jti?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    hashed?: StringFilter<"RefreshToken"> | string
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    ip?: StringNullableFilter<"RefreshToken"> | string | null
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    jti?: SortOrder
    userId?: SortOrder
    hashed?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jti?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    hashed?: StringFilter<"RefreshToken"> | string
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    ip?: StringNullableFilter<"RefreshToken"> | string | null
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "jti">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    jti?: SortOrder
    userId?: SortOrder
    hashed?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    jti?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    hashed?: StringWithAggregatesFilter<"RefreshToken"> | string
    userAgent?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    ip?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    revoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type OTPWhereInput = {
    AND?: OTPWhereInput | OTPWhereInput[]
    OR?: OTPWhereInput[]
    NOT?: OTPWhereInput | OTPWhereInput[]
    id?: StringFilter<"OTP"> | string
    email?: StringFilter<"OTP"> | string
    otp?: StringFilter<"OTP"> | string
    attempts?: IntFilter<"OTP"> | number
    expiresAt?: DateTimeFilter<"OTP"> | Date | string
    createdAt?: DateTimeFilter<"OTP"> | Date | string
    updatedAt?: DateTimeFilter<"OTP"> | Date | string
  }

  export type OTPOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    attempts?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OTPWhereInput | OTPWhereInput[]
    OR?: OTPWhereInput[]
    NOT?: OTPWhereInput | OTPWhereInput[]
    email?: StringFilter<"OTP"> | string
    otp?: StringFilter<"OTP"> | string
    attempts?: IntFilter<"OTP"> | number
    expiresAt?: DateTimeFilter<"OTP"> | Date | string
    createdAt?: DateTimeFilter<"OTP"> | Date | string
    updatedAt?: DateTimeFilter<"OTP"> | Date | string
  }, "id">

  export type OTPOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    attempts?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OTPCountOrderByAggregateInput
    _avg?: OTPAvgOrderByAggregateInput
    _max?: OTPMaxOrderByAggregateInput
    _min?: OTPMinOrderByAggregateInput
    _sum?: OTPSumOrderByAggregateInput
  }

  export type OTPScalarWhereWithAggregatesInput = {
    AND?: OTPScalarWhereWithAggregatesInput | OTPScalarWhereWithAggregatesInput[]
    OR?: OTPScalarWhereWithAggregatesInput[]
    NOT?: OTPScalarWhereWithAggregatesInput | OTPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OTP"> | string
    email?: StringWithAggregatesFilter<"OTP"> | string
    otp?: StringWithAggregatesFilter<"OTP"> | string
    attempts?: IntWithAggregatesFilter<"OTP"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"OTP"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"OTP"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OTP"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    description?: StringFilter<"Invoice"> | string
    amount?: IntFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    invoiceUrl?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    externalId?: StringNullableFilter<"Invoice"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    invoiceUrl?: SortOrder
    date?: SortOrder
    externalId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    userId?: StringFilter<"Invoice"> | string
    description?: StringFilter<"Invoice"> | string
    amount?: IntFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    invoiceUrl?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    externalId?: StringNullableFilter<"Invoice"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    invoiceUrl?: SortOrder
    date?: SortOrder
    externalId?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    userId?: StringWithAggregatesFilter<"Invoice"> | string
    description?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: IntWithAggregatesFilter<"Invoice"> | number
    status?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceUrl?: StringWithAggregatesFilter<"Invoice"> | string
    date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    externalId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
  }

  export type ThirdPartyOTPWhereInput = {
    AND?: ThirdPartyOTPWhereInput | ThirdPartyOTPWhereInput[]
    OR?: ThirdPartyOTPWhereInput[]
    NOT?: ThirdPartyOTPWhereInput | ThirdPartyOTPWhereInput[]
    email?: StringFilter<"ThirdPartyOTP"> | string
    code?: StringFilter<"ThirdPartyOTP"> | string
    otpType?: StringFilter<"ThirdPartyOTP"> | string
    expiresAt?: DateTimeFilter<"ThirdPartyOTP"> | Date | string
    createdBy?: StringFilter<"ThirdPartyOTP"> | string
    createdAt?: DateTimeFilter<"ThirdPartyOTP"> | Date | string
    attempts?: IntFilter<"ThirdPartyOTP"> | number
  }

  export type ThirdPartyOTPOrderByWithRelationInput = {
    email?: SortOrder
    code?: SortOrder
    otpType?: SortOrder
    expiresAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
  }

  export type ThirdPartyOTPWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    AND?: ThirdPartyOTPWhereInput | ThirdPartyOTPWhereInput[]
    OR?: ThirdPartyOTPWhereInput[]
    NOT?: ThirdPartyOTPWhereInput | ThirdPartyOTPWhereInput[]
    code?: StringFilter<"ThirdPartyOTP"> | string
    otpType?: StringFilter<"ThirdPartyOTP"> | string
    expiresAt?: DateTimeFilter<"ThirdPartyOTP"> | Date | string
    createdBy?: StringFilter<"ThirdPartyOTP"> | string
    createdAt?: DateTimeFilter<"ThirdPartyOTP"> | Date | string
    attempts?: IntFilter<"ThirdPartyOTP"> | number
  }, "email">

  export type ThirdPartyOTPOrderByWithAggregationInput = {
    email?: SortOrder
    code?: SortOrder
    otpType?: SortOrder
    expiresAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
    _count?: ThirdPartyOTPCountOrderByAggregateInput
    _avg?: ThirdPartyOTPAvgOrderByAggregateInput
    _max?: ThirdPartyOTPMaxOrderByAggregateInput
    _min?: ThirdPartyOTPMinOrderByAggregateInput
    _sum?: ThirdPartyOTPSumOrderByAggregateInput
  }

  export type ThirdPartyOTPScalarWhereWithAggregatesInput = {
    AND?: ThirdPartyOTPScalarWhereWithAggregatesInput | ThirdPartyOTPScalarWhereWithAggregatesInput[]
    OR?: ThirdPartyOTPScalarWhereWithAggregatesInput[]
    NOT?: ThirdPartyOTPScalarWhereWithAggregatesInput | ThirdPartyOTPScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"ThirdPartyOTP"> | string
    code?: StringWithAggregatesFilter<"ThirdPartyOTP"> | string
    otpType?: StringWithAggregatesFilter<"ThirdPartyOTP"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"ThirdPartyOTP"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ThirdPartyOTP"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ThirdPartyOTP"> | Date | string
    attempts?: IntWithAggregatesFilter<"ThirdPartyOTP"> | number
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    jwt?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    isTrial?: BoolFilter<"ApiKey"> | boolean
    expiresAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    jwt?: SortOrder
    createdAt?: SortOrder
    isTrial?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyHash?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    userId?: StringFilter<"ApiKey"> | string
    jwt?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    isTrial?: BoolFilter<"ApiKey"> | boolean
    expiresAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "keyHash">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    jwt?: SortOrder
    createdAt?: SortOrder
    isTrial?: SortOrder
    expiresAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    userId?: StringWithAggregatesFilter<"ApiKey"> | string
    keyHash?: StringWithAggregatesFilter<"ApiKey"> | string
    jwt?: StringWithAggregatesFilter<"ApiKey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    isTrial?: BoolWithAggregatesFilter<"ApiKey"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type KycWhereInput = {
    AND?: KycWhereInput | KycWhereInput[]
    OR?: KycWhereInput[]
    NOT?: KycWhereInput | KycWhereInput[]
    id?: StringFilter<"Kyc"> | string
    userId?: StringFilter<"Kyc"> | string
    accountType?: EnumKYCAccountTypeFilter<"Kyc"> | $Enums.KYCAccountType
    status?: EnumKYCStatusFilter<"Kyc"> | $Enums.KYCStatus
    levels?: JsonFilter<"Kyc">
    documents?: JsonFilter<"Kyc">
    livePhoto?: StringNullableFilter<"Kyc"> | string | null
    reviewedTime?: DateTimeNullableFilter<"Kyc"> | Date | string | null
    reviewedBy?: StringNullableFilter<"Kyc"> | string | null
    rejectedResponse?: StringNullableFilter<"Kyc"> | string | null
    comments?: StringNullableFilter<"Kyc"> | string | null
    createdAt?: DateTimeFilter<"Kyc"> | Date | string
    updatedAt?: DateTimeFilter<"Kyc"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    kycDocuments?: KYCDocumentListRelationFilter
  }

  export type KycOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    status?: SortOrder
    levels?: SortOrder
    documents?: SortOrder
    livePhoto?: SortOrderInput | SortOrder
    reviewedTime?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    rejectedResponse?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    kycDocuments?: KYCDocumentOrderByRelationAggregateInput
  }

  export type KycWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: KycWhereInput | KycWhereInput[]
    OR?: KycWhereInput[]
    NOT?: KycWhereInput | KycWhereInput[]
    accountType?: EnumKYCAccountTypeFilter<"Kyc"> | $Enums.KYCAccountType
    status?: EnumKYCStatusFilter<"Kyc"> | $Enums.KYCStatus
    levels?: JsonFilter<"Kyc">
    documents?: JsonFilter<"Kyc">
    livePhoto?: StringNullableFilter<"Kyc"> | string | null
    reviewedTime?: DateTimeNullableFilter<"Kyc"> | Date | string | null
    reviewedBy?: StringNullableFilter<"Kyc"> | string | null
    rejectedResponse?: StringNullableFilter<"Kyc"> | string | null
    comments?: StringNullableFilter<"Kyc"> | string | null
    createdAt?: DateTimeFilter<"Kyc"> | Date | string
    updatedAt?: DateTimeFilter<"Kyc"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    kycDocuments?: KYCDocumentListRelationFilter
  }, "id" | "userId">

  export type KycOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    status?: SortOrder
    levels?: SortOrder
    documents?: SortOrder
    livePhoto?: SortOrderInput | SortOrder
    reviewedTime?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    rejectedResponse?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KycCountOrderByAggregateInput
    _max?: KycMaxOrderByAggregateInput
    _min?: KycMinOrderByAggregateInput
  }

  export type KycScalarWhereWithAggregatesInput = {
    AND?: KycScalarWhereWithAggregatesInput | KycScalarWhereWithAggregatesInput[]
    OR?: KycScalarWhereWithAggregatesInput[]
    NOT?: KycScalarWhereWithAggregatesInput | KycScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Kyc"> | string
    userId?: StringWithAggregatesFilter<"Kyc"> | string
    accountType?: EnumKYCAccountTypeWithAggregatesFilter<"Kyc"> | $Enums.KYCAccountType
    status?: EnumKYCStatusWithAggregatesFilter<"Kyc"> | $Enums.KYCStatus
    levels?: JsonWithAggregatesFilter<"Kyc">
    documents?: JsonWithAggregatesFilter<"Kyc">
    livePhoto?: StringNullableWithAggregatesFilter<"Kyc"> | string | null
    reviewedTime?: DateTimeNullableWithAggregatesFilter<"Kyc"> | Date | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"Kyc"> | string | null
    rejectedResponse?: StringNullableWithAggregatesFilter<"Kyc"> | string | null
    comments?: StringNullableWithAggregatesFilter<"Kyc"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Kyc"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Kyc"> | Date | string
  }

  export type KYCDocumentWhereInput = {
    AND?: KYCDocumentWhereInput | KYCDocumentWhereInput[]
    OR?: KYCDocumentWhereInput[]
    NOT?: KYCDocumentWhereInput | KYCDocumentWhereInput[]
    id?: StringFilter<"KYCDocument"> | string
    kycId?: StringFilter<"KYCDocument"> | string
    type?: StringFilter<"KYCDocument"> | string
    url?: StringFilter<"KYCDocument"> | string
    key?: StringFilter<"KYCDocument"> | string
    uploadedAt?: DateTimeFilter<"KYCDocument"> | Date | string
    kyc?: XOR<KycScalarRelationFilter, KycWhereInput>
  }

  export type KYCDocumentOrderByWithRelationInput = {
    id?: SortOrder
    kycId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    key?: SortOrder
    uploadedAt?: SortOrder
    kyc?: KycOrderByWithRelationInput
  }

  export type KYCDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KYCDocumentWhereInput | KYCDocumentWhereInput[]
    OR?: KYCDocumentWhereInput[]
    NOT?: KYCDocumentWhereInput | KYCDocumentWhereInput[]
    kycId?: StringFilter<"KYCDocument"> | string
    type?: StringFilter<"KYCDocument"> | string
    url?: StringFilter<"KYCDocument"> | string
    key?: StringFilter<"KYCDocument"> | string
    uploadedAt?: DateTimeFilter<"KYCDocument"> | Date | string
    kyc?: XOR<KycScalarRelationFilter, KycWhereInput>
  }, "id">

  export type KYCDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    kycId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    key?: SortOrder
    uploadedAt?: SortOrder
    _count?: KYCDocumentCountOrderByAggregateInput
    _max?: KYCDocumentMaxOrderByAggregateInput
    _min?: KYCDocumentMinOrderByAggregateInput
  }

  export type KYCDocumentScalarWhereWithAggregatesInput = {
    AND?: KYCDocumentScalarWhereWithAggregatesInput | KYCDocumentScalarWhereWithAggregatesInput[]
    OR?: KYCDocumentScalarWhereWithAggregatesInput[]
    NOT?: KYCDocumentScalarWhereWithAggregatesInput | KYCDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KYCDocument"> | string
    kycId?: StringWithAggregatesFilter<"KYCDocument"> | string
    type?: StringWithAggregatesFilter<"KYCDocument"> | string
    url?: StringWithAggregatesFilter<"KYCDocument"> | string
    key?: StringWithAggregatesFilter<"KYCDocument"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"KYCDocument"> | Date | string
  }

  export type MembershipUsageWhereInput = {
    AND?: MembershipUsageWhereInput | MembershipUsageWhereInput[]
    OR?: MembershipUsageWhereInput[]
    NOT?: MembershipUsageWhereInput | MembershipUsageWhereInput[]
    id?: StringFilter<"MembershipUsage"> | string
    userId?: StringFilter<"MembershipUsage"> | string
    month?: StringFilter<"MembershipUsage"> | string
    emailsSent?: IntFilter<"MembershipUsage"> | number
    subscribersAdded?: IntFilter<"MembershipUsage"> | number
    campaignsCreated?: IntFilter<"MembershipUsage"> | number
    blogPostsCreated?: IntFilter<"MembershipUsage"> | number
    aiGenerationsUsed?: IntFilter<"MembershipUsage"> | number
    createdAt?: DateTimeFilter<"MembershipUsage"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipUsage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MembershipUsageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    emailsSent?: SortOrder
    subscribersAdded?: SortOrder
    campaignsCreated?: SortOrder
    blogPostsCreated?: SortOrder
    aiGenerationsUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MembershipUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_month?: MembershipUsageUserId_monthCompoundUniqueInput
    AND?: MembershipUsageWhereInput | MembershipUsageWhereInput[]
    OR?: MembershipUsageWhereInput[]
    NOT?: MembershipUsageWhereInput | MembershipUsageWhereInput[]
    userId?: StringFilter<"MembershipUsage"> | string
    month?: StringFilter<"MembershipUsage"> | string
    emailsSent?: IntFilter<"MembershipUsage"> | number
    subscribersAdded?: IntFilter<"MembershipUsage"> | number
    campaignsCreated?: IntFilter<"MembershipUsage"> | number
    blogPostsCreated?: IntFilter<"MembershipUsage"> | number
    aiGenerationsUsed?: IntFilter<"MembershipUsage"> | number
    createdAt?: DateTimeFilter<"MembershipUsage"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipUsage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_month">

  export type MembershipUsageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    emailsSent?: SortOrder
    subscribersAdded?: SortOrder
    campaignsCreated?: SortOrder
    blogPostsCreated?: SortOrder
    aiGenerationsUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MembershipUsageCountOrderByAggregateInput
    _avg?: MembershipUsageAvgOrderByAggregateInput
    _max?: MembershipUsageMaxOrderByAggregateInput
    _min?: MembershipUsageMinOrderByAggregateInput
    _sum?: MembershipUsageSumOrderByAggregateInput
  }

  export type MembershipUsageScalarWhereWithAggregatesInput = {
    AND?: MembershipUsageScalarWhereWithAggregatesInput | MembershipUsageScalarWhereWithAggregatesInput[]
    OR?: MembershipUsageScalarWhereWithAggregatesInput[]
    NOT?: MembershipUsageScalarWhereWithAggregatesInput | MembershipUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MembershipUsage"> | string
    userId?: StringWithAggregatesFilter<"MembershipUsage"> | string
    month?: StringWithAggregatesFilter<"MembershipUsage"> | string
    emailsSent?: IntWithAggregatesFilter<"MembershipUsage"> | number
    subscribersAdded?: IntWithAggregatesFilter<"MembershipUsage"> | number
    campaignsCreated?: IntWithAggregatesFilter<"MembershipUsage"> | number
    blogPostsCreated?: IntWithAggregatesFilter<"MembershipUsage"> | number
    aiGenerationsUsed?: IntWithAggregatesFilter<"MembershipUsage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MembershipUsage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MembershipUsage"> | Date | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    subtitle?: StringNullableFilter<"BlogPost"> | string | null
    slug?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    format?: EnumContentFormatFilter<"BlogPost"> | $Enums.ContentFormat
    status?: EnumPostStatusFilter<"BlogPost"> | $Enums.PostStatus
    visibility?: EnumPostVisibilityFilter<"BlogPost"> | $Enums.PostVisibility
    featuredImage?: StringFilter<"BlogPost"> | string
    featuredVideo?: StringNullableFilter<"BlogPost"> | string | null
    galleryImages?: StringNullableListFilter<"BlogPost">
    authorId?: StringFilter<"BlogPost"> | string
    authorBio?: StringFilter<"BlogPost"> | string
    authorTitle?: StringFilter<"BlogPost"> | string
    author?: StringFilter<"BlogPost"> | string
    categoryId?: StringNullableFilter<"BlogPost"> | string | null
    seoTitle?: StringNullableFilter<"BlogPost"> | string | null
    seoDescription?: StringNullableFilter<"BlogPost"> | string | null
    seoKeywords?: StringNullableListFilter<"BlogPost">
    seoScore?: IntFilter<"BlogPost"> | number
    shares?: IntFilter<"BlogPost"> | number
    readTime?: IntFilter<"BlogPost"> | number
    wordCount?: IntFilter<"BlogPost"> | number
    characterCount?: IntFilter<"BlogPost"> | number
    likes?: IntFilter<"BlogPost"> | number
    views?: IntFilter<"BlogPost"> | number
    flagReason?: StringNullableFilter<"BlogPost"> | string | null
    isFlagged?: BoolFilter<"BlogPost"> | boolean
    isFeatured?: BoolFilter<"BlogPost"> | boolean
    isPinned?: BoolFilter<"BlogPost"> | boolean
    allowComments?: BoolFilter<"BlogPost"> | boolean
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    flaggedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    scheduledAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    generatedById?: StringNullableFilter<"BlogPost"> | string | null
    comments?: BlogCommentListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    category?: XOR<BlogCategoryNullableScalarRelationFilter, BlogCategoryWhereInput> | null
    aiGeneration?: XOR<BlogAIGenerationNullableScalarRelationFilter, BlogAIGenerationWhereInput> | null
    viewsCount?: BlogPostViewListRelationFilter
    flaggedPosts?: FlagedBlogPostListRelationFilter
    tags?: BlogTagListRelationFilter
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    format?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    featuredImage?: SortOrder
    featuredVideo?: SortOrderInput | SortOrder
    galleryImages?: SortOrder
    authorId?: SortOrder
    authorBio?: SortOrder
    authorTitle?: SortOrder
    author?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    seoKeywords?: SortOrder
    seoScore?: SortOrder
    shares?: SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    characterCount?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    flagReason?: SortOrderInput | SortOrder
    isFlagged?: SortOrder
    isFeatured?: SortOrder
    isPinned?: SortOrder
    allowComments?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    flaggedAt?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    generatedById?: SortOrderInput | SortOrder
    comments?: BlogCommentOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    category?: BlogCategoryOrderByWithRelationInput
    aiGeneration?: BlogAIGenerationOrderByWithRelationInput
    viewsCount?: BlogPostViewOrderByRelationAggregateInput
    flaggedPosts?: FlagedBlogPostOrderByRelationAggregateInput
    tags?: BlogTagOrderByRelationAggregateInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    subtitle?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    format?: EnumContentFormatFilter<"BlogPost"> | $Enums.ContentFormat
    status?: EnumPostStatusFilter<"BlogPost"> | $Enums.PostStatus
    visibility?: EnumPostVisibilityFilter<"BlogPost"> | $Enums.PostVisibility
    featuredImage?: StringFilter<"BlogPost"> | string
    featuredVideo?: StringNullableFilter<"BlogPost"> | string | null
    galleryImages?: StringNullableListFilter<"BlogPost">
    authorId?: StringFilter<"BlogPost"> | string
    authorBio?: StringFilter<"BlogPost"> | string
    authorTitle?: StringFilter<"BlogPost"> | string
    author?: StringFilter<"BlogPost"> | string
    categoryId?: StringNullableFilter<"BlogPost"> | string | null
    seoTitle?: StringNullableFilter<"BlogPost"> | string | null
    seoDescription?: StringNullableFilter<"BlogPost"> | string | null
    seoKeywords?: StringNullableListFilter<"BlogPost">
    seoScore?: IntFilter<"BlogPost"> | number
    shares?: IntFilter<"BlogPost"> | number
    readTime?: IntFilter<"BlogPost"> | number
    wordCount?: IntFilter<"BlogPost"> | number
    characterCount?: IntFilter<"BlogPost"> | number
    likes?: IntFilter<"BlogPost"> | number
    views?: IntFilter<"BlogPost"> | number
    flagReason?: StringNullableFilter<"BlogPost"> | string | null
    isFlagged?: BoolFilter<"BlogPost"> | boolean
    isFeatured?: BoolFilter<"BlogPost"> | boolean
    isPinned?: BoolFilter<"BlogPost"> | boolean
    allowComments?: BoolFilter<"BlogPost"> | boolean
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    flaggedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    scheduledAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    generatedById?: StringNullableFilter<"BlogPost"> | string | null
    comments?: BlogCommentListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    category?: XOR<BlogCategoryNullableScalarRelationFilter, BlogCategoryWhereInput> | null
    aiGeneration?: XOR<BlogAIGenerationNullableScalarRelationFilter, BlogAIGenerationWhereInput> | null
    viewsCount?: BlogPostViewListRelationFilter
    flaggedPosts?: FlagedBlogPostListRelationFilter
    tags?: BlogTagListRelationFilter
  }, "id" | "slug">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    format?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    featuredImage?: SortOrder
    featuredVideo?: SortOrderInput | SortOrder
    galleryImages?: SortOrder
    authorId?: SortOrder
    authorBio?: SortOrder
    authorTitle?: SortOrder
    author?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    seoKeywords?: SortOrder
    seoScore?: SortOrder
    shares?: SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    characterCount?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    flagReason?: SortOrderInput | SortOrder
    isFlagged?: SortOrder
    isFeatured?: SortOrder
    isPinned?: SortOrder
    allowComments?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    flaggedAt?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    generatedById?: SortOrderInput | SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _avg?: BlogPostAvgOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
    _sum?: BlogPostSumOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    subtitle?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    slug?: StringWithAggregatesFilter<"BlogPost"> | string
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    excerpt?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    format?: EnumContentFormatWithAggregatesFilter<"BlogPost"> | $Enums.ContentFormat
    status?: EnumPostStatusWithAggregatesFilter<"BlogPost"> | $Enums.PostStatus
    visibility?: EnumPostVisibilityWithAggregatesFilter<"BlogPost"> | $Enums.PostVisibility
    featuredImage?: StringWithAggregatesFilter<"BlogPost"> | string
    featuredVideo?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    galleryImages?: StringNullableListFilter<"BlogPost">
    authorId?: StringWithAggregatesFilter<"BlogPost"> | string
    authorBio?: StringWithAggregatesFilter<"BlogPost"> | string
    authorTitle?: StringWithAggregatesFilter<"BlogPost"> | string
    author?: StringWithAggregatesFilter<"BlogPost"> | string
    categoryId?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    seoTitle?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    seoDescription?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    seoKeywords?: StringNullableListFilter<"BlogPost">
    seoScore?: IntWithAggregatesFilter<"BlogPost"> | number
    shares?: IntWithAggregatesFilter<"BlogPost"> | number
    readTime?: IntWithAggregatesFilter<"BlogPost"> | number
    wordCount?: IntWithAggregatesFilter<"BlogPost"> | number
    characterCount?: IntWithAggregatesFilter<"BlogPost"> | number
    likes?: IntWithAggregatesFilter<"BlogPost"> | number
    views?: IntWithAggregatesFilter<"BlogPost"> | number
    flagReason?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    isFlagged?: BoolWithAggregatesFilter<"BlogPost"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"BlogPost"> | boolean
    isPinned?: BoolWithAggregatesFilter<"BlogPost"> | boolean
    allowComments?: BoolWithAggregatesFilter<"BlogPost"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    flaggedAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    generatedById?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
  }

  export type FlagedBlogPostWhereInput = {
    AND?: FlagedBlogPostWhereInput | FlagedBlogPostWhereInput[]
    OR?: FlagedBlogPostWhereInput[]
    NOT?: FlagedBlogPostWhereInput | FlagedBlogPostWhereInput[]
    id?: StringFilter<"FlagedBlogPost"> | string
    reason?: StringFilter<"FlagedBlogPost"> | string
    comment?: StringFilter<"FlagedBlogPost"> | string
    flaggedBy?: StringFilter<"FlagedBlogPost"> | string
    status?: EnumFlagStatusFilter<"FlagedBlogPost"> | $Enums.FlagStatus
    createdAt?: DateTimeFilter<"FlagedBlogPost"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"FlagedBlogPost"> | Date | string | null
    postId?: StringFilter<"FlagedBlogPost"> | string
    userId?: StringFilter<"FlagedBlogPost"> | string
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FlagedBlogPostOrderByWithRelationInput = {
    id?: SortOrder
    reason?: SortOrder
    comment?: SortOrder
    flaggedBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    postId?: SortOrder
    userId?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FlagedBlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlagedBlogPostWhereInput | FlagedBlogPostWhereInput[]
    OR?: FlagedBlogPostWhereInput[]
    NOT?: FlagedBlogPostWhereInput | FlagedBlogPostWhereInput[]
    reason?: StringFilter<"FlagedBlogPost"> | string
    comment?: StringFilter<"FlagedBlogPost"> | string
    flaggedBy?: StringFilter<"FlagedBlogPost"> | string
    status?: EnumFlagStatusFilter<"FlagedBlogPost"> | $Enums.FlagStatus
    createdAt?: DateTimeFilter<"FlagedBlogPost"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"FlagedBlogPost"> | Date | string | null
    postId?: StringFilter<"FlagedBlogPost"> | string
    userId?: StringFilter<"FlagedBlogPost"> | string
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FlagedBlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    reason?: SortOrder
    comment?: SortOrder
    flaggedBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    postId?: SortOrder
    userId?: SortOrder
    _count?: FlagedBlogPostCountOrderByAggregateInput
    _max?: FlagedBlogPostMaxOrderByAggregateInput
    _min?: FlagedBlogPostMinOrderByAggregateInput
  }

  export type FlagedBlogPostScalarWhereWithAggregatesInput = {
    AND?: FlagedBlogPostScalarWhereWithAggregatesInput | FlagedBlogPostScalarWhereWithAggregatesInput[]
    OR?: FlagedBlogPostScalarWhereWithAggregatesInput[]
    NOT?: FlagedBlogPostScalarWhereWithAggregatesInput | FlagedBlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlagedBlogPost"> | string
    reason?: StringWithAggregatesFilter<"FlagedBlogPost"> | string
    comment?: StringWithAggregatesFilter<"FlagedBlogPost"> | string
    flaggedBy?: StringWithAggregatesFilter<"FlagedBlogPost"> | string
    status?: EnumFlagStatusWithAggregatesFilter<"FlagedBlogPost"> | $Enums.FlagStatus
    createdAt?: DateTimeWithAggregatesFilter<"FlagedBlogPost"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"FlagedBlogPost"> | Date | string | null
    postId?: StringWithAggregatesFilter<"FlagedBlogPost"> | string
    userId?: StringWithAggregatesFilter<"FlagedBlogPost"> | string
  }

  export type BlogPostViewWhereInput = {
    AND?: BlogPostViewWhereInput | BlogPostViewWhereInput[]
    OR?: BlogPostViewWhereInput[]
    NOT?: BlogPostViewWhereInput | BlogPostViewWhereInput[]
    id?: StringFilter<"BlogPostView"> | string
    postId?: StringFilter<"BlogPostView"> | string
    userId?: StringNullableFilter<"BlogPostView"> | string | null
    externalName?: StringNullableFilter<"BlogPostView"> | string | null
    createdAt?: DateTimeFilter<"BlogPostView"> | Date | string
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type BlogPostViewOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrderInput | SortOrder
    externalName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BlogPostViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_userId_externalName?: BlogPostViewPostIdUserIdExternalNameCompoundUniqueInput
    AND?: BlogPostViewWhereInput | BlogPostViewWhereInput[]
    OR?: BlogPostViewWhereInput[]
    NOT?: BlogPostViewWhereInput | BlogPostViewWhereInput[]
    postId?: StringFilter<"BlogPostView"> | string
    userId?: StringNullableFilter<"BlogPostView"> | string | null
    externalName?: StringNullableFilter<"BlogPostView"> | string | null
    createdAt?: DateTimeFilter<"BlogPostView"> | Date | string
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "postId_userId_externalName">

  export type BlogPostViewOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrderInput | SortOrder
    externalName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BlogPostViewCountOrderByAggregateInput
    _max?: BlogPostViewMaxOrderByAggregateInput
    _min?: BlogPostViewMinOrderByAggregateInput
  }

  export type BlogPostViewScalarWhereWithAggregatesInput = {
    AND?: BlogPostViewScalarWhereWithAggregatesInput | BlogPostViewScalarWhereWithAggregatesInput[]
    OR?: BlogPostViewScalarWhereWithAggregatesInput[]
    NOT?: BlogPostViewScalarWhereWithAggregatesInput | BlogPostViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPostView"> | string
    postId?: StringWithAggregatesFilter<"BlogPostView"> | string
    userId?: StringNullableWithAggregatesFilter<"BlogPostView"> | string | null
    externalName?: StringNullableWithAggregatesFilter<"BlogPostView"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogPostView"> | Date | string
  }

  export type BlogCategoryWhereInput = {
    AND?: BlogCategoryWhereInput | BlogCategoryWhereInput[]
    OR?: BlogCategoryWhereInput[]
    NOT?: BlogCategoryWhereInput | BlogCategoryWhereInput[]
    id?: StringFilter<"BlogCategory"> | string
    name?: StringFilter<"BlogCategory"> | string
    description?: StringNullableFilter<"BlogCategory"> | string | null
    createdAt?: DateTimeFilter<"BlogCategory"> | Date | string
    updatedAt?: DateTimeFilter<"BlogCategory"> | Date | string
    posts?: BlogPostListRelationFilter
  }

  export type BlogCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: BlogPostOrderByRelationAggregateInput
  }

  export type BlogCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BlogCategoryWhereInput | BlogCategoryWhereInput[]
    OR?: BlogCategoryWhereInput[]
    NOT?: BlogCategoryWhereInput | BlogCategoryWhereInput[]
    description?: StringNullableFilter<"BlogCategory"> | string | null
    createdAt?: DateTimeFilter<"BlogCategory"> | Date | string
    updatedAt?: DateTimeFilter<"BlogCategory"> | Date | string
    posts?: BlogPostListRelationFilter
  }, "id" | "name">

  export type BlogCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogCategoryCountOrderByAggregateInput
    _max?: BlogCategoryMaxOrderByAggregateInput
    _min?: BlogCategoryMinOrderByAggregateInput
  }

  export type BlogCategoryScalarWhereWithAggregatesInput = {
    AND?: BlogCategoryScalarWhereWithAggregatesInput | BlogCategoryScalarWhereWithAggregatesInput[]
    OR?: BlogCategoryScalarWhereWithAggregatesInput[]
    NOT?: BlogCategoryScalarWhereWithAggregatesInput | BlogCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogCategory"> | string
    name?: StringWithAggregatesFilter<"BlogCategory"> | string
    description?: StringNullableWithAggregatesFilter<"BlogCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogCategory"> | Date | string
  }

  export type BlogTagWhereInput = {
    AND?: BlogTagWhereInput | BlogTagWhereInput[]
    OR?: BlogTagWhereInput[]
    NOT?: BlogTagWhereInput | BlogTagWhereInput[]
    id?: StringFilter<"BlogTag"> | string
    name?: StringFilter<"BlogTag"> | string
    createdAt?: DateTimeFilter<"BlogTag"> | Date | string
    updatedAt?: DateTimeFilter<"BlogTag"> | Date | string
    posts?: BlogPostListRelationFilter
  }

  export type BlogTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: BlogPostOrderByRelationAggregateInput
  }

  export type BlogTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BlogTagWhereInput | BlogTagWhereInput[]
    OR?: BlogTagWhereInput[]
    NOT?: BlogTagWhereInput | BlogTagWhereInput[]
    createdAt?: DateTimeFilter<"BlogTag"> | Date | string
    updatedAt?: DateTimeFilter<"BlogTag"> | Date | string
    posts?: BlogPostListRelationFilter
  }, "id" | "name">

  export type BlogTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogTagCountOrderByAggregateInput
    _max?: BlogTagMaxOrderByAggregateInput
    _min?: BlogTagMinOrderByAggregateInput
  }

  export type BlogTagScalarWhereWithAggregatesInput = {
    AND?: BlogTagScalarWhereWithAggregatesInput | BlogTagScalarWhereWithAggregatesInput[]
    OR?: BlogTagScalarWhereWithAggregatesInput[]
    NOT?: BlogTagScalarWhereWithAggregatesInput | BlogTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogTag"> | string
    name?: StringWithAggregatesFilter<"BlogTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlogTag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogTag"> | Date | string
  }

  export type BlogCommentWhereInput = {
    AND?: BlogCommentWhereInput | BlogCommentWhereInput[]
    OR?: BlogCommentWhereInput[]
    NOT?: BlogCommentWhereInput | BlogCommentWhereInput[]
    id?: StringFilter<"BlogComment"> | string
    content?: StringFilter<"BlogComment"> | string
    authorId?: StringFilter<"BlogComment"> | string
    postId?: StringFilter<"BlogComment"> | string
    userId?: StringNullableFilter<"BlogComment"> | string | null
    parentId?: StringNullableFilter<"BlogComment"> | string | null
    externalName?: StringNullableFilter<"BlogComment"> | string | null
    externalAvatar?: StringNullableFilter<"BlogComment"> | string | null
    likes?: IntFilter<"BlogComment"> | number
    status?: StringFilter<"BlogComment"> | string
    createdAt?: DateTimeFilter<"BlogComment"> | Date | string
    updatedAt?: DateTimeFilter<"BlogComment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<BlogCommentNullableScalarRelationFilter, BlogCommentWhereInput> | null
    replies?: BlogCommentListRelationFilter
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
    reportedComments?: ReportedCommentListRelationFilter
  }

  export type BlogCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    postId?: SortOrder
    userId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    externalName?: SortOrderInput | SortOrder
    externalAvatar?: SortOrderInput | SortOrder
    likes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    parent?: BlogCommentOrderByWithRelationInput
    replies?: BlogCommentOrderByRelationAggregateInput
    post?: BlogPostOrderByWithRelationInput
    reportedComments?: ReportedCommentOrderByRelationAggregateInput
  }

  export type BlogCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlogCommentWhereInput | BlogCommentWhereInput[]
    OR?: BlogCommentWhereInput[]
    NOT?: BlogCommentWhereInput | BlogCommentWhereInput[]
    content?: StringFilter<"BlogComment"> | string
    authorId?: StringFilter<"BlogComment"> | string
    postId?: StringFilter<"BlogComment"> | string
    userId?: StringNullableFilter<"BlogComment"> | string | null
    parentId?: StringNullableFilter<"BlogComment"> | string | null
    externalName?: StringNullableFilter<"BlogComment"> | string | null
    externalAvatar?: StringNullableFilter<"BlogComment"> | string | null
    likes?: IntFilter<"BlogComment"> | number
    status?: StringFilter<"BlogComment"> | string
    createdAt?: DateTimeFilter<"BlogComment"> | Date | string
    updatedAt?: DateTimeFilter<"BlogComment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<BlogCommentNullableScalarRelationFilter, BlogCommentWhereInput> | null
    replies?: BlogCommentListRelationFilter
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
    reportedComments?: ReportedCommentListRelationFilter
  }, "id">

  export type BlogCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    postId?: SortOrder
    userId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    externalName?: SortOrderInput | SortOrder
    externalAvatar?: SortOrderInput | SortOrder
    likes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogCommentCountOrderByAggregateInput
    _avg?: BlogCommentAvgOrderByAggregateInput
    _max?: BlogCommentMaxOrderByAggregateInput
    _min?: BlogCommentMinOrderByAggregateInput
    _sum?: BlogCommentSumOrderByAggregateInput
  }

  export type BlogCommentScalarWhereWithAggregatesInput = {
    AND?: BlogCommentScalarWhereWithAggregatesInput | BlogCommentScalarWhereWithAggregatesInput[]
    OR?: BlogCommentScalarWhereWithAggregatesInput[]
    NOT?: BlogCommentScalarWhereWithAggregatesInput | BlogCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogComment"> | string
    content?: StringWithAggregatesFilter<"BlogComment"> | string
    authorId?: StringWithAggregatesFilter<"BlogComment"> | string
    postId?: StringWithAggregatesFilter<"BlogComment"> | string
    userId?: StringNullableWithAggregatesFilter<"BlogComment"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"BlogComment"> | string | null
    externalName?: StringNullableWithAggregatesFilter<"BlogComment"> | string | null
    externalAvatar?: StringNullableWithAggregatesFilter<"BlogComment"> | string | null
    likes?: IntWithAggregatesFilter<"BlogComment"> | number
    status?: StringWithAggregatesFilter<"BlogComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlogComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogComment"> | Date | string
  }

  export type ReportedCommentWhereInput = {
    AND?: ReportedCommentWhereInput | ReportedCommentWhereInput[]
    OR?: ReportedCommentWhereInput[]
    NOT?: ReportedCommentWhereInput | ReportedCommentWhereInput[]
    id?: StringFilter<"ReportedComment"> | string
    commentId?: StringFilter<"ReportedComment"> | string
    blogSlug?: StringFilter<"ReportedComment"> | string
    blogOwner?: StringFilter<"ReportedComment"> | string
    parentCommentBy?: StringFilter<"ReportedComment"> | string
    reportedBy?: StringFilter<"ReportedComment"> | string
    reason?: StringNullableFilter<"ReportedComment"> | string | null
    reportedAt?: DateTimeFilter<"ReportedComment"> | Date | string
    resolved?: BoolFilter<"ReportedComment"> | boolean
    comment?: XOR<BlogCommentScalarRelationFilter, BlogCommentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReportedCommentOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    blogSlug?: SortOrder
    blogOwner?: SortOrder
    parentCommentBy?: SortOrder
    reportedBy?: SortOrder
    reason?: SortOrderInput | SortOrder
    reportedAt?: SortOrder
    resolved?: SortOrder
    comment?: BlogCommentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReportedCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportedCommentWhereInput | ReportedCommentWhereInput[]
    OR?: ReportedCommentWhereInput[]
    NOT?: ReportedCommentWhereInput | ReportedCommentWhereInput[]
    commentId?: StringFilter<"ReportedComment"> | string
    blogSlug?: StringFilter<"ReportedComment"> | string
    blogOwner?: StringFilter<"ReportedComment"> | string
    parentCommentBy?: StringFilter<"ReportedComment"> | string
    reportedBy?: StringFilter<"ReportedComment"> | string
    reason?: StringNullableFilter<"ReportedComment"> | string | null
    reportedAt?: DateTimeFilter<"ReportedComment"> | Date | string
    resolved?: BoolFilter<"ReportedComment"> | boolean
    comment?: XOR<BlogCommentScalarRelationFilter, BlogCommentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReportedCommentOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    blogSlug?: SortOrder
    blogOwner?: SortOrder
    parentCommentBy?: SortOrder
    reportedBy?: SortOrder
    reason?: SortOrderInput | SortOrder
    reportedAt?: SortOrder
    resolved?: SortOrder
    _count?: ReportedCommentCountOrderByAggregateInput
    _max?: ReportedCommentMaxOrderByAggregateInput
    _min?: ReportedCommentMinOrderByAggregateInput
  }

  export type ReportedCommentScalarWhereWithAggregatesInput = {
    AND?: ReportedCommentScalarWhereWithAggregatesInput | ReportedCommentScalarWhereWithAggregatesInput[]
    OR?: ReportedCommentScalarWhereWithAggregatesInput[]
    NOT?: ReportedCommentScalarWhereWithAggregatesInput | ReportedCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportedComment"> | string
    commentId?: StringWithAggregatesFilter<"ReportedComment"> | string
    blogSlug?: StringWithAggregatesFilter<"ReportedComment"> | string
    blogOwner?: StringWithAggregatesFilter<"ReportedComment"> | string
    parentCommentBy?: StringWithAggregatesFilter<"ReportedComment"> | string
    reportedBy?: StringWithAggregatesFilter<"ReportedComment"> | string
    reason?: StringNullableWithAggregatesFilter<"ReportedComment"> | string | null
    reportedAt?: DateTimeWithAggregatesFilter<"ReportedComment"> | Date | string
    resolved?: BoolWithAggregatesFilter<"ReportedComment"> | boolean
  }

  export type BlogAIGenerationWhereInput = {
    AND?: BlogAIGenerationWhereInput | BlogAIGenerationWhereInput[]
    OR?: BlogAIGenerationWhereInput[]
    NOT?: BlogAIGenerationWhereInput | BlogAIGenerationWhereInput[]
    id?: StringFilter<"BlogAIGeneration"> | string
    prompt?: StringFilter<"BlogAIGeneration"> | string
    parameters?: JsonNullableFilter<"BlogAIGeneration">
    status?: EnumAIGenerationStatusFilter<"BlogAIGeneration"> | $Enums.AIGenerationStatus
    output?: StringFilter<"BlogAIGeneration"> | string
    format?: EnumContentFormatFilter<"BlogAIGeneration"> | $Enums.ContentFormat
    cost?: FloatNullableFilter<"BlogAIGeneration"> | number | null
    tokensUsed?: IntNullableFilter<"BlogAIGeneration"> | number | null
    model?: StringNullableFilter<"BlogAIGeneration"> | string | null
    userId?: StringFilter<"BlogAIGeneration"> | string
    createdAt?: DateTimeFilter<"BlogAIGeneration"> | Date | string
    completedAt?: DateTimeNullableFilter<"BlogAIGeneration"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    blogPosts?: BlogPostListRelationFilter
  }

  export type BlogAIGenerationOrderByWithRelationInput = {
    id?: SortOrder
    prompt?: SortOrder
    parameters?: SortOrderInput | SortOrder
    status?: SortOrder
    output?: SortOrder
    format?: SortOrder
    cost?: SortOrderInput | SortOrder
    tokensUsed?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    blogPosts?: BlogPostOrderByRelationAggregateInput
  }

  export type BlogAIGenerationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlogAIGenerationWhereInput | BlogAIGenerationWhereInput[]
    OR?: BlogAIGenerationWhereInput[]
    NOT?: BlogAIGenerationWhereInput | BlogAIGenerationWhereInput[]
    prompt?: StringFilter<"BlogAIGeneration"> | string
    parameters?: JsonNullableFilter<"BlogAIGeneration">
    status?: EnumAIGenerationStatusFilter<"BlogAIGeneration"> | $Enums.AIGenerationStatus
    output?: StringFilter<"BlogAIGeneration"> | string
    format?: EnumContentFormatFilter<"BlogAIGeneration"> | $Enums.ContentFormat
    cost?: FloatNullableFilter<"BlogAIGeneration"> | number | null
    tokensUsed?: IntNullableFilter<"BlogAIGeneration"> | number | null
    model?: StringNullableFilter<"BlogAIGeneration"> | string | null
    userId?: StringFilter<"BlogAIGeneration"> | string
    createdAt?: DateTimeFilter<"BlogAIGeneration"> | Date | string
    completedAt?: DateTimeNullableFilter<"BlogAIGeneration"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    blogPosts?: BlogPostListRelationFilter
  }, "id">

  export type BlogAIGenerationOrderByWithAggregationInput = {
    id?: SortOrder
    prompt?: SortOrder
    parameters?: SortOrderInput | SortOrder
    status?: SortOrder
    output?: SortOrder
    format?: SortOrder
    cost?: SortOrderInput | SortOrder
    tokensUsed?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: BlogAIGenerationCountOrderByAggregateInput
    _avg?: BlogAIGenerationAvgOrderByAggregateInput
    _max?: BlogAIGenerationMaxOrderByAggregateInput
    _min?: BlogAIGenerationMinOrderByAggregateInput
    _sum?: BlogAIGenerationSumOrderByAggregateInput
  }

  export type BlogAIGenerationScalarWhereWithAggregatesInput = {
    AND?: BlogAIGenerationScalarWhereWithAggregatesInput | BlogAIGenerationScalarWhereWithAggregatesInput[]
    OR?: BlogAIGenerationScalarWhereWithAggregatesInput[]
    NOT?: BlogAIGenerationScalarWhereWithAggregatesInput | BlogAIGenerationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogAIGeneration"> | string
    prompt?: StringWithAggregatesFilter<"BlogAIGeneration"> | string
    parameters?: JsonNullableWithAggregatesFilter<"BlogAIGeneration">
    status?: EnumAIGenerationStatusWithAggregatesFilter<"BlogAIGeneration"> | $Enums.AIGenerationStatus
    output?: StringWithAggregatesFilter<"BlogAIGeneration"> | string
    format?: EnumContentFormatWithAggregatesFilter<"BlogAIGeneration"> | $Enums.ContentFormat
    cost?: FloatNullableWithAggregatesFilter<"BlogAIGeneration"> | number | null
    tokensUsed?: IntNullableWithAggregatesFilter<"BlogAIGeneration"> | number | null
    model?: StringNullableWithAggregatesFilter<"BlogAIGeneration"> | string | null
    userId?: StringWithAggregatesFilter<"BlogAIGeneration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlogAIGeneration"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"BlogAIGeneration"> | Date | string | null
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    userId?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    type?: StringNullableFilter<"Campaign"> | string | null
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    emailsSent?: IntFilter<"Campaign"> | number
    recipients?: IntNullableFilter<"Campaign"> | number | null
    openRate?: FloatNullableFilter<"Campaign"> | number | null
    clickRate?: FloatNullableFilter<"Campaign"> | number | null
    lastSentAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    emails?: EmailListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailsSent?: SortOrder
    recipients?: SortOrderInput | SortOrder
    openRate?: SortOrderInput | SortOrder
    clickRate?: SortOrderInput | SortOrder
    lastSentAt?: SortOrderInput | SortOrder
    emails?: EmailOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    userId?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    type?: StringNullableFilter<"Campaign"> | string | null
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    emailsSent?: IntFilter<"Campaign"> | number
    recipients?: IntNullableFilter<"Campaign"> | number | null
    openRate?: FloatNullableFilter<"Campaign"> | number | null
    clickRate?: FloatNullableFilter<"Campaign"> | number | null
    lastSentAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    emails?: EmailListRelationFilter
  }, "id" | "name">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailsSent?: SortOrder
    recipients?: SortOrderInput | SortOrder
    openRate?: SortOrderInput | SortOrder
    clickRate?: SortOrderInput | SortOrder
    lastSentAt?: SortOrderInput | SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    userId?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    type?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    status?: EnumCampaignStatusWithAggregatesFilter<"Campaign"> | $Enums.CampaignStatus
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    emailsSent?: IntWithAggregatesFilter<"Campaign"> | number
    recipients?: IntNullableWithAggregatesFilter<"Campaign"> | number | null
    openRate?: FloatNullableWithAggregatesFilter<"Campaign"> | number | null
    clickRate?: FloatNullableWithAggregatesFilter<"Campaign"> | number | null
    lastSentAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
  }

  export type SubscriberWhereInput = {
    AND?: SubscriberWhereInput | SubscriberWhereInput[]
    OR?: SubscriberWhereInput[]
    NOT?: SubscriberWhereInput | SubscriberWhereInput[]
    id?: StringFilter<"Subscriber"> | string
    email?: StringFilter<"Subscriber"> | string
    name?: StringNullableFilter<"Subscriber"> | string | null
    newsLetterOwnerId?: StringFilter<"Subscriber"> | string
    source?: StringFilter<"Subscriber"> | string
    status?: EnumSubscriptionStatusFilter<"Subscriber"> | $Enums.SubscriptionStatus
    campaignId?: StringNullableFilter<"Subscriber"> | string | null
    pageUrl?: StringNullableFilter<"Subscriber"> | string | null
    createdAt?: DateTimeFilter<"Subscriber"> | Date | string
    updatedAt?: DateTimeFilter<"Subscriber"> | Date | string
  }

  export type SubscriberOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    newsLetterOwnerId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    pageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unique_subscriber_key?: SubscriberUnique_subscriber_keyCompoundUniqueInput
    AND?: SubscriberWhereInput | SubscriberWhereInput[]
    OR?: SubscriberWhereInput[]
    NOT?: SubscriberWhereInput | SubscriberWhereInput[]
    email?: StringFilter<"Subscriber"> | string
    name?: StringNullableFilter<"Subscriber"> | string | null
    newsLetterOwnerId?: StringFilter<"Subscriber"> | string
    source?: StringFilter<"Subscriber"> | string
    status?: EnumSubscriptionStatusFilter<"Subscriber"> | $Enums.SubscriptionStatus
    campaignId?: StringNullableFilter<"Subscriber"> | string | null
    pageUrl?: StringNullableFilter<"Subscriber"> | string | null
    createdAt?: DateTimeFilter<"Subscriber"> | Date | string
    updatedAt?: DateTimeFilter<"Subscriber"> | Date | string
  }, "id" | "unique_subscriber_key">

  export type SubscriberOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    newsLetterOwnerId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    pageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriberCountOrderByAggregateInput
    _max?: SubscriberMaxOrderByAggregateInput
    _min?: SubscriberMinOrderByAggregateInput
  }

  export type SubscriberScalarWhereWithAggregatesInput = {
    AND?: SubscriberScalarWhereWithAggregatesInput | SubscriberScalarWhereWithAggregatesInput[]
    OR?: SubscriberScalarWhereWithAggregatesInput[]
    NOT?: SubscriberScalarWhereWithAggregatesInput | SubscriberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscriber"> | string
    email?: StringWithAggregatesFilter<"Subscriber"> | string
    name?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    newsLetterOwnerId?: StringWithAggregatesFilter<"Subscriber"> | string
    source?: StringWithAggregatesFilter<"Subscriber"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscriber"> | $Enums.SubscriptionStatus
    campaignId?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    pageUrl?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscriber"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscriber"> | Date | string
  }

  export type EmailNotificationWhereInput = {
    AND?: EmailNotificationWhereInput | EmailNotificationWhereInput[]
    OR?: EmailNotificationWhereInput[]
    NOT?: EmailNotificationWhereInput | EmailNotificationWhereInput[]
    id?: StringFilter<"EmailNotification"> | string
    type?: EnumNotificationTypeFilter<"EmailNotification"> | $Enums.NotificationType
    category?: EnumNotificationCategoryFilter<"EmailNotification"> | $Enums.NotificationCategory
    title?: StringFilter<"EmailNotification"> | string
    content?: JsonFilter<"EmailNotification">
    textContent?: StringNullableFilter<"EmailNotification"> | string | null
    htmlContent?: StringNullableFilter<"EmailNotification"> | string | null
    status?: EnumNotificationStatusFilter<"EmailNotification"> | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityFilter<"EmailNotification"> | $Enums.NotificationPriority
    userId?: StringFilter<"EmailNotification"> | string
    emailsSentCount?: IntNullableFilter<"EmailNotification"> | number | null
    openCount?: IntNullableFilter<"EmailNotification"> | number | null
    clickCount?: IntNullableFilter<"EmailNotification"> | number | null
    recipients?: IntNullableFilter<"EmailNotification"> | number | null
    bounceCount?: IntNullableFilter<"EmailNotification"> | number | null
    openedByEmails?: StringNullableListFilter<"EmailNotification">
    clickedByEmails?: StringNullableListFilter<"EmailNotification">
    lastOpened?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    lastClicked?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    metadata?: JsonNullableFilter<"EmailNotification">
    sentAt?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailNotification"> | Date | string
    updatedAt?: DateTimeFilter<"EmailNotification"> | Date | string
    read?: BoolFilter<"EmailNotification"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    NotificationEmailClickedLink?: NotificationEmailClickedLinkListRelationFilter
  }

  export type EmailNotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    textContent?: SortOrderInput | SortOrder
    htmlContent?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    emailsSentCount?: SortOrderInput | SortOrder
    openCount?: SortOrderInput | SortOrder
    clickCount?: SortOrderInput | SortOrder
    recipients?: SortOrderInput | SortOrder
    bounceCount?: SortOrderInput | SortOrder
    openedByEmails?: SortOrder
    clickedByEmails?: SortOrder
    lastOpened?: SortOrderInput | SortOrder
    lastClicked?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
    user?: UserOrderByWithRelationInput
    NotificationEmailClickedLink?: NotificationEmailClickedLinkOrderByRelationAggregateInput
  }

  export type EmailNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailNotificationWhereInput | EmailNotificationWhereInput[]
    OR?: EmailNotificationWhereInput[]
    NOT?: EmailNotificationWhereInput | EmailNotificationWhereInput[]
    type?: EnumNotificationTypeFilter<"EmailNotification"> | $Enums.NotificationType
    category?: EnumNotificationCategoryFilter<"EmailNotification"> | $Enums.NotificationCategory
    title?: StringFilter<"EmailNotification"> | string
    content?: JsonFilter<"EmailNotification">
    textContent?: StringNullableFilter<"EmailNotification"> | string | null
    htmlContent?: StringNullableFilter<"EmailNotification"> | string | null
    status?: EnumNotificationStatusFilter<"EmailNotification"> | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityFilter<"EmailNotification"> | $Enums.NotificationPriority
    userId?: StringFilter<"EmailNotification"> | string
    emailsSentCount?: IntNullableFilter<"EmailNotification"> | number | null
    openCount?: IntNullableFilter<"EmailNotification"> | number | null
    clickCount?: IntNullableFilter<"EmailNotification"> | number | null
    recipients?: IntNullableFilter<"EmailNotification"> | number | null
    bounceCount?: IntNullableFilter<"EmailNotification"> | number | null
    openedByEmails?: StringNullableListFilter<"EmailNotification">
    clickedByEmails?: StringNullableListFilter<"EmailNotification">
    lastOpened?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    lastClicked?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    metadata?: JsonNullableFilter<"EmailNotification">
    sentAt?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailNotification"> | Date | string
    updatedAt?: DateTimeFilter<"EmailNotification"> | Date | string
    read?: BoolFilter<"EmailNotification"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    NotificationEmailClickedLink?: NotificationEmailClickedLinkListRelationFilter
  }, "id">

  export type EmailNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    textContent?: SortOrderInput | SortOrder
    htmlContent?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    emailsSentCount?: SortOrderInput | SortOrder
    openCount?: SortOrderInput | SortOrder
    clickCount?: SortOrderInput | SortOrder
    recipients?: SortOrderInput | SortOrder
    bounceCount?: SortOrderInput | SortOrder
    openedByEmails?: SortOrder
    clickedByEmails?: SortOrder
    lastOpened?: SortOrderInput | SortOrder
    lastClicked?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
    _count?: EmailNotificationCountOrderByAggregateInput
    _avg?: EmailNotificationAvgOrderByAggregateInput
    _max?: EmailNotificationMaxOrderByAggregateInput
    _min?: EmailNotificationMinOrderByAggregateInput
    _sum?: EmailNotificationSumOrderByAggregateInput
  }

  export type EmailNotificationScalarWhereWithAggregatesInput = {
    AND?: EmailNotificationScalarWhereWithAggregatesInput | EmailNotificationScalarWhereWithAggregatesInput[]
    OR?: EmailNotificationScalarWhereWithAggregatesInput[]
    NOT?: EmailNotificationScalarWhereWithAggregatesInput | EmailNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailNotification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"EmailNotification"> | $Enums.NotificationType
    category?: EnumNotificationCategoryWithAggregatesFilter<"EmailNotification"> | $Enums.NotificationCategory
    title?: StringWithAggregatesFilter<"EmailNotification"> | string
    content?: JsonWithAggregatesFilter<"EmailNotification">
    textContent?: StringNullableWithAggregatesFilter<"EmailNotification"> | string | null
    htmlContent?: StringNullableWithAggregatesFilter<"EmailNotification"> | string | null
    status?: EnumNotificationStatusWithAggregatesFilter<"EmailNotification"> | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityWithAggregatesFilter<"EmailNotification"> | $Enums.NotificationPriority
    userId?: StringWithAggregatesFilter<"EmailNotification"> | string
    emailsSentCount?: IntNullableWithAggregatesFilter<"EmailNotification"> | number | null
    openCount?: IntNullableWithAggregatesFilter<"EmailNotification"> | number | null
    clickCount?: IntNullableWithAggregatesFilter<"EmailNotification"> | number | null
    recipients?: IntNullableWithAggregatesFilter<"EmailNotification"> | number | null
    bounceCount?: IntNullableWithAggregatesFilter<"EmailNotification"> | number | null
    openedByEmails?: StringNullableListFilter<"EmailNotification">
    clickedByEmails?: StringNullableListFilter<"EmailNotification">
    lastOpened?: DateTimeNullableWithAggregatesFilter<"EmailNotification"> | Date | string | null
    lastClicked?: DateTimeNullableWithAggregatesFilter<"EmailNotification"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"EmailNotification">
    sentAt?: DateTimeNullableWithAggregatesFilter<"EmailNotification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailNotification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailNotification"> | Date | string
    read?: BoolWithAggregatesFilter<"EmailNotification"> | boolean
  }

  export type ClickedLinkWhereInput = {
    AND?: ClickedLinkWhereInput | ClickedLinkWhereInput[]
    OR?: ClickedLinkWhereInput[]
    NOT?: ClickedLinkWhereInput | ClickedLinkWhereInput[]
    id?: StringFilter<"ClickedLink"> | string
    emailId?: StringFilter<"ClickedLink"> | string
    url?: StringFilter<"ClickedLink"> | string
    clickedAt?: DateTimeFilter<"ClickedLink"> | Date | string
    clickedBy?: StringNullableFilter<"ClickedLink"> | string | null
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }

  export type ClickedLinkOrderByWithRelationInput = {
    id?: SortOrder
    emailId?: SortOrder
    url?: SortOrder
    clickedAt?: SortOrder
    clickedBy?: SortOrderInput | SortOrder
    email?: EmailOrderByWithRelationInput
  }

  export type ClickedLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClickedLinkWhereInput | ClickedLinkWhereInput[]
    OR?: ClickedLinkWhereInput[]
    NOT?: ClickedLinkWhereInput | ClickedLinkWhereInput[]
    emailId?: StringFilter<"ClickedLink"> | string
    url?: StringFilter<"ClickedLink"> | string
    clickedAt?: DateTimeFilter<"ClickedLink"> | Date | string
    clickedBy?: StringNullableFilter<"ClickedLink"> | string | null
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }, "id">

  export type ClickedLinkOrderByWithAggregationInput = {
    id?: SortOrder
    emailId?: SortOrder
    url?: SortOrder
    clickedAt?: SortOrder
    clickedBy?: SortOrderInput | SortOrder
    _count?: ClickedLinkCountOrderByAggregateInput
    _max?: ClickedLinkMaxOrderByAggregateInput
    _min?: ClickedLinkMinOrderByAggregateInput
  }

  export type ClickedLinkScalarWhereWithAggregatesInput = {
    AND?: ClickedLinkScalarWhereWithAggregatesInput | ClickedLinkScalarWhereWithAggregatesInput[]
    OR?: ClickedLinkScalarWhereWithAggregatesInput[]
    NOT?: ClickedLinkScalarWhereWithAggregatesInput | ClickedLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClickedLink"> | string
    emailId?: StringWithAggregatesFilter<"ClickedLink"> | string
    url?: StringWithAggregatesFilter<"ClickedLink"> | string
    clickedAt?: DateTimeWithAggregatesFilter<"ClickedLink"> | Date | string
    clickedBy?: StringNullableWithAggregatesFilter<"ClickedLink"> | string | null
  }

  export type NotificationEmailClickedLinkWhereInput = {
    AND?: NotificationEmailClickedLinkWhereInput | NotificationEmailClickedLinkWhereInput[]
    OR?: NotificationEmailClickedLinkWhereInput[]
    NOT?: NotificationEmailClickedLinkWhereInput | NotificationEmailClickedLinkWhereInput[]
    id?: StringFilter<"NotificationEmailClickedLink"> | string
    notificationEmailId?: StringNullableFilter<"NotificationEmailClickedLink"> | string | null
    url?: StringFilter<"NotificationEmailClickedLink"> | string
    clickedAt?: DateTimeFilter<"NotificationEmailClickedLink"> | Date | string
    clickedBy?: StringNullableFilter<"NotificationEmailClickedLink"> | string | null
    notificationEmail?: XOR<EmailNotificationNullableScalarRelationFilter, EmailNotificationWhereInput> | null
  }

  export type NotificationEmailClickedLinkOrderByWithRelationInput = {
    id?: SortOrder
    notificationEmailId?: SortOrderInput | SortOrder
    url?: SortOrder
    clickedAt?: SortOrder
    clickedBy?: SortOrderInput | SortOrder
    notificationEmail?: EmailNotificationOrderByWithRelationInput
  }

  export type NotificationEmailClickedLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationEmailClickedLinkWhereInput | NotificationEmailClickedLinkWhereInput[]
    OR?: NotificationEmailClickedLinkWhereInput[]
    NOT?: NotificationEmailClickedLinkWhereInput | NotificationEmailClickedLinkWhereInput[]
    notificationEmailId?: StringNullableFilter<"NotificationEmailClickedLink"> | string | null
    url?: StringFilter<"NotificationEmailClickedLink"> | string
    clickedAt?: DateTimeFilter<"NotificationEmailClickedLink"> | Date | string
    clickedBy?: StringNullableFilter<"NotificationEmailClickedLink"> | string | null
    notificationEmail?: XOR<EmailNotificationNullableScalarRelationFilter, EmailNotificationWhereInput> | null
  }, "id">

  export type NotificationEmailClickedLinkOrderByWithAggregationInput = {
    id?: SortOrder
    notificationEmailId?: SortOrderInput | SortOrder
    url?: SortOrder
    clickedAt?: SortOrder
    clickedBy?: SortOrderInput | SortOrder
    _count?: NotificationEmailClickedLinkCountOrderByAggregateInput
    _max?: NotificationEmailClickedLinkMaxOrderByAggregateInput
    _min?: NotificationEmailClickedLinkMinOrderByAggregateInput
  }

  export type NotificationEmailClickedLinkScalarWhereWithAggregatesInput = {
    AND?: NotificationEmailClickedLinkScalarWhereWithAggregatesInput | NotificationEmailClickedLinkScalarWhereWithAggregatesInput[]
    OR?: NotificationEmailClickedLinkScalarWhereWithAggregatesInput[]
    NOT?: NotificationEmailClickedLinkScalarWhereWithAggregatesInput | NotificationEmailClickedLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationEmailClickedLink"> | string
    notificationEmailId?: StringNullableWithAggregatesFilter<"NotificationEmailClickedLink"> | string | null
    url?: StringWithAggregatesFilter<"NotificationEmailClickedLink"> | string
    clickedAt?: DateTimeWithAggregatesFilter<"NotificationEmailClickedLink"> | Date | string
    clickedBy?: StringNullableWithAggregatesFilter<"NotificationEmailClickedLink"> | string | null
  }

  export type EmailWhereInput = {
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    id?: StringFilter<"Email"> | string
    title?: StringFilter<"Email"> | string
    content?: StringFilter<"Email"> | string
    emailSubject?: StringFilter<"Email"> | string
    previewText?: StringNullableFilter<"Email"> | string | null
    builderMode?: StringFilter<"Email"> | string
    builderData?: JsonNullableFilter<"Email">
    templateUsed?: StringNullableFilter<"Email"> | string | null
    status?: EnumEmailStatusFilter<"Email"> | $Enums.EmailStatus
    emailType?: EnumEmailTypeFilter<"Email"> | $Enums.EmailType
    trackOpens?: BoolFilter<"Email"> | boolean
    trackClicks?: BoolFilter<"Email"> | boolean
    enableUnsubscribe?: BoolFilter<"Email"> | boolean
    scheduleDate?: DateTimeNullableFilter<"Email"> | Date | string | null
    scheduleTime?: StringNullableFilter<"Email"> | string | null
    emailsSentCount?: IntFilter<"Email"> | number
    recipients?: IntFilter<"Email"> | number
    bounceCount?: IntFilter<"Email"> | number
    openCount?: IntFilter<"Email"> | number
    clickCount?: IntFilter<"Email"> | number
    sentAt?: DateTimeNullableFilter<"Email"> | Date | string | null
    lastOpened?: DateTimeNullableFilter<"Email"> | Date | string | null
    lastClicked?: DateTimeNullableFilter<"Email"> | Date | string | null
    openedByIps?: StringNullableListFilter<"Email">
    openedByEmails?: StringNullableListFilter<"Email">
    clickedByIps?: StringNullableListFilter<"Email">
    clickedByEmails?: StringNullableListFilter<"Email">
    createdAt?: DateTimeFilter<"Email"> | Date | string
    updatedAt?: DateTimeFilter<"Email"> | Date | string
    userId?: StringFilter<"Email"> | string
    newsLetterOwnerId?: StringFilter<"Email"> | string
    campaignId?: StringNullableFilter<"Email"> | string | null
    messageId?: StringNullableFilter<"Email"> | string | null
    elements?: EmailElementListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    clickedLinks?: ClickedLinkListRelationFilter
    emailAttachments?: EmailAttachmentListRelationFilter
    emailRecipients?: EmailRecipientListRelationFilter
    template?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    emailAnalytics?: XOR<EmailAnalyticsNullableScalarRelationFilter, EmailAnalyticsWhereInput> | null
  }

  export type EmailOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    emailSubject?: SortOrder
    previewText?: SortOrderInput | SortOrder
    builderMode?: SortOrder
    builderData?: SortOrderInput | SortOrder
    templateUsed?: SortOrderInput | SortOrder
    status?: SortOrder
    emailType?: SortOrder
    trackOpens?: SortOrder
    trackClicks?: SortOrder
    enableUnsubscribe?: SortOrder
    scheduleDate?: SortOrderInput | SortOrder
    scheduleTime?: SortOrderInput | SortOrder
    emailsSentCount?: SortOrder
    recipients?: SortOrder
    bounceCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    lastOpened?: SortOrderInput | SortOrder
    lastClicked?: SortOrderInput | SortOrder
    openedByIps?: SortOrder
    openedByEmails?: SortOrder
    clickedByIps?: SortOrder
    clickedByEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    newsLetterOwnerId?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    elements?: EmailElementOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
    clickedLinks?: ClickedLinkOrderByRelationAggregateInput
    emailAttachments?: EmailAttachmentOrderByRelationAggregateInput
    emailRecipients?: EmailRecipientOrderByRelationAggregateInput
    template?: EmailTemplateOrderByWithRelationInput
    emailAnalytics?: EmailAnalyticsOrderByWithRelationInput
  }

  export type EmailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    messageId?: string
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    content?: StringFilter<"Email"> | string
    emailSubject?: StringFilter<"Email"> | string
    previewText?: StringNullableFilter<"Email"> | string | null
    builderMode?: StringFilter<"Email"> | string
    builderData?: JsonNullableFilter<"Email">
    templateUsed?: StringNullableFilter<"Email"> | string | null
    status?: EnumEmailStatusFilter<"Email"> | $Enums.EmailStatus
    emailType?: EnumEmailTypeFilter<"Email"> | $Enums.EmailType
    trackOpens?: BoolFilter<"Email"> | boolean
    trackClicks?: BoolFilter<"Email"> | boolean
    enableUnsubscribe?: BoolFilter<"Email"> | boolean
    scheduleDate?: DateTimeNullableFilter<"Email"> | Date | string | null
    scheduleTime?: StringNullableFilter<"Email"> | string | null
    emailsSentCount?: IntFilter<"Email"> | number
    recipients?: IntFilter<"Email"> | number
    bounceCount?: IntFilter<"Email"> | number
    openCount?: IntFilter<"Email"> | number
    clickCount?: IntFilter<"Email"> | number
    sentAt?: DateTimeNullableFilter<"Email"> | Date | string | null
    lastOpened?: DateTimeNullableFilter<"Email"> | Date | string | null
    lastClicked?: DateTimeNullableFilter<"Email"> | Date | string | null
    openedByIps?: StringNullableListFilter<"Email">
    openedByEmails?: StringNullableListFilter<"Email">
    clickedByIps?: StringNullableListFilter<"Email">
    clickedByEmails?: StringNullableListFilter<"Email">
    createdAt?: DateTimeFilter<"Email"> | Date | string
    updatedAt?: DateTimeFilter<"Email"> | Date | string
    userId?: StringFilter<"Email"> | string
    newsLetterOwnerId?: StringFilter<"Email"> | string
    campaignId?: StringNullableFilter<"Email"> | string | null
    elements?: EmailElementListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    clickedLinks?: ClickedLinkListRelationFilter
    emailAttachments?: EmailAttachmentListRelationFilter
    emailRecipients?: EmailRecipientListRelationFilter
    template?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    emailAnalytics?: XOR<EmailAnalyticsNullableScalarRelationFilter, EmailAnalyticsWhereInput> | null
  }, "id" | "title" | "messageId">

  export type EmailOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    emailSubject?: SortOrder
    previewText?: SortOrderInput | SortOrder
    builderMode?: SortOrder
    builderData?: SortOrderInput | SortOrder
    templateUsed?: SortOrderInput | SortOrder
    status?: SortOrder
    emailType?: SortOrder
    trackOpens?: SortOrder
    trackClicks?: SortOrder
    enableUnsubscribe?: SortOrder
    scheduleDate?: SortOrderInput | SortOrder
    scheduleTime?: SortOrderInput | SortOrder
    emailsSentCount?: SortOrder
    recipients?: SortOrder
    bounceCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    lastOpened?: SortOrderInput | SortOrder
    lastClicked?: SortOrderInput | SortOrder
    openedByIps?: SortOrder
    openedByEmails?: SortOrder
    clickedByIps?: SortOrder
    clickedByEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    newsLetterOwnerId?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    _count?: EmailCountOrderByAggregateInput
    _avg?: EmailAvgOrderByAggregateInput
    _max?: EmailMaxOrderByAggregateInput
    _min?: EmailMinOrderByAggregateInput
    _sum?: EmailSumOrderByAggregateInput
  }

  export type EmailScalarWhereWithAggregatesInput = {
    AND?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    OR?: EmailScalarWhereWithAggregatesInput[]
    NOT?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Email"> | string
    title?: StringWithAggregatesFilter<"Email"> | string
    content?: StringWithAggregatesFilter<"Email"> | string
    emailSubject?: StringWithAggregatesFilter<"Email"> | string
    previewText?: StringNullableWithAggregatesFilter<"Email"> | string | null
    builderMode?: StringWithAggregatesFilter<"Email"> | string
    builderData?: JsonNullableWithAggregatesFilter<"Email">
    templateUsed?: StringNullableWithAggregatesFilter<"Email"> | string | null
    status?: EnumEmailStatusWithAggregatesFilter<"Email"> | $Enums.EmailStatus
    emailType?: EnumEmailTypeWithAggregatesFilter<"Email"> | $Enums.EmailType
    trackOpens?: BoolWithAggregatesFilter<"Email"> | boolean
    trackClicks?: BoolWithAggregatesFilter<"Email"> | boolean
    enableUnsubscribe?: BoolWithAggregatesFilter<"Email"> | boolean
    scheduleDate?: DateTimeNullableWithAggregatesFilter<"Email"> | Date | string | null
    scheduleTime?: StringNullableWithAggregatesFilter<"Email"> | string | null
    emailsSentCount?: IntWithAggregatesFilter<"Email"> | number
    recipients?: IntWithAggregatesFilter<"Email"> | number
    bounceCount?: IntWithAggregatesFilter<"Email"> | number
    openCount?: IntWithAggregatesFilter<"Email"> | number
    clickCount?: IntWithAggregatesFilter<"Email"> | number
    sentAt?: DateTimeNullableWithAggregatesFilter<"Email"> | Date | string | null
    lastOpened?: DateTimeNullableWithAggregatesFilter<"Email"> | Date | string | null
    lastClicked?: DateTimeNullableWithAggregatesFilter<"Email"> | Date | string | null
    openedByIps?: StringNullableListFilter<"Email">
    openedByEmails?: StringNullableListFilter<"Email">
    clickedByIps?: StringNullableListFilter<"Email">
    clickedByEmails?: StringNullableListFilter<"Email">
    createdAt?: DateTimeWithAggregatesFilter<"Email"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Email"> | Date | string
    userId?: StringWithAggregatesFilter<"Email"> | string
    newsLetterOwnerId?: StringWithAggregatesFilter<"Email"> | string
    campaignId?: StringNullableWithAggregatesFilter<"Email"> | string | null
    messageId?: StringNullableWithAggregatesFilter<"Email"> | string | null
  }

  export type EmailElementWhereInput = {
    AND?: EmailElementWhereInput | EmailElementWhereInput[]
    OR?: EmailElementWhereInput[]
    NOT?: EmailElementWhereInput | EmailElementWhereInput[]
    id?: StringFilter<"EmailElement"> | string
    emailId?: StringFilter<"EmailElement"> | string
    elementId?: StringFilter<"EmailElement"> | string
    type?: EnumElementTypeFilter<"EmailElement"> | $Enums.ElementType
    content?: StringNullableFilter<"EmailElement"> | string | null
    properties?: JsonFilter<"EmailElement">
    sortOrder?: IntFilter<"EmailElement"> | number
    createdAt?: DateTimeFilter<"EmailElement"> | Date | string
    updatedAt?: DateTimeFilter<"EmailElement"> | Date | string
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }

  export type EmailElementOrderByWithRelationInput = {
    id?: SortOrder
    emailId?: SortOrder
    elementId?: SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    properties?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: EmailOrderByWithRelationInput
  }

  export type EmailElementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    emailId_elementId?: EmailElementEmailIdElementIdCompoundUniqueInput
    AND?: EmailElementWhereInput | EmailElementWhereInput[]
    OR?: EmailElementWhereInput[]
    NOT?: EmailElementWhereInput | EmailElementWhereInput[]
    emailId?: StringFilter<"EmailElement"> | string
    elementId?: StringFilter<"EmailElement"> | string
    type?: EnumElementTypeFilter<"EmailElement"> | $Enums.ElementType
    content?: StringNullableFilter<"EmailElement"> | string | null
    properties?: JsonFilter<"EmailElement">
    sortOrder?: IntFilter<"EmailElement"> | number
    createdAt?: DateTimeFilter<"EmailElement"> | Date | string
    updatedAt?: DateTimeFilter<"EmailElement"> | Date | string
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }, "id" | "emailId_elementId">

  export type EmailElementOrderByWithAggregationInput = {
    id?: SortOrder
    emailId?: SortOrder
    elementId?: SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    properties?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailElementCountOrderByAggregateInput
    _avg?: EmailElementAvgOrderByAggregateInput
    _max?: EmailElementMaxOrderByAggregateInput
    _min?: EmailElementMinOrderByAggregateInput
    _sum?: EmailElementSumOrderByAggregateInput
  }

  export type EmailElementScalarWhereWithAggregatesInput = {
    AND?: EmailElementScalarWhereWithAggregatesInput | EmailElementScalarWhereWithAggregatesInput[]
    OR?: EmailElementScalarWhereWithAggregatesInput[]
    NOT?: EmailElementScalarWhereWithAggregatesInput | EmailElementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailElement"> | string
    emailId?: StringWithAggregatesFilter<"EmailElement"> | string
    elementId?: StringWithAggregatesFilter<"EmailElement"> | string
    type?: EnumElementTypeWithAggregatesFilter<"EmailElement"> | $Enums.ElementType
    content?: StringNullableWithAggregatesFilter<"EmailElement"> | string | null
    properties?: JsonWithAggregatesFilter<"EmailElement">
    sortOrder?: IntWithAggregatesFilter<"EmailElement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EmailElement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailElement"> | Date | string
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    description?: StringNullableFilter<"EmailTemplate"> | string | null
    thumbnail?: StringNullableFilter<"EmailTemplate"> | string | null
    category?: StringFilter<"EmailTemplate"> | string
    tags?: StringNullableListFilter<"EmailTemplate">
    elements?: JsonFilter<"EmailTemplate">
    subject?: StringFilter<"EmailTemplate"> | string
    isPublic?: BoolFilter<"EmailTemplate"> | boolean
    isFeatured?: BoolFilter<"EmailTemplate"> | boolean
    usageCount?: IntFilter<"EmailTemplate"> | number
    userId?: StringNullableFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    emails?: EmailListRelationFilter
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrder
    elements?: SortOrder
    subject?: SortOrder
    isPublic?: SortOrder
    isFeatured?: SortOrder
    usageCount?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    emails?: EmailOrderByRelationAggregateInput
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    name?: StringFilter<"EmailTemplate"> | string
    description?: StringNullableFilter<"EmailTemplate"> | string | null
    thumbnail?: StringNullableFilter<"EmailTemplate"> | string | null
    category?: StringFilter<"EmailTemplate"> | string
    tags?: StringNullableListFilter<"EmailTemplate">
    elements?: JsonFilter<"EmailTemplate">
    subject?: StringFilter<"EmailTemplate"> | string
    isPublic?: BoolFilter<"EmailTemplate"> | boolean
    isFeatured?: BoolFilter<"EmailTemplate"> | boolean
    usageCount?: IntFilter<"EmailTemplate"> | number
    userId?: StringNullableFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    emails?: EmailListRelationFilter
  }, "id">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrder
    elements?: SortOrder
    subject?: SortOrder
    isPublic?: SortOrder
    isFeatured?: SortOrder
    usageCount?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _avg?: EmailTemplateAvgOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
    _sum?: EmailTemplateSumOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    category?: StringWithAggregatesFilter<"EmailTemplate"> | string
    tags?: StringNullableListFilter<"EmailTemplate">
    elements?: JsonWithAggregatesFilter<"EmailTemplate">
    subject?: StringWithAggregatesFilter<"EmailTemplate"> | string
    isPublic?: BoolWithAggregatesFilter<"EmailTemplate"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"EmailTemplate"> | boolean
    usageCount?: IntWithAggregatesFilter<"EmailTemplate"> | number
    userId?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
  }

  export type EmailAttachmentWhereInput = {
    AND?: EmailAttachmentWhereInput | EmailAttachmentWhereInput[]
    OR?: EmailAttachmentWhereInput[]
    NOT?: EmailAttachmentWhereInput | EmailAttachmentWhereInput[]
    id?: StringFilter<"EmailAttachment"> | string
    emailId?: StringFilter<"EmailAttachment"> | string
    filename?: StringFilter<"EmailAttachment"> | string
    fileSize?: IntFilter<"EmailAttachment"> | number
    mimeType?: StringFilter<"EmailAttachment"> | string
    url?: StringFilter<"EmailAttachment"> | string
    createdAt?: DateTimeFilter<"EmailAttachment"> | Date | string
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }

  export type EmailAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    emailId?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    email?: EmailOrderByWithRelationInput
  }

  export type EmailAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailAttachmentWhereInput | EmailAttachmentWhereInput[]
    OR?: EmailAttachmentWhereInput[]
    NOT?: EmailAttachmentWhereInput | EmailAttachmentWhereInput[]
    emailId?: StringFilter<"EmailAttachment"> | string
    filename?: StringFilter<"EmailAttachment"> | string
    fileSize?: IntFilter<"EmailAttachment"> | number
    mimeType?: StringFilter<"EmailAttachment"> | string
    url?: StringFilter<"EmailAttachment"> | string
    createdAt?: DateTimeFilter<"EmailAttachment"> | Date | string
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }, "id">

  export type EmailAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    emailId?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    _count?: EmailAttachmentCountOrderByAggregateInput
    _avg?: EmailAttachmentAvgOrderByAggregateInput
    _max?: EmailAttachmentMaxOrderByAggregateInput
    _min?: EmailAttachmentMinOrderByAggregateInput
    _sum?: EmailAttachmentSumOrderByAggregateInput
  }

  export type EmailAttachmentScalarWhereWithAggregatesInput = {
    AND?: EmailAttachmentScalarWhereWithAggregatesInput | EmailAttachmentScalarWhereWithAggregatesInput[]
    OR?: EmailAttachmentScalarWhereWithAggregatesInput[]
    NOT?: EmailAttachmentScalarWhereWithAggregatesInput | EmailAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailAttachment"> | string
    emailId?: StringWithAggregatesFilter<"EmailAttachment"> | string
    filename?: StringWithAggregatesFilter<"EmailAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"EmailAttachment"> | number
    mimeType?: StringWithAggregatesFilter<"EmailAttachment"> | string
    url?: StringWithAggregatesFilter<"EmailAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailAttachment"> | Date | string
  }

  export type EmailRecipientWhereInput = {
    AND?: EmailRecipientWhereInput | EmailRecipientWhereInput[]
    OR?: EmailRecipientWhereInput[]
    NOT?: EmailRecipientWhereInput | EmailRecipientWhereInput[]
    id?: StringFilter<"EmailRecipient"> | string
    emailId?: StringFilter<"EmailRecipient"> | string
    recipientEmail?: StringFilter<"EmailRecipient"> | string
    status?: EnumRecipientStatusFilter<"EmailRecipient"> | $Enums.RecipientStatus
    sentAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    bouncedAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    bounceReason?: StringNullableFilter<"EmailRecipient"> | string | null
    unsubscribeAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }

  export type EmailRecipientOrderByWithRelationInput = {
    id?: SortOrder
    emailId?: SortOrder
    recipientEmail?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    openedAt?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    bouncedAt?: SortOrderInput | SortOrder
    bounceReason?: SortOrderInput | SortOrder
    unsubscribeAt?: SortOrderInput | SortOrder
    email?: EmailOrderByWithRelationInput
  }

  export type EmailRecipientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    emailId_recipientEmail?: EmailRecipientEmailIdRecipientEmailCompoundUniqueInput
    AND?: EmailRecipientWhereInput | EmailRecipientWhereInput[]
    OR?: EmailRecipientWhereInput[]
    NOT?: EmailRecipientWhereInput | EmailRecipientWhereInput[]
    emailId?: StringFilter<"EmailRecipient"> | string
    recipientEmail?: StringFilter<"EmailRecipient"> | string
    status?: EnumRecipientStatusFilter<"EmailRecipient"> | $Enums.RecipientStatus
    sentAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    bouncedAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    bounceReason?: StringNullableFilter<"EmailRecipient"> | string | null
    unsubscribeAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }, "id" | "emailId_recipientEmail">

  export type EmailRecipientOrderByWithAggregationInput = {
    id?: SortOrder
    emailId?: SortOrder
    recipientEmail?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    openedAt?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    bouncedAt?: SortOrderInput | SortOrder
    bounceReason?: SortOrderInput | SortOrder
    unsubscribeAt?: SortOrderInput | SortOrder
    _count?: EmailRecipientCountOrderByAggregateInput
    _max?: EmailRecipientMaxOrderByAggregateInput
    _min?: EmailRecipientMinOrderByAggregateInput
  }

  export type EmailRecipientScalarWhereWithAggregatesInput = {
    AND?: EmailRecipientScalarWhereWithAggregatesInput | EmailRecipientScalarWhereWithAggregatesInput[]
    OR?: EmailRecipientScalarWhereWithAggregatesInput[]
    NOT?: EmailRecipientScalarWhereWithAggregatesInput | EmailRecipientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailRecipient"> | string
    emailId?: StringWithAggregatesFilter<"EmailRecipient"> | string
    recipientEmail?: StringWithAggregatesFilter<"EmailRecipient"> | string
    status?: EnumRecipientStatusWithAggregatesFilter<"EmailRecipient"> | $Enums.RecipientStatus
    sentAt?: DateTimeNullableWithAggregatesFilter<"EmailRecipient"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"EmailRecipient"> | Date | string | null
    openedAt?: DateTimeNullableWithAggregatesFilter<"EmailRecipient"> | Date | string | null
    clickedAt?: DateTimeNullableWithAggregatesFilter<"EmailRecipient"> | Date | string | null
    bouncedAt?: DateTimeNullableWithAggregatesFilter<"EmailRecipient"> | Date | string | null
    bounceReason?: StringNullableWithAggregatesFilter<"EmailRecipient"> | string | null
    unsubscribeAt?: DateTimeNullableWithAggregatesFilter<"EmailRecipient"> | Date | string | null
  }

  export type EmailAnalyticsWhereInput = {
    AND?: EmailAnalyticsWhereInput | EmailAnalyticsWhereInput[]
    OR?: EmailAnalyticsWhereInput[]
    NOT?: EmailAnalyticsWhereInput | EmailAnalyticsWhereInput[]
    id?: StringFilter<"EmailAnalytics"> | string
    emailId?: StringFilter<"EmailAnalytics"> | string
    totalOpens?: IntFilter<"EmailAnalytics"> | number
    deliveredCount?: IntFilter<"EmailAnalytics"> | number
    totalRecipients?: IntFilter<"EmailAnalytics"> | number
    uniqueOpens?: IntFilter<"EmailAnalytics"> | number
    totalClicks?: IntFilter<"EmailAnalytics"> | number
    uniqueClicks?: IntFilter<"EmailAnalytics"> | number
    deliveryRate?: FloatFilter<"EmailAnalytics"> | number
    openRate?: FloatFilter<"EmailAnalytics"> | number
    clickRate?: FloatFilter<"EmailAnalytics"> | number
    bounceRate?: FloatFilter<"EmailAnalytics"> | number
    unsubscribeCount?: IntFilter<"EmailAnalytics"> | number
    spamReportCount?: IntFilter<"EmailAnalytics"> | number
    forwardCount?: IntFilter<"EmailAnalytics"> | number
    deviceBreakdown?: JsonNullableFilter<"EmailAnalytics">
    locationData?: JsonNullableFilter<"EmailAnalytics">
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }

  export type EmailAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    emailId?: SortOrder
    totalOpens?: SortOrder
    deliveredCount?: SortOrder
    totalRecipients?: SortOrder
    uniqueOpens?: SortOrder
    totalClicks?: SortOrder
    uniqueClicks?: SortOrder
    deliveryRate?: SortOrder
    openRate?: SortOrder
    clickRate?: SortOrder
    bounceRate?: SortOrder
    unsubscribeCount?: SortOrder
    spamReportCount?: SortOrder
    forwardCount?: SortOrder
    deviceBreakdown?: SortOrderInput | SortOrder
    locationData?: SortOrderInput | SortOrder
    email?: EmailOrderByWithRelationInput
  }

  export type EmailAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    emailId?: string
    AND?: EmailAnalyticsWhereInput | EmailAnalyticsWhereInput[]
    OR?: EmailAnalyticsWhereInput[]
    NOT?: EmailAnalyticsWhereInput | EmailAnalyticsWhereInput[]
    totalOpens?: IntFilter<"EmailAnalytics"> | number
    deliveredCount?: IntFilter<"EmailAnalytics"> | number
    totalRecipients?: IntFilter<"EmailAnalytics"> | number
    uniqueOpens?: IntFilter<"EmailAnalytics"> | number
    totalClicks?: IntFilter<"EmailAnalytics"> | number
    uniqueClicks?: IntFilter<"EmailAnalytics"> | number
    deliveryRate?: FloatFilter<"EmailAnalytics"> | number
    openRate?: FloatFilter<"EmailAnalytics"> | number
    clickRate?: FloatFilter<"EmailAnalytics"> | number
    bounceRate?: FloatFilter<"EmailAnalytics"> | number
    unsubscribeCount?: IntFilter<"EmailAnalytics"> | number
    spamReportCount?: IntFilter<"EmailAnalytics"> | number
    forwardCount?: IntFilter<"EmailAnalytics"> | number
    deviceBreakdown?: JsonNullableFilter<"EmailAnalytics">
    locationData?: JsonNullableFilter<"EmailAnalytics">
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }, "id" | "emailId">

  export type EmailAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    emailId?: SortOrder
    totalOpens?: SortOrder
    deliveredCount?: SortOrder
    totalRecipients?: SortOrder
    uniqueOpens?: SortOrder
    totalClicks?: SortOrder
    uniqueClicks?: SortOrder
    deliveryRate?: SortOrder
    openRate?: SortOrder
    clickRate?: SortOrder
    bounceRate?: SortOrder
    unsubscribeCount?: SortOrder
    spamReportCount?: SortOrder
    forwardCount?: SortOrder
    deviceBreakdown?: SortOrderInput | SortOrder
    locationData?: SortOrderInput | SortOrder
    _count?: EmailAnalyticsCountOrderByAggregateInput
    _avg?: EmailAnalyticsAvgOrderByAggregateInput
    _max?: EmailAnalyticsMaxOrderByAggregateInput
    _min?: EmailAnalyticsMinOrderByAggregateInput
    _sum?: EmailAnalyticsSumOrderByAggregateInput
  }

  export type EmailAnalyticsScalarWhereWithAggregatesInput = {
    AND?: EmailAnalyticsScalarWhereWithAggregatesInput | EmailAnalyticsScalarWhereWithAggregatesInput[]
    OR?: EmailAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: EmailAnalyticsScalarWhereWithAggregatesInput | EmailAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailAnalytics"> | string
    emailId?: StringWithAggregatesFilter<"EmailAnalytics"> | string
    totalOpens?: IntWithAggregatesFilter<"EmailAnalytics"> | number
    deliveredCount?: IntWithAggregatesFilter<"EmailAnalytics"> | number
    totalRecipients?: IntWithAggregatesFilter<"EmailAnalytics"> | number
    uniqueOpens?: IntWithAggregatesFilter<"EmailAnalytics"> | number
    totalClicks?: IntWithAggregatesFilter<"EmailAnalytics"> | number
    uniqueClicks?: IntWithAggregatesFilter<"EmailAnalytics"> | number
    deliveryRate?: FloatWithAggregatesFilter<"EmailAnalytics"> | number
    openRate?: FloatWithAggregatesFilter<"EmailAnalytics"> | number
    clickRate?: FloatWithAggregatesFilter<"EmailAnalytics"> | number
    bounceRate?: FloatWithAggregatesFilter<"EmailAnalytics"> | number
    unsubscribeCount?: IntWithAggregatesFilter<"EmailAnalytics"> | number
    spamReportCount?: IntWithAggregatesFilter<"EmailAnalytics"> | number
    forwardCount?: IntWithAggregatesFilter<"EmailAnalytics"> | number
    deviceBreakdown?: JsonNullableWithAggregatesFilter<"EmailAnalytics">
    locationData?: JsonNullableWithAggregatesFilter<"EmailAnalytics">
  }

  export type UserCreateInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    jti: string
    hashed: string
    userAgent?: string | null
    ip?: string | null
    revoked?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    jti: string
    userId: string
    hashed: string
    userAgent?: string | null
    ip?: string | null
    revoked?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    hashed?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    hashed?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    jti: string
    userId: string
    hashed: string
    userAgent?: string | null
    ip?: string | null
    revoked?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    hashed?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    hashed?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPCreateInput = {
    id?: string
    email: string
    otp: string
    attempts?: number
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTPUncheckedCreateInput = {
    id?: string
    email: string
    otp: string
    attempts?: number
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPCreateManyInput = {
    id?: string
    email: string
    otp: string
    attempts?: number
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    description: string
    amount: number
    status: string
    invoiceUrl: string
    date?: Date | string
    externalId?: string | null
    user: UserCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    userId: string
    description: string
    amount: number
    status: string
    invoiceUrl: string
    date?: Date | string
    externalId?: string | null
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateManyInput = {
    id?: string
    userId: string
    description: string
    amount: number
    status: string
    invoiceUrl: string
    date?: Date | string
    externalId?: string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThirdPartyOTPCreateInput = {
    email: string
    code: string
    otpType: string
    expiresAt: Date | string
    createdBy: string
    createdAt?: Date | string
    attempts?: number
  }

  export type ThirdPartyOTPUncheckedCreateInput = {
    email: string
    code: string
    otpType: string
    expiresAt: Date | string
    createdBy: string
    createdAt?: Date | string
    attempts?: number
  }

  export type ThirdPartyOTPUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    otpType?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type ThirdPartyOTPUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    otpType?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type ThirdPartyOTPCreateManyInput = {
    email: string
    code: string
    otpType: string
    expiresAt: Date | string
    createdBy: string
    createdAt?: Date | string
    attempts?: number
  }

  export type ThirdPartyOTPUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    otpType?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type ThirdPartyOTPUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    otpType?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type ApiKeyCreateInput = {
    id?: string
    keyHash: string
    jwt: string
    createdAt?: Date | string
    isTrial?: boolean
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    userId: string
    keyHash: string
    jwt: string
    createdAt?: Date | string
    isTrial?: boolean
    expiresAt: Date | string
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    userId: string
    keyHash: string
    jwt: string
    createdAt?: Date | string
    isTrial?: boolean
    expiresAt: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycCreateInput = {
    id?: string
    accountType: $Enums.KYCAccountType
    status?: $Enums.KYCStatus
    levels: JsonNullValueInput | InputJsonValue
    documents: JsonNullValueInput | InputJsonValue
    livePhoto?: string | null
    reviewedTime?: Date | string | null
    reviewedBy?: string | null
    rejectedResponse?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKycInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutKycInput
  }

  export type KycUncheckedCreateInput = {
    id?: string
    userId: string
    accountType: $Enums.KYCAccountType
    status?: $Enums.KYCStatus
    levels: JsonNullValueInput | InputJsonValue
    documents: JsonNullValueInput | InputJsonValue
    livePhoto?: string | null
    reviewedTime?: Date | string | null
    reviewedBy?: string | null
    rejectedResponse?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutKycInput
  }

  export type KycUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: EnumKYCAccountTypeFieldUpdateOperationsInput | $Enums.KYCAccountType
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    levels?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    livePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedResponse?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKycNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutKycNestedInput
  }

  export type KycUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: EnumKYCAccountTypeFieldUpdateOperationsInput | $Enums.KYCAccountType
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    levels?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    livePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedResponse?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutKycNestedInput
  }

  export type KycCreateManyInput = {
    id?: string
    userId: string
    accountType: $Enums.KYCAccountType
    status?: $Enums.KYCStatus
    levels: JsonNullValueInput | InputJsonValue
    documents: JsonNullValueInput | InputJsonValue
    livePhoto?: string | null
    reviewedTime?: Date | string | null
    reviewedBy?: string | null
    rejectedResponse?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KycUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: EnumKYCAccountTypeFieldUpdateOperationsInput | $Enums.KYCAccountType
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    levels?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    livePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedResponse?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: EnumKYCAccountTypeFieldUpdateOperationsInput | $Enums.KYCAccountType
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    levels?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    livePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedResponse?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCDocumentCreateInput = {
    id?: string
    type: string
    url: string
    key: string
    uploadedAt?: Date | string
    kyc: KycCreateNestedOneWithoutKycDocumentsInput
  }

  export type KYCDocumentUncheckedCreateInput = {
    id?: string
    kycId: string
    type: string
    url: string
    key: string
    uploadedAt?: Date | string
  }

  export type KYCDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KycUpdateOneRequiredWithoutKycDocumentsNestedInput
  }

  export type KYCDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kycId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCDocumentCreateManyInput = {
    id?: string
    kycId: string
    type: string
    url: string
    key: string
    uploadedAt?: Date | string
  }

  export type KYCDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kycId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUsageCreateInput = {
    id?: string
    month: string
    emailsSent?: number
    subscribersAdded?: number
    campaignsCreated?: number
    blogPostsCreated?: number
    aiGenerationsUsed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUsageInput
  }

  export type MembershipUsageUncheckedCreateInput = {
    id?: string
    userId: string
    month: string
    emailsSent?: number
    subscribersAdded?: number
    campaignsCreated?: number
    blogPostsCreated?: number
    aiGenerationsUsed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    subscribersAdded?: IntFieldUpdateOperationsInput | number
    campaignsCreated?: IntFieldUpdateOperationsInput | number
    blogPostsCreated?: IntFieldUpdateOperationsInput | number
    aiGenerationsUsed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsageNestedInput
  }

  export type MembershipUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    subscribersAdded?: IntFieldUpdateOperationsInput | number
    campaignsCreated?: IntFieldUpdateOperationsInput | number
    blogPostsCreated?: IntFieldUpdateOperationsInput | number
    aiGenerationsUsed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUsageCreateManyInput = {
    id?: string
    userId: string
    month: string
    emailsSent?: number
    subscribersAdded?: number
    campaignsCreated?: number
    blogPostsCreated?: number
    aiGenerationsUsed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    subscribersAdded?: IntFieldUpdateOperationsInput | number
    campaignsCreated?: IntFieldUpdateOperationsInput | number
    blogPostsCreated?: IntFieldUpdateOperationsInput | number
    aiGenerationsUsed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    subscribersAdded?: IntFieldUpdateOperationsInput | number
    campaignsCreated?: IntFieldUpdateOperationsInput | number
    blogPostsCreated?: IntFieldUpdateOperationsInput | number
    aiGenerationsUsed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorBio: string
    authorTitle: string
    author: string
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: BlogCommentCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutBlogPostsInput
    category?: BlogCategoryCreateNestedOneWithoutPostsInput
    aiGeneration?: BlogAIGenerationCreateNestedOneWithoutBlogPostsInput
    viewsCount?: BlogPostViewCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostCreateNestedManyWithoutPostInput
    tags?: BlogTagCreateNestedManyWithoutPostsInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorId: string
    authorBio: string
    authorTitle: string
    author: string
    categoryId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedById?: string | null
    comments?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
    viewsCount?: BlogPostViewUncheckedCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutPostInput
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type BlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: BlogCommentUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    category?: BlogCategoryUpdateOneWithoutPostsNestedInput
    aiGeneration?: BlogAIGenerationUpdateOneWithoutBlogPostsNestedInput
    viewsCount?: BlogPostViewUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUpdateManyWithoutPostNestedInput
    tags?: BlogTagUpdateManyWithoutPostsNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
    viewsCount?: BlogPostViewUncheckedUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutPostNestedInput
    tags?: BlogTagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type BlogPostCreateManyInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorId: string
    authorBio: string
    authorTitle: string
    author: string
    categoryId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedById?: string | null
  }

  export type BlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlagedBlogPostCreateInput = {
    id?: string
    reason: string
    comment: string
    flaggedBy: string
    status?: $Enums.FlagStatus
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    post: BlogPostCreateNestedOneWithoutFlaggedPostsInput
    user: UserCreateNestedOneWithoutFlagedPostsInput
  }

  export type FlagedBlogPostUncheckedCreateInput = {
    id?: string
    reason: string
    comment: string
    flaggedBy: string
    status?: $Enums.FlagStatus
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    postId: string
    userId: string
  }

  export type FlagedBlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: BlogPostUpdateOneRequiredWithoutFlaggedPostsNestedInput
    user?: UserUpdateOneRequiredWithoutFlagedPostsNestedInput
  }

  export type FlagedBlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FlagedBlogPostCreateManyInput = {
    id?: string
    reason: string
    comment: string
    flaggedBy: string
    status?: $Enums.FlagStatus
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    postId: string
    userId: string
  }

  export type FlagedBlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlagedBlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostViewCreateInput = {
    id?: string
    externalName?: string | null
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutViewsCountInput
    user?: UserCreateNestedOneWithoutPostViewsInput
  }

  export type BlogPostViewUncheckedCreateInput = {
    id?: string
    postId: string
    userId?: string | null
    externalName?: string | null
    createdAt?: Date | string
  }

  export type BlogPostViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutViewsCountNestedInput
    user?: UserUpdateOneWithoutPostViewsNestedInput
  }

  export type BlogPostViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostViewCreateManyInput = {
    id?: string
    postId: string
    userId?: string | null
    externalName?: string | null
    createdAt?: Date | string
  }

  export type BlogPostViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostCreateNestedManyWithoutCategoryInput
  }

  export type BlogCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type BlogCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUpdateManyWithoutCategoryNestedInput
  }

  export type BlogCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type BlogCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostCreateNestedManyWithoutTagsInput
  }

  export type BlogTagUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostUncheckedCreateNestedManyWithoutTagsInput
  }

  export type BlogTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUpdateManyWithoutTagsNestedInput
  }

  export type BlogTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type BlogTagCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentCreateInput = {
    id?: string
    content: string
    userId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBlogCommentsInput
    parent?: BlogCommentCreateNestedOneWithoutRepliesInput
    replies?: BlogCommentCreateNestedManyWithoutParentInput
    post: BlogPostCreateNestedOneWithoutCommentsInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutCommentInput
  }

  export type BlogCommentUncheckedCreateInput = {
    id?: string
    content: string
    authorId: string
    postId: string
    userId?: string | null
    parentId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: BlogCommentUncheckedCreateNestedManyWithoutParentInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type BlogCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogCommentsNestedInput
    parent?: BlogCommentUpdateOneWithoutRepliesNestedInput
    replies?: BlogCommentUpdateManyWithoutParentNestedInput
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutCommentNestedInput
  }

  export type BlogCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: BlogCommentUncheckedUpdateManyWithoutParentNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type BlogCommentCreateManyInput = {
    id?: string
    content: string
    authorId: string
    postId: string
    userId?: string | null
    parentId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportedCommentCreateInput = {
    id?: string
    blogSlug: string
    blogOwner: string
    parentCommentBy: string
    reason?: string | null
    reportedAt?: Date | string
    resolved?: boolean
    comment: BlogCommentCreateNestedOneWithoutReportedCommentsInput
    user: UserCreateNestedOneWithoutReportedCommentsInput
  }

  export type ReportedCommentUncheckedCreateInput = {
    id?: string
    commentId: string
    blogSlug: string
    blogOwner: string
    parentCommentBy: string
    reportedBy: string
    reason?: string | null
    reportedAt?: Date | string
    resolved?: boolean
  }

  export type ReportedCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogSlug?: StringFieldUpdateOperationsInput | string
    blogOwner?: StringFieldUpdateOperationsInput | string
    parentCommentBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    comment?: BlogCommentUpdateOneRequiredWithoutReportedCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutReportedCommentsNestedInput
  }

  export type ReportedCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    blogSlug?: StringFieldUpdateOperationsInput | string
    blogOwner?: StringFieldUpdateOperationsInput | string
    parentCommentBy?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReportedCommentCreateManyInput = {
    id?: string
    commentId: string
    blogSlug: string
    blogOwner: string
    parentCommentBy: string
    reportedBy: string
    reason?: string | null
    reportedAt?: Date | string
    resolved?: boolean
  }

  export type ReportedCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogSlug?: StringFieldUpdateOperationsInput | string
    blogOwner?: StringFieldUpdateOperationsInput | string
    parentCommentBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReportedCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    blogSlug?: StringFieldUpdateOperationsInput | string
    blogOwner?: StringFieldUpdateOperationsInput | string
    parentCommentBy?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogAIGenerationCreateInput = {
    id?: string
    prompt: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIGenerationStatus
    output: string
    format?: $Enums.ContentFormat
    cost?: number | null
    tokensUsed?: number | null
    model?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAIContentGenerationToExcerptInput
    blogPosts?: BlogPostCreateNestedManyWithoutAiGenerationInput
  }

  export type BlogAIGenerationUncheckedCreateInput = {
    id?: string
    prompt: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIGenerationStatus
    output: string
    format?: $Enums.ContentFormat
    cost?: number | null
    tokensUsed?: number | null
    model?: string | null
    userId: string
    createdAt?: Date | string
    completedAt?: Date | string | null
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAiGenerationInput
  }

  export type BlogAIGenerationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIGenerationStatusFieldUpdateOperationsInput | $Enums.AIGenerationStatus
    output?: StringFieldUpdateOperationsInput | string
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAIContentGenerationToExcerptNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAiGenerationNestedInput
  }

  export type BlogAIGenerationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIGenerationStatusFieldUpdateOperationsInput | $Enums.AIGenerationStatus
    output?: StringFieldUpdateOperationsInput | string
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAiGenerationNestedInput
  }

  export type BlogAIGenerationCreateManyInput = {
    id?: string
    prompt: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIGenerationStatus
    output: string
    format?: $Enums.ContentFormat
    cost?: number | null
    tokensUsed?: number | null
    model?: string | null
    userId: string
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type BlogAIGenerationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIGenerationStatusFieldUpdateOperationsInput | $Enums.AIGenerationStatus
    output?: StringFieldUpdateOperationsInput | string
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlogAIGenerationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIGenerationStatusFieldUpdateOperationsInput | $Enums.AIGenerationStatus
    output?: StringFieldUpdateOperationsInput | string
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    userId: string
    description?: string | null
    type?: string | null
    status?: $Enums.CampaignStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    emailsSent?: number
    recipients?: number | null
    openRate?: number | null
    clickRate?: number | null
    lastSentAt?: Date | string | null
    emails?: EmailCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    userId: string
    description?: string | null
    type?: string | null
    status?: $Enums.CampaignStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    emailsSent?: number
    recipients?: number | null
    openRate?: number | null
    clickRate?: number | null
    lastSentAt?: Date | string | null
    emails?: EmailUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    openRate?: NullableFloatFieldUpdateOperationsInput | number | null
    clickRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emails?: EmailUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    openRate?: NullableFloatFieldUpdateOperationsInput | number | null
    clickRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emails?: EmailUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    userId: string
    description?: string | null
    type?: string | null
    status?: $Enums.CampaignStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    emailsSent?: number
    recipients?: number | null
    openRate?: number | null
    clickRate?: number | null
    lastSentAt?: Date | string | null
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    openRate?: NullableFloatFieldUpdateOperationsInput | number | null
    clickRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    openRate?: NullableFloatFieldUpdateOperationsInput | number | null
    clickRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriberCreateInput = {
    id?: string
    email: string
    name?: string | null
    newsLetterOwnerId: string
    source?: string
    status?: $Enums.SubscriptionStatus
    campaignId?: string | null
    pageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriberUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    newsLetterOwnerId: string
    source?: string
    status?: $Enums.SubscriptionStatus
    campaignId?: string | null
    pageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    pageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    pageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriberCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    newsLetterOwnerId: string
    source?: string
    status?: $Enums.SubscriptionStatus
    campaignId?: string | null
    pageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    pageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    pageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    title: string
    content: JsonNullValueInput | InputJsonValue
    textContent?: string | null
    htmlContent?: string | null
    status?: $Enums.NotificationStatus
    priority?: $Enums.NotificationPriority
    emailsSentCount?: number | null
    openCount?: number | null
    clickCount?: number | null
    recipients?: number | null
    bounceCount?: number | null
    openedByEmails?: EmailNotificationCreateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationCreateclickedByEmailsInput | string[]
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    user: UserCreateNestedOneWithoutNotificationEmailsInput
    NotificationEmailClickedLink?: NotificationEmailClickedLinkCreateNestedManyWithoutNotificationEmailInput
  }

  export type EmailNotificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    title: string
    content: JsonNullValueInput | InputJsonValue
    textContent?: string | null
    htmlContent?: string | null
    status?: $Enums.NotificationStatus
    priority?: $Enums.NotificationPriority
    userId: string
    emailsSentCount?: number | null
    openCount?: number | null
    clickCount?: number | null
    recipients?: number | null
    bounceCount?: number | null
    openedByEmails?: EmailNotificationCreateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationCreateclickedByEmailsInput | string[]
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    NotificationEmailClickedLink?: NotificationEmailClickedLinkUncheckedCreateNestedManyWithoutNotificationEmailInput
  }

  export type EmailNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    emailsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    openCount?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    bounceCount?: NullableIntFieldUpdateOperationsInput | number | null
    openedByEmails?: EmailNotificationUpdateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationUpdateclickedByEmailsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutNotificationEmailsNestedInput
    NotificationEmailClickedLink?: NotificationEmailClickedLinkUpdateManyWithoutNotificationEmailNestedInput
  }

  export type EmailNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    userId?: StringFieldUpdateOperationsInput | string
    emailsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    openCount?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    bounceCount?: NullableIntFieldUpdateOperationsInput | number | null
    openedByEmails?: EmailNotificationUpdateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationUpdateclickedByEmailsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    NotificationEmailClickedLink?: NotificationEmailClickedLinkUncheckedUpdateManyWithoutNotificationEmailNestedInput
  }

  export type EmailNotificationCreateManyInput = {
    id?: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    title: string
    content: JsonNullValueInput | InputJsonValue
    textContent?: string | null
    htmlContent?: string | null
    status?: $Enums.NotificationStatus
    priority?: $Enums.NotificationPriority
    userId: string
    emailsSentCount?: number | null
    openCount?: number | null
    clickCount?: number | null
    recipients?: number | null
    bounceCount?: number | null
    openedByEmails?: EmailNotificationCreateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationCreateclickedByEmailsInput | string[]
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
  }

  export type EmailNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    emailsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    openCount?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    bounceCount?: NullableIntFieldUpdateOperationsInput | number | null
    openedByEmails?: EmailNotificationUpdateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationUpdateclickedByEmailsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    userId?: StringFieldUpdateOperationsInput | string
    emailsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    openCount?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    bounceCount?: NullableIntFieldUpdateOperationsInput | number | null
    openedByEmails?: EmailNotificationUpdateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationUpdateclickedByEmailsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClickedLinkCreateInput = {
    id?: string
    url: string
    clickedAt?: Date | string
    clickedBy?: string | null
    email: EmailCreateNestedOneWithoutClickedLinksInput
  }

  export type ClickedLinkUncheckedCreateInput = {
    id?: string
    emailId: string
    url: string
    clickedAt?: Date | string
    clickedBy?: string | null
  }

  export type ClickedLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
    email?: EmailUpdateOneRequiredWithoutClickedLinksNestedInput
  }

  export type ClickedLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClickedLinkCreateManyInput = {
    id?: string
    emailId: string
    url: string
    clickedAt?: Date | string
    clickedBy?: string | null
  }

  export type ClickedLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClickedLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationEmailClickedLinkCreateInput = {
    id?: string
    url: string
    clickedAt?: Date | string
    clickedBy?: string | null
    notificationEmail?: EmailNotificationCreateNestedOneWithoutNotificationEmailClickedLinkInput
  }

  export type NotificationEmailClickedLinkUncheckedCreateInput = {
    id?: string
    notificationEmailId?: string | null
    url: string
    clickedAt?: Date | string
    clickedBy?: string | null
  }

  export type NotificationEmailClickedLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: EmailNotificationUpdateOneWithoutNotificationEmailClickedLinkNestedInput
  }

  export type NotificationEmailClickedLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationEmailId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationEmailClickedLinkCreateManyInput = {
    id?: string
    notificationEmailId?: string | null
    url: string
    clickedAt?: Date | string
    clickedBy?: string | null
  }

  export type NotificationEmailClickedLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationEmailClickedLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationEmailId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailCreateInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    newsLetterOwnerId: string
    messageId?: string | null
    elements?: EmailElementCreateNestedManyWithoutEmailInput
    user: UserCreateNestedOneWithoutEmailsInput
    campaign?: CampaignCreateNestedOneWithoutEmailsInput
    clickedLinks?: ClickedLinkCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientCreateNestedManyWithoutEmailInput
    template?: EmailTemplateCreateNestedOneWithoutEmailsInput
    emailAnalytics?: EmailAnalyticsCreateNestedOneWithoutEmailInput
  }

  export type EmailUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    newsLetterOwnerId: string
    campaignId?: string | null
    messageId?: string | null
    elements?: EmailElementUncheckedCreateNestedManyWithoutEmailInput
    clickedLinks?: ClickedLinkUncheckedCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientUncheckedCreateNestedManyWithoutEmailInput
    emailAnalytics?: EmailAnalyticsUncheckedCreateNestedOneWithoutEmailInput
  }

  export type EmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUpdateManyWithoutEmailNestedInput
    user?: UserUpdateOneRequiredWithoutEmailsNestedInput
    campaign?: CampaignUpdateOneWithoutEmailsNestedInput
    clickedLinks?: ClickedLinkUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUpdateManyWithoutEmailNestedInput
    template?: EmailTemplateUpdateOneWithoutEmailsNestedInput
    emailAnalytics?: EmailAnalyticsUpdateOneWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUncheckedUpdateManyWithoutEmailNestedInput
    clickedLinks?: ClickedLinkUncheckedUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUncheckedUpdateManyWithoutEmailNestedInput
    emailAnalytics?: EmailAnalyticsUncheckedUpdateOneWithoutEmailNestedInput
  }

  export type EmailCreateManyInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    newsLetterOwnerId: string
    campaignId?: string | null
    messageId?: string | null
  }

  export type EmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailElementCreateInput = {
    id?: string
    elementId: string
    type: $Enums.ElementType
    content?: string | null
    properties: JsonNullValueInput | InputJsonValue
    sortOrder: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: EmailCreateNestedOneWithoutElementsInput
  }

  export type EmailElementUncheckedCreateInput = {
    id?: string
    emailId: string
    elementId: string
    type: $Enums.ElementType
    content?: string | null
    properties: JsonNullValueInput | InputJsonValue
    sortOrder: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailElementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: EmailUpdateOneRequiredWithoutElementsNestedInput
  }

  export type EmailElementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailElementCreateManyInput = {
    id?: string
    emailId: string
    elementId: string
    type: $Enums.ElementType
    content?: string | null
    properties: JsonNullValueInput | InputJsonValue
    sortOrder: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailElementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailElementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    thumbnail?: string | null
    category: string
    tags?: EmailTemplateCreatetagsInput | string[]
    elements: JsonNullValueInput | InputJsonValue
    subject: string
    isPublic?: boolean
    isFeatured?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTemplateInput
    emails?: EmailCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    thumbnail?: string | null
    category: string
    tags?: EmailTemplateCreatetagsInput | string[]
    elements: JsonNullValueInput | InputJsonValue
    subject: string
    isPublic?: boolean
    isFeatured?: boolean
    usageCount?: number
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: EmailTemplateUpdatetagsInput | string[]
    elements?: JsonNullValueInput | InputJsonValue
    subject?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTemplateNestedInput
    emails?: EmailUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: EmailTemplateUpdatetagsInput | string[]
    elements?: JsonNullValueInput | InputJsonValue
    subject?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    thumbnail?: string | null
    category: string
    tags?: EmailTemplateCreatetagsInput | string[]
    elements: JsonNullValueInput | InputJsonValue
    subject: string
    isPublic?: boolean
    isFeatured?: boolean
    usageCount?: number
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: EmailTemplateUpdatetagsInput | string[]
    elements?: JsonNullValueInput | InputJsonValue
    subject?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: EmailTemplateUpdatetagsInput | string[]
    elements?: JsonNullValueInput | InputJsonValue
    subject?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentCreateInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
    email: EmailCreateNestedOneWithoutEmailAttachmentsInput
  }

  export type EmailAttachmentUncheckedCreateInput = {
    id?: string
    emailId: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
  }

  export type EmailAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: EmailUpdateOneRequiredWithoutEmailAttachmentsNestedInput
  }

  export type EmailAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentCreateManyInput = {
    id?: string
    emailId: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
  }

  export type EmailAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailRecipientCreateInput = {
    id?: string
    recipientEmail: string
    status?: $Enums.RecipientStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    bouncedAt?: Date | string | null
    bounceReason?: string | null
    unsubscribeAt?: Date | string | null
    email: EmailCreateNestedOneWithoutEmailRecipientsInput
  }

  export type EmailRecipientUncheckedCreateInput = {
    id?: string
    emailId: string
    recipientEmail: string
    status?: $Enums.RecipientStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    bouncedAt?: Date | string | null
    bounceReason?: string | null
    unsubscribeAt?: Date | string | null
  }

  export type EmailRecipientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bouncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bounceReason?: NullableStringFieldUpdateOperationsInput | string | null
    unsubscribeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: EmailUpdateOneRequiredWithoutEmailRecipientsNestedInput
  }

  export type EmailRecipientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bouncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bounceReason?: NullableStringFieldUpdateOperationsInput | string | null
    unsubscribeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailRecipientCreateManyInput = {
    id?: string
    emailId: string
    recipientEmail: string
    status?: $Enums.RecipientStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    bouncedAt?: Date | string | null
    bounceReason?: string | null
    unsubscribeAt?: Date | string | null
  }

  export type EmailRecipientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bouncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bounceReason?: NullableStringFieldUpdateOperationsInput | string | null
    unsubscribeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailRecipientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bouncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bounceReason?: NullableStringFieldUpdateOperationsInput | string | null
    unsubscribeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAnalyticsCreateInput = {
    id?: string
    totalOpens?: number
    deliveredCount?: number
    totalRecipients?: number
    uniqueOpens?: number
    totalClicks?: number
    uniqueClicks?: number
    deliveryRate?: number
    openRate?: number
    clickRate?: number
    bounceRate?: number
    unsubscribeCount?: number
    spamReportCount?: number
    forwardCount?: number
    deviceBreakdown?: NullableJsonNullValueInput | InputJsonValue
    locationData?: NullableJsonNullValueInput | InputJsonValue
    email: EmailCreateNestedOneWithoutEmailAnalyticsInput
  }

  export type EmailAnalyticsUncheckedCreateInput = {
    id?: string
    emailId: string
    totalOpens?: number
    deliveredCount?: number
    totalRecipients?: number
    uniqueOpens?: number
    totalClicks?: number
    uniqueClicks?: number
    deliveryRate?: number
    openRate?: number
    clickRate?: number
    bounceRate?: number
    unsubscribeCount?: number
    spamReportCount?: number
    forwardCount?: number
    deviceBreakdown?: NullableJsonNullValueInput | InputJsonValue
    locationData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOpens?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    totalRecipients?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    deliveryRate?: FloatFieldUpdateOperationsInput | number
    openRate?: FloatFieldUpdateOperationsInput | number
    clickRate?: FloatFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    unsubscribeCount?: IntFieldUpdateOperationsInput | number
    spamReportCount?: IntFieldUpdateOperationsInput | number
    forwardCount?: IntFieldUpdateOperationsInput | number
    deviceBreakdown?: NullableJsonNullValueInput | InputJsonValue
    locationData?: NullableJsonNullValueInput | InputJsonValue
    email?: EmailUpdateOneRequiredWithoutEmailAnalyticsNestedInput
  }

  export type EmailAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    totalOpens?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    totalRecipients?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    deliveryRate?: FloatFieldUpdateOperationsInput | number
    openRate?: FloatFieldUpdateOperationsInput | number
    clickRate?: FloatFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    unsubscribeCount?: IntFieldUpdateOperationsInput | number
    spamReportCount?: IntFieldUpdateOperationsInput | number
    forwardCount?: IntFieldUpdateOperationsInput | number
    deviceBreakdown?: NullableJsonNullValueInput | InputJsonValue
    locationData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailAnalyticsCreateManyInput = {
    id?: string
    emailId: string
    totalOpens?: number
    deliveredCount?: number
    totalRecipients?: number
    uniqueOpens?: number
    totalClicks?: number
    uniqueClicks?: number
    deliveryRate?: number
    openRate?: number
    clickRate?: number
    bounceRate?: number
    unsubscribeCount?: number
    spamReportCount?: number
    forwardCount?: number
    deviceBreakdown?: NullableJsonNullValueInput | InputJsonValue
    locationData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOpens?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    totalRecipients?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    deliveryRate?: FloatFieldUpdateOperationsInput | number
    openRate?: FloatFieldUpdateOperationsInput | number
    clickRate?: FloatFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    unsubscribeCount?: IntFieldUpdateOperationsInput | number
    spamReportCount?: IntFieldUpdateOperationsInput | number
    forwardCount?: IntFieldUpdateOperationsInput | number
    deviceBreakdown?: NullableJsonNullValueInput | InputJsonValue
    locationData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    totalOpens?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    totalRecipients?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    deliveryRate?: FloatFieldUpdateOperationsInput | number
    openRate?: FloatFieldUpdateOperationsInput | number
    clickRate?: FloatFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    unsubscribeCount?: IntFieldUpdateOperationsInput | number
    spamReportCount?: IntFieldUpdateOperationsInput | number
    forwardCount?: IntFieldUpdateOperationsInput | number
    deviceBreakdown?: NullableJsonNullValueInput | InputJsonValue
    locationData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanFilter<$PrismaModel> | $Enums.Plan
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumPlanSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanSubscriptionStatus | EnumPlanSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlanSubscriptionStatus[] | ListEnumPlanSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanSubscriptionStatus[] | ListEnumPlanSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanSubscriptionStatusFilter<$PrismaModel> | $Enums.PlanSubscriptionStatus
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type BlogAIGenerationListRelationFilter = {
    every?: BlogAIGenerationWhereInput
    some?: BlogAIGenerationWhereInput
    none?: BlogAIGenerationWhereInput
  }

  export type BlogCommentListRelationFilter = {
    every?: BlogCommentWhereInput
    some?: BlogCommentWhereInput
    none?: BlogCommentWhereInput
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type BlogPostViewListRelationFilter = {
    every?: BlogPostViewWhereInput
    some?: BlogPostViewWhereInput
    none?: BlogPostViewWhereInput
  }

  export type EmailListRelationFilter = {
    every?: EmailWhereInput
    some?: EmailWhereInput
    none?: EmailWhereInput
  }

  export type FlagedBlogPostListRelationFilter = {
    every?: FlagedBlogPostWhereInput
    some?: FlagedBlogPostWhereInput
    none?: FlagedBlogPostWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type KycNullableScalarRelationFilter = {
    is?: KycWhereInput | null
    isNot?: KycWhereInput | null
  }

  export type MembershipUsageListRelationFilter = {
    every?: MembershipUsageWhereInput
    some?: MembershipUsageWhereInput
    none?: MembershipUsageWhereInput
  }

  export type EmailNotificationListRelationFilter = {
    every?: EmailNotificationWhereInput
    some?: EmailNotificationWhereInput
    none?: EmailNotificationWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type ReportedCommentListRelationFilter = {
    every?: ReportedCommentWhereInput
    some?: ReportedCommentWhereInput
    none?: ReportedCommentWhereInput
  }

  export type EmailTemplateListRelationFilter = {
    every?: EmailTemplateWhereInput
    some?: EmailTemplateWhereInput
    none?: EmailTemplateWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogAIGenerationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlagedBlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembershipUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportedCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    imageUrl?: SortOrder
    paystackCustomerId?: SortOrder
    paystackSubscriptionId?: SortOrder
    plan?: SortOrder
    role?: SortOrder
    subscriptionStatus?: SortOrder
    accType?: SortOrder
    currentPeriodEnd?: SortOrder
    organization?: SortOrder
    website?: SortOrder
    kycStatus?: SortOrder
    SenderName?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    lastPaymentDate?: SortOrder
    nextPaymentDate?: SortOrder
    successfulPayments?: SortOrder
    failedAttempts?: SortOrder
    subscriberLimit?: SortOrder
    emailLimit?: SortOrder
    blogPostLimit?: SortOrder
    aiGenerationLimit?: SortOrder
    termsAndConditionsAccepted?: SortOrder
    approvedKYC?: SortOrder
    isEmailVerified?: SortOrder
    isLoggedIn?: SortOrder
    is2FAEnabled?: SortOrder
    createdAt?: SortOrder
    loggedInAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    amount?: SortOrder
    successfulPayments?: SortOrder
    failedAttempts?: SortOrder
    subscriberLimit?: SortOrder
    emailLimit?: SortOrder
    blogPostLimit?: SortOrder
    aiGenerationLimit?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    imageUrl?: SortOrder
    paystackCustomerId?: SortOrder
    paystackSubscriptionId?: SortOrder
    plan?: SortOrder
    role?: SortOrder
    subscriptionStatus?: SortOrder
    accType?: SortOrder
    currentPeriodEnd?: SortOrder
    organization?: SortOrder
    website?: SortOrder
    kycStatus?: SortOrder
    SenderName?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    lastPaymentDate?: SortOrder
    nextPaymentDate?: SortOrder
    successfulPayments?: SortOrder
    failedAttempts?: SortOrder
    subscriberLimit?: SortOrder
    emailLimit?: SortOrder
    blogPostLimit?: SortOrder
    aiGenerationLimit?: SortOrder
    termsAndConditionsAccepted?: SortOrder
    approvedKYC?: SortOrder
    isEmailVerified?: SortOrder
    isLoggedIn?: SortOrder
    is2FAEnabled?: SortOrder
    createdAt?: SortOrder
    loggedInAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    imageUrl?: SortOrder
    paystackCustomerId?: SortOrder
    paystackSubscriptionId?: SortOrder
    plan?: SortOrder
    role?: SortOrder
    subscriptionStatus?: SortOrder
    accType?: SortOrder
    currentPeriodEnd?: SortOrder
    organization?: SortOrder
    website?: SortOrder
    kycStatus?: SortOrder
    SenderName?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    lastPaymentDate?: SortOrder
    nextPaymentDate?: SortOrder
    successfulPayments?: SortOrder
    failedAttempts?: SortOrder
    subscriberLimit?: SortOrder
    emailLimit?: SortOrder
    blogPostLimit?: SortOrder
    aiGenerationLimit?: SortOrder
    termsAndConditionsAccepted?: SortOrder
    approvedKYC?: SortOrder
    isEmailVerified?: SortOrder
    isLoggedIn?: SortOrder
    is2FAEnabled?: SortOrder
    createdAt?: SortOrder
    loggedInAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    amount?: SortOrder
    successfulPayments?: SortOrder
    failedAttempts?: SortOrder
    subscriberLimit?: SortOrder
    emailLimit?: SortOrder
    blogPostLimit?: SortOrder
    aiGenerationLimit?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanWithAggregatesFilter<$PrismaModel> | $Enums.Plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanFilter<$PrismaModel>
    _max?: NestedEnumPlanFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumPlanSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanSubscriptionStatus | EnumPlanSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlanSubscriptionStatus[] | ListEnumPlanSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanSubscriptionStatus[] | ListEnumPlanSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlanSubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumPlanSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    jti?: SortOrder
    userId?: SortOrder
    hashed?: SortOrder
    userAgent?: SortOrder
    ip?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    jti?: SortOrder
    userId?: SortOrder
    hashed?: SortOrder
    userAgent?: SortOrder
    ip?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    jti?: SortOrder
    userId?: SortOrder
    hashed?: SortOrder
    userAgent?: SortOrder
    ip?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OTPCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    attempts?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTPAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type OTPMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    attempts?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTPMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    attempts?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTPSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    invoiceUrl?: SortOrder
    date?: SortOrder
    externalId?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    invoiceUrl?: SortOrder
    date?: SortOrder
    externalId?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    invoiceUrl?: SortOrder
    date?: SortOrder
    externalId?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ThirdPartyOTPCountOrderByAggregateInput = {
    email?: SortOrder
    code?: SortOrder
    otpType?: SortOrder
    expiresAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
  }

  export type ThirdPartyOTPAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type ThirdPartyOTPMaxOrderByAggregateInput = {
    email?: SortOrder
    code?: SortOrder
    otpType?: SortOrder
    expiresAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
  }

  export type ThirdPartyOTPMinOrderByAggregateInput = {
    email?: SortOrder
    code?: SortOrder
    otpType?: SortOrder
    expiresAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
  }

  export type ThirdPartyOTPSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    jwt?: SortOrder
    createdAt?: SortOrder
    isTrial?: SortOrder
    expiresAt?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    jwt?: SortOrder
    createdAt?: SortOrder
    isTrial?: SortOrder
    expiresAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    jwt?: SortOrder
    createdAt?: SortOrder
    isTrial?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumKYCAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCAccountType | EnumKYCAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KYCAccountType[] | ListEnumKYCAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCAccountType[] | ListEnumKYCAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCAccountTypeFilter<$PrismaModel> | $Enums.KYCAccountType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type KYCDocumentListRelationFilter = {
    every?: KYCDocumentWhereInput
    some?: KYCDocumentWhereInput
    none?: KYCDocumentWhereInput
  }

  export type KYCDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KycCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    status?: SortOrder
    levels?: SortOrder
    documents?: SortOrder
    livePhoto?: SortOrder
    reviewedTime?: SortOrder
    reviewedBy?: SortOrder
    rejectedResponse?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KycMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    status?: SortOrder
    livePhoto?: SortOrder
    reviewedTime?: SortOrder
    reviewedBy?: SortOrder
    rejectedResponse?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KycMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    status?: SortOrder
    livePhoto?: SortOrder
    reviewedTime?: SortOrder
    reviewedBy?: SortOrder
    rejectedResponse?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumKYCAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCAccountType | EnumKYCAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KYCAccountType[] | ListEnumKYCAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCAccountType[] | ListEnumKYCAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.KYCAccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumKYCAccountTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type KycScalarRelationFilter = {
    is?: KycWhereInput
    isNot?: KycWhereInput
  }

  export type KYCDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    kycId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    key?: SortOrder
    uploadedAt?: SortOrder
  }

  export type KYCDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    kycId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    key?: SortOrder
    uploadedAt?: SortOrder
  }

  export type KYCDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    kycId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    key?: SortOrder
    uploadedAt?: SortOrder
  }

  export type MembershipUsageUserId_monthCompoundUniqueInput = {
    userId: string
    month: string
  }

  export type MembershipUsageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    emailsSent?: SortOrder
    subscribersAdded?: SortOrder
    campaignsCreated?: SortOrder
    blogPostsCreated?: SortOrder
    aiGenerationsUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipUsageAvgOrderByAggregateInput = {
    emailsSent?: SortOrder
    subscribersAdded?: SortOrder
    campaignsCreated?: SortOrder
    blogPostsCreated?: SortOrder
    aiGenerationsUsed?: SortOrder
  }

  export type MembershipUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    emailsSent?: SortOrder
    subscribersAdded?: SortOrder
    campaignsCreated?: SortOrder
    blogPostsCreated?: SortOrder
    aiGenerationsUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipUsageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    emailsSent?: SortOrder
    subscribersAdded?: SortOrder
    campaignsCreated?: SortOrder
    blogPostsCreated?: SortOrder
    aiGenerationsUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipUsageSumOrderByAggregateInput = {
    emailsSent?: SortOrder
    subscribersAdded?: SortOrder
    campaignsCreated?: SortOrder
    blogPostsCreated?: SortOrder
    aiGenerationsUsed?: SortOrder
  }

  export type EnumContentFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentFormat | EnumContentFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ContentFormat[] | ListEnumContentFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentFormat[] | ListEnumContentFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumContentFormatFilter<$PrismaModel> | $Enums.ContentFormat
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type EnumPostVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityFilter<$PrismaModel> | $Enums.PostVisibility
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BlogCategoryNullableScalarRelationFilter = {
    is?: BlogCategoryWhereInput | null
    isNot?: BlogCategoryWhereInput | null
  }

  export type BlogAIGenerationNullableScalarRelationFilter = {
    is?: BlogAIGenerationWhereInput | null
    isNot?: BlogAIGenerationWhereInput | null
  }

  export type BlogTagListRelationFilter = {
    every?: BlogTagWhereInput
    some?: BlogTagWhereInput
    none?: BlogTagWhereInput
  }

  export type BlogTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    format?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    featuredImage?: SortOrder
    featuredVideo?: SortOrder
    galleryImages?: SortOrder
    authorId?: SortOrder
    authorBio?: SortOrder
    authorTitle?: SortOrder
    author?: SortOrder
    categoryId?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    seoKeywords?: SortOrder
    seoScore?: SortOrder
    shares?: SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    characterCount?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    flagReason?: SortOrder
    isFlagged?: SortOrder
    isFeatured?: SortOrder
    isPinned?: SortOrder
    allowComments?: SortOrder
    publishedAt?: SortOrder
    flaggedAt?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    generatedById?: SortOrder
  }

  export type BlogPostAvgOrderByAggregateInput = {
    seoScore?: SortOrder
    shares?: SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    characterCount?: SortOrder
    likes?: SortOrder
    views?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    format?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    featuredImage?: SortOrder
    featuredVideo?: SortOrder
    authorId?: SortOrder
    authorBio?: SortOrder
    authorTitle?: SortOrder
    author?: SortOrder
    categoryId?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    seoScore?: SortOrder
    shares?: SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    characterCount?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    flagReason?: SortOrder
    isFlagged?: SortOrder
    isFeatured?: SortOrder
    isPinned?: SortOrder
    allowComments?: SortOrder
    publishedAt?: SortOrder
    flaggedAt?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    generatedById?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    format?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    featuredImage?: SortOrder
    featuredVideo?: SortOrder
    authorId?: SortOrder
    authorBio?: SortOrder
    authorTitle?: SortOrder
    author?: SortOrder
    categoryId?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    seoScore?: SortOrder
    shares?: SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    characterCount?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    flagReason?: SortOrder
    isFlagged?: SortOrder
    isFeatured?: SortOrder
    isPinned?: SortOrder
    allowComments?: SortOrder
    publishedAt?: SortOrder
    flaggedAt?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    generatedById?: SortOrder
  }

  export type BlogPostSumOrderByAggregateInput = {
    seoScore?: SortOrder
    shares?: SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    characterCount?: SortOrder
    likes?: SortOrder
    views?: SortOrder
  }

  export type EnumContentFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentFormat | EnumContentFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ContentFormat[] | ListEnumContentFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentFormat[] | ListEnumContentFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumContentFormatWithAggregatesFilter<$PrismaModel> | $Enums.ContentFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentFormatFilter<$PrismaModel>
    _max?: NestedEnumContentFormatFilter<$PrismaModel>
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type EnumPostVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.PostVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostVisibilityFilter<$PrismaModel>
    _max?: NestedEnumPostVisibilityFilter<$PrismaModel>
  }

  export type EnumFlagStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagStatus | EnumFlagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagStatusFilter<$PrismaModel> | $Enums.FlagStatus
  }

  export type BlogPostScalarRelationFilter = {
    is?: BlogPostWhereInput
    isNot?: BlogPostWhereInput
  }

  export type FlagedBlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    comment?: SortOrder
    flaggedBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type FlagedBlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    comment?: SortOrder
    flaggedBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type FlagedBlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    comment?: SortOrder
    flaggedBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type EnumFlagStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagStatus | EnumFlagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagStatusWithAggregatesFilter<$PrismaModel> | $Enums.FlagStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlagStatusFilter<$PrismaModel>
    _max?: NestedEnumFlagStatusFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BlogPostViewPostIdUserIdExternalNameCompoundUniqueInput = {
    postId: string
    userId: string
    externalName: string
  }

  export type BlogPostViewCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    externalName?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogPostViewMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    externalName?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogPostViewMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    externalName?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogCommentNullableScalarRelationFilter = {
    is?: BlogCommentWhereInput | null
    isNot?: BlogCommentWhereInput | null
  }

  export type BlogCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    externalName?: SortOrder
    externalAvatar?: SortOrder
    likes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogCommentAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type BlogCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    externalName?: SortOrder
    externalAvatar?: SortOrder
    likes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    externalName?: SortOrder
    externalAvatar?: SortOrder
    likes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogCommentSumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type BlogCommentScalarRelationFilter = {
    is?: BlogCommentWhereInput
    isNot?: BlogCommentWhereInput
  }

  export type ReportedCommentCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    blogSlug?: SortOrder
    blogOwner?: SortOrder
    parentCommentBy?: SortOrder
    reportedBy?: SortOrder
    reason?: SortOrder
    reportedAt?: SortOrder
    resolved?: SortOrder
  }

  export type ReportedCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    blogSlug?: SortOrder
    blogOwner?: SortOrder
    parentCommentBy?: SortOrder
    reportedBy?: SortOrder
    reason?: SortOrder
    reportedAt?: SortOrder
    resolved?: SortOrder
  }

  export type ReportedCommentMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    blogSlug?: SortOrder
    blogOwner?: SortOrder
    parentCommentBy?: SortOrder
    reportedBy?: SortOrder
    reason?: SortOrder
    reportedAt?: SortOrder
    resolved?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumAIGenerationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AIGenerationStatus | EnumAIGenerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIGenerationStatus[] | ListEnumAIGenerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIGenerationStatus[] | ListEnumAIGenerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIGenerationStatusFilter<$PrismaModel> | $Enums.AIGenerationStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BlogAIGenerationCountOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    parameters?: SortOrder
    status?: SortOrder
    output?: SortOrder
    format?: SortOrder
    cost?: SortOrder
    tokensUsed?: SortOrder
    model?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BlogAIGenerationAvgOrderByAggregateInput = {
    cost?: SortOrder
    tokensUsed?: SortOrder
  }

  export type BlogAIGenerationMaxOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    status?: SortOrder
    output?: SortOrder
    format?: SortOrder
    cost?: SortOrder
    tokensUsed?: SortOrder
    model?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BlogAIGenerationMinOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    status?: SortOrder
    output?: SortOrder
    format?: SortOrder
    cost?: SortOrder
    tokensUsed?: SortOrder
    model?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BlogAIGenerationSumOrderByAggregateInput = {
    cost?: SortOrder
    tokensUsed?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumAIGenerationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIGenerationStatus | EnumAIGenerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIGenerationStatus[] | ListEnumAIGenerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIGenerationStatus[] | ListEnumAIGenerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIGenerationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AIGenerationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIGenerationStatusFilter<$PrismaModel>
    _max?: NestedEnumAIGenerationStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailsSent?: SortOrder
    recipients?: SortOrder
    openRate?: SortOrder
    clickRate?: SortOrder
    lastSentAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    emailsSent?: SortOrder
    recipients?: SortOrder
    openRate?: SortOrder
    clickRate?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailsSent?: SortOrder
    recipients?: SortOrder
    openRate?: SortOrder
    clickRate?: SortOrder
    lastSentAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailsSent?: SortOrder
    recipients?: SortOrder
    openRate?: SortOrder
    clickRate?: SortOrder
    lastSentAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    emailsSent?: SortOrder
    recipients?: SortOrder
    openRate?: SortOrder
    clickRate?: SortOrder
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type SubscriberUnique_subscriber_keyCompoundUniqueInput = {
    email: string
    newsLetterOwnerId: string
  }

  export type SubscriberCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    newsLetterOwnerId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    campaignId?: SortOrder
    pageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriberMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    newsLetterOwnerId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    campaignId?: SortOrder
    pageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriberMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    newsLetterOwnerId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    campaignId?: SortOrder
    pageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationCategory | EnumNotificationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationCategoryFilter<$PrismaModel> | $Enums.NotificationCategory
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NotificationEmailClickedLinkListRelationFilter = {
    every?: NotificationEmailClickedLinkWhereInput
    some?: NotificationEmailClickedLinkWhereInput
    none?: NotificationEmailClickedLinkWhereInput
  }

  export type NotificationEmailClickedLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    textContent?: SortOrder
    htmlContent?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    emailsSentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    recipients?: SortOrder
    bounceCount?: SortOrder
    openedByEmails?: SortOrder
    clickedByEmails?: SortOrder
    lastOpened?: SortOrder
    lastClicked?: SortOrder
    metadata?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
  }

  export type EmailNotificationAvgOrderByAggregateInput = {
    emailsSentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    recipients?: SortOrder
    bounceCount?: SortOrder
  }

  export type EmailNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    textContent?: SortOrder
    htmlContent?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    emailsSentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    recipients?: SortOrder
    bounceCount?: SortOrder
    lastOpened?: SortOrder
    lastClicked?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
  }

  export type EmailNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    textContent?: SortOrder
    htmlContent?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    emailsSentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    recipients?: SortOrder
    bounceCount?: SortOrder
    lastOpened?: SortOrder
    lastClicked?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
  }

  export type EmailNotificationSumOrderByAggregateInput = {
    emailsSentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    recipients?: SortOrder
    bounceCount?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationCategory | EnumNotificationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NotificationCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationCategoryFilter<$PrismaModel>
    _max?: NestedEnumNotificationCategoryFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type EmailScalarRelationFilter = {
    is?: EmailWhereInput
    isNot?: EmailWhereInput
  }

  export type ClickedLinkCountOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    url?: SortOrder
    clickedAt?: SortOrder
    clickedBy?: SortOrder
  }

  export type ClickedLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    url?: SortOrder
    clickedAt?: SortOrder
    clickedBy?: SortOrder
  }

  export type ClickedLinkMinOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    url?: SortOrder
    clickedAt?: SortOrder
    clickedBy?: SortOrder
  }

  export type EmailNotificationNullableScalarRelationFilter = {
    is?: EmailNotificationWhereInput | null
    isNot?: EmailNotificationWhereInput | null
  }

  export type NotificationEmailClickedLinkCountOrderByAggregateInput = {
    id?: SortOrder
    notificationEmailId?: SortOrder
    url?: SortOrder
    clickedAt?: SortOrder
    clickedBy?: SortOrder
  }

  export type NotificationEmailClickedLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationEmailId?: SortOrder
    url?: SortOrder
    clickedAt?: SortOrder
    clickedBy?: SortOrder
  }

  export type NotificationEmailClickedLinkMinOrderByAggregateInput = {
    id?: SortOrder
    notificationEmailId?: SortOrder
    url?: SortOrder
    clickedAt?: SortOrder
    clickedBy?: SortOrder
  }

  export type EnumEmailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusFilter<$PrismaModel> | $Enums.EmailStatus
  }

  export type EnumEmailTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailType | EnumEmailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTypeFilter<$PrismaModel> | $Enums.EmailType
  }

  export type EmailElementListRelationFilter = {
    every?: EmailElementWhereInput
    some?: EmailElementWhereInput
    none?: EmailElementWhereInput
  }

  export type CampaignNullableScalarRelationFilter = {
    is?: CampaignWhereInput | null
    isNot?: CampaignWhereInput | null
  }

  export type ClickedLinkListRelationFilter = {
    every?: ClickedLinkWhereInput
    some?: ClickedLinkWhereInput
    none?: ClickedLinkWhereInput
  }

  export type EmailAttachmentListRelationFilter = {
    every?: EmailAttachmentWhereInput
    some?: EmailAttachmentWhereInput
    none?: EmailAttachmentWhereInput
  }

  export type EmailRecipientListRelationFilter = {
    every?: EmailRecipientWhereInput
    some?: EmailRecipientWhereInput
    none?: EmailRecipientWhereInput
  }

  export type EmailTemplateNullableScalarRelationFilter = {
    is?: EmailTemplateWhereInput | null
    isNot?: EmailTemplateWhereInput | null
  }

  export type EmailAnalyticsNullableScalarRelationFilter = {
    is?: EmailAnalyticsWhereInput | null
    isNot?: EmailAnalyticsWhereInput | null
  }

  export type EmailElementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClickedLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailRecipientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    emailSubject?: SortOrder
    previewText?: SortOrder
    builderMode?: SortOrder
    builderData?: SortOrder
    templateUsed?: SortOrder
    status?: SortOrder
    emailType?: SortOrder
    trackOpens?: SortOrder
    trackClicks?: SortOrder
    enableUnsubscribe?: SortOrder
    scheduleDate?: SortOrder
    scheduleTime?: SortOrder
    emailsSentCount?: SortOrder
    recipients?: SortOrder
    bounceCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    sentAt?: SortOrder
    lastOpened?: SortOrder
    lastClicked?: SortOrder
    openedByIps?: SortOrder
    openedByEmails?: SortOrder
    clickedByIps?: SortOrder
    clickedByEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    newsLetterOwnerId?: SortOrder
    campaignId?: SortOrder
    messageId?: SortOrder
  }

  export type EmailAvgOrderByAggregateInput = {
    emailsSentCount?: SortOrder
    recipients?: SortOrder
    bounceCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
  }

  export type EmailMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    emailSubject?: SortOrder
    previewText?: SortOrder
    builderMode?: SortOrder
    templateUsed?: SortOrder
    status?: SortOrder
    emailType?: SortOrder
    trackOpens?: SortOrder
    trackClicks?: SortOrder
    enableUnsubscribe?: SortOrder
    scheduleDate?: SortOrder
    scheduleTime?: SortOrder
    emailsSentCount?: SortOrder
    recipients?: SortOrder
    bounceCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    sentAt?: SortOrder
    lastOpened?: SortOrder
    lastClicked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    newsLetterOwnerId?: SortOrder
    campaignId?: SortOrder
    messageId?: SortOrder
  }

  export type EmailMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    emailSubject?: SortOrder
    previewText?: SortOrder
    builderMode?: SortOrder
    templateUsed?: SortOrder
    status?: SortOrder
    emailType?: SortOrder
    trackOpens?: SortOrder
    trackClicks?: SortOrder
    enableUnsubscribe?: SortOrder
    scheduleDate?: SortOrder
    scheduleTime?: SortOrder
    emailsSentCount?: SortOrder
    recipients?: SortOrder
    bounceCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    sentAt?: SortOrder
    lastOpened?: SortOrder
    lastClicked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    newsLetterOwnerId?: SortOrder
    campaignId?: SortOrder
    messageId?: SortOrder
  }

  export type EmailSumOrderByAggregateInput = {
    emailsSentCount?: SortOrder
    recipients?: SortOrder
    bounceCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
  }

  export type EnumEmailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailStatusFilter<$PrismaModel>
    _max?: NestedEnumEmailStatusFilter<$PrismaModel>
  }

  export type EnumEmailTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailType | EnumEmailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmailType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailTypeFilter<$PrismaModel>
    _max?: NestedEnumEmailTypeFilter<$PrismaModel>
  }

  export type EnumElementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeFilter<$PrismaModel> | $Enums.ElementType
  }

  export type EmailElementEmailIdElementIdCompoundUniqueInput = {
    emailId: string
    elementId: string
  }

  export type EmailElementCountOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    elementId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    properties?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailElementAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EmailElementMaxOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    elementId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailElementMinOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    elementId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailElementSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumElementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ElementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumElementTypeFilter<$PrismaModel>
    _max?: NestedEnumElementTypeFilter<$PrismaModel>
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    elements?: SortOrder
    subject?: SortOrder
    isPublic?: SortOrder
    isFeatured?: SortOrder
    usageCount?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    category?: SortOrder
    subject?: SortOrder
    isPublic?: SortOrder
    isFeatured?: SortOrder
    usageCount?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    category?: SortOrder
    subject?: SortOrder
    isPublic?: SortOrder
    isFeatured?: SortOrder
    usageCount?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type EmailAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EmailAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumRecipientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecipientStatus | EnumRecipientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecipientStatusFilter<$PrismaModel> | $Enums.RecipientStatus
  }

  export type EmailRecipientEmailIdRecipientEmailCompoundUniqueInput = {
    emailId: string
    recipientEmail: string
  }

  export type EmailRecipientCountOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    recipientEmail?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
    bouncedAt?: SortOrder
    bounceReason?: SortOrder
    unsubscribeAt?: SortOrder
  }

  export type EmailRecipientMaxOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    recipientEmail?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
    bouncedAt?: SortOrder
    bounceReason?: SortOrder
    unsubscribeAt?: SortOrder
  }

  export type EmailRecipientMinOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    recipientEmail?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
    bouncedAt?: SortOrder
    bounceReason?: SortOrder
    unsubscribeAt?: SortOrder
  }

  export type EnumRecipientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecipientStatus | EnumRecipientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecipientStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecipientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecipientStatusFilter<$PrismaModel>
    _max?: NestedEnumRecipientStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EmailAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    totalOpens?: SortOrder
    deliveredCount?: SortOrder
    totalRecipients?: SortOrder
    uniqueOpens?: SortOrder
    totalClicks?: SortOrder
    uniqueClicks?: SortOrder
    deliveryRate?: SortOrder
    openRate?: SortOrder
    clickRate?: SortOrder
    bounceRate?: SortOrder
    unsubscribeCount?: SortOrder
    spamReportCount?: SortOrder
    forwardCount?: SortOrder
    deviceBreakdown?: SortOrder
    locationData?: SortOrder
  }

  export type EmailAnalyticsAvgOrderByAggregateInput = {
    totalOpens?: SortOrder
    deliveredCount?: SortOrder
    totalRecipients?: SortOrder
    uniqueOpens?: SortOrder
    totalClicks?: SortOrder
    uniqueClicks?: SortOrder
    deliveryRate?: SortOrder
    openRate?: SortOrder
    clickRate?: SortOrder
    bounceRate?: SortOrder
    unsubscribeCount?: SortOrder
    spamReportCount?: SortOrder
    forwardCount?: SortOrder
  }

  export type EmailAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    totalOpens?: SortOrder
    deliveredCount?: SortOrder
    totalRecipients?: SortOrder
    uniqueOpens?: SortOrder
    totalClicks?: SortOrder
    uniqueClicks?: SortOrder
    deliveryRate?: SortOrder
    openRate?: SortOrder
    clickRate?: SortOrder
    bounceRate?: SortOrder
    unsubscribeCount?: SortOrder
    spamReportCount?: SortOrder
    forwardCount?: SortOrder
  }

  export type EmailAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    totalOpens?: SortOrder
    deliveredCount?: SortOrder
    totalRecipients?: SortOrder
    uniqueOpens?: SortOrder
    totalClicks?: SortOrder
    uniqueClicks?: SortOrder
    deliveryRate?: SortOrder
    openRate?: SortOrder
    clickRate?: SortOrder
    bounceRate?: SortOrder
    unsubscribeCount?: SortOrder
    spamReportCount?: SortOrder
    forwardCount?: SortOrder
  }

  export type EmailAnalyticsSumOrderByAggregateInput = {
    totalOpens?: SortOrder
    deliveredCount?: SortOrder
    totalRecipients?: SortOrder
    uniqueOpens?: SortOrder
    totalClicks?: SortOrder
    uniqueClicks?: SortOrder
    deliveryRate?: SortOrder
    openRate?: SortOrder
    clickRate?: SortOrder
    bounceRate?: SortOrder
    unsubscribeCount?: SortOrder
    spamReportCount?: SortOrder
    forwardCount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ApiKeyCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type BlogAIGenerationCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogAIGenerationCreateWithoutUserInput, BlogAIGenerationUncheckedCreateWithoutUserInput> | BlogAIGenerationCreateWithoutUserInput[] | BlogAIGenerationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogAIGenerationCreateOrConnectWithoutUserInput | BlogAIGenerationCreateOrConnectWithoutUserInput[]
    createMany?: BlogAIGenerationCreateManyUserInputEnvelope
    connect?: BlogAIGenerationWhereUniqueInput | BlogAIGenerationWhereUniqueInput[]
  }

  export type BlogCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput> | BlogCommentCreateWithoutUserInput[] | BlogCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutUserInput | BlogCommentCreateOrConnectWithoutUserInput[]
    createMany?: BlogCommentCreateManyUserInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type BlogPostCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostViewCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogPostViewCreateWithoutUserInput, BlogPostViewUncheckedCreateWithoutUserInput> | BlogPostViewCreateWithoutUserInput[] | BlogPostViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostViewCreateOrConnectWithoutUserInput | BlogPostViewCreateOrConnectWithoutUserInput[]
    createMany?: BlogPostViewCreateManyUserInputEnvelope
    connect?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
  }

  export type EmailCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailCreateWithoutUserInput, EmailUncheckedCreateWithoutUserInput> | EmailCreateWithoutUserInput[] | EmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutUserInput | EmailCreateOrConnectWithoutUserInput[]
    createMany?: EmailCreateManyUserInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type FlagedBlogPostCreateNestedManyWithoutUserInput = {
    create?: XOR<FlagedBlogPostCreateWithoutUserInput, FlagedBlogPostUncheckedCreateWithoutUserInput> | FlagedBlogPostCreateWithoutUserInput[] | FlagedBlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlagedBlogPostCreateOrConnectWithoutUserInput | FlagedBlogPostCreateOrConnectWithoutUserInput[]
    createMany?: FlagedBlogPostCreateManyUserInputEnvelope
    connect?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type KycCreateNestedOneWithoutUserInput = {
    create?: XOR<KycCreateWithoutUserInput, KycUncheckedCreateWithoutUserInput>
    connectOrCreate?: KycCreateOrConnectWithoutUserInput
    connect?: KycWhereUniqueInput
  }

  export type MembershipUsageCreateNestedManyWithoutUserInput = {
    create?: XOR<MembershipUsageCreateWithoutUserInput, MembershipUsageUncheckedCreateWithoutUserInput> | MembershipUsageCreateWithoutUserInput[] | MembershipUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipUsageCreateOrConnectWithoutUserInput | MembershipUsageCreateOrConnectWithoutUserInput[]
    createMany?: MembershipUsageCreateManyUserInputEnvelope
    connect?: MembershipUsageWhereUniqueInput | MembershipUsageWhereUniqueInput[]
  }

  export type EmailNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailNotificationCreateWithoutUserInput, EmailNotificationUncheckedCreateWithoutUserInput> | EmailNotificationCreateWithoutUserInput[] | EmailNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailNotificationCreateOrConnectWithoutUserInput | EmailNotificationCreateOrConnectWithoutUserInput[]
    createMany?: EmailNotificationCreateManyUserInputEnvelope
    connect?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type ReportedCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportedCommentCreateWithoutUserInput, ReportedCommentUncheckedCreateWithoutUserInput> | ReportedCommentCreateWithoutUserInput[] | ReportedCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportedCommentCreateOrConnectWithoutUserInput | ReportedCommentCreateOrConnectWithoutUserInput[]
    createMany?: ReportedCommentCreateManyUserInputEnvelope
    connect?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
  }

  export type EmailTemplateCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput> | EmailTemplateCreateWithoutUserInput[] | EmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutUserInput | EmailTemplateCreateOrConnectWithoutUserInput[]
    createMany?: EmailTemplateCreateManyUserInputEnvelope
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogAIGenerationCreateWithoutUserInput, BlogAIGenerationUncheckedCreateWithoutUserInput> | BlogAIGenerationCreateWithoutUserInput[] | BlogAIGenerationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogAIGenerationCreateOrConnectWithoutUserInput | BlogAIGenerationCreateOrConnectWithoutUserInput[]
    createMany?: BlogAIGenerationCreateManyUserInputEnvelope
    connect?: BlogAIGenerationWhereUniqueInput | BlogAIGenerationWhereUniqueInput[]
  }

  export type BlogCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput> | BlogCommentCreateWithoutUserInput[] | BlogCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutUserInput | BlogCommentCreateOrConnectWithoutUserInput[]
    createMany?: BlogCommentCreateManyUserInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostViewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogPostViewCreateWithoutUserInput, BlogPostViewUncheckedCreateWithoutUserInput> | BlogPostViewCreateWithoutUserInput[] | BlogPostViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostViewCreateOrConnectWithoutUserInput | BlogPostViewCreateOrConnectWithoutUserInput[]
    createMany?: BlogPostViewCreateManyUserInputEnvelope
    connect?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
  }

  export type EmailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailCreateWithoutUserInput, EmailUncheckedCreateWithoutUserInput> | EmailCreateWithoutUserInput[] | EmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutUserInput | EmailCreateOrConnectWithoutUserInput[]
    createMany?: EmailCreateManyUserInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FlagedBlogPostCreateWithoutUserInput, FlagedBlogPostUncheckedCreateWithoutUserInput> | FlagedBlogPostCreateWithoutUserInput[] | FlagedBlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlagedBlogPostCreateOrConnectWithoutUserInput | FlagedBlogPostCreateOrConnectWithoutUserInput[]
    createMany?: FlagedBlogPostCreateManyUserInputEnvelope
    connect?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type KycUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<KycCreateWithoutUserInput, KycUncheckedCreateWithoutUserInput>
    connectOrCreate?: KycCreateOrConnectWithoutUserInput
    connect?: KycWhereUniqueInput
  }

  export type MembershipUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MembershipUsageCreateWithoutUserInput, MembershipUsageUncheckedCreateWithoutUserInput> | MembershipUsageCreateWithoutUserInput[] | MembershipUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipUsageCreateOrConnectWithoutUserInput | MembershipUsageCreateOrConnectWithoutUserInput[]
    createMany?: MembershipUsageCreateManyUserInputEnvelope
    connect?: MembershipUsageWhereUniqueInput | MembershipUsageWhereUniqueInput[]
  }

  export type EmailNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailNotificationCreateWithoutUserInput, EmailNotificationUncheckedCreateWithoutUserInput> | EmailNotificationCreateWithoutUserInput[] | EmailNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailNotificationCreateOrConnectWithoutUserInput | EmailNotificationCreateOrConnectWithoutUserInput[]
    createMany?: EmailNotificationCreateManyUserInputEnvelope
    connect?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type ReportedCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportedCommentCreateWithoutUserInput, ReportedCommentUncheckedCreateWithoutUserInput> | ReportedCommentCreateWithoutUserInput[] | ReportedCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportedCommentCreateOrConnectWithoutUserInput | ReportedCommentCreateOrConnectWithoutUserInput[]
    createMany?: ReportedCommentCreateManyUserInputEnvelope
    connect?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
  }

  export type EmailTemplateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput> | EmailTemplateCreateWithoutUserInput[] | EmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutUserInput | EmailTemplateCreateOrConnectWithoutUserInput[]
    createMany?: EmailTemplateCreateManyUserInputEnvelope
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumPlanFieldUpdateOperationsInput = {
    set?: $Enums.Plan
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumPlanSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.PlanSubscriptionStatus
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumKYCStatusFieldUpdateOperationsInput = {
    set?: $Enums.KYCStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ApiKeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type BlogAIGenerationUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogAIGenerationCreateWithoutUserInput, BlogAIGenerationUncheckedCreateWithoutUserInput> | BlogAIGenerationCreateWithoutUserInput[] | BlogAIGenerationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogAIGenerationCreateOrConnectWithoutUserInput | BlogAIGenerationCreateOrConnectWithoutUserInput[]
    upsert?: BlogAIGenerationUpsertWithWhereUniqueWithoutUserInput | BlogAIGenerationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogAIGenerationCreateManyUserInputEnvelope
    set?: BlogAIGenerationWhereUniqueInput | BlogAIGenerationWhereUniqueInput[]
    disconnect?: BlogAIGenerationWhereUniqueInput | BlogAIGenerationWhereUniqueInput[]
    delete?: BlogAIGenerationWhereUniqueInput | BlogAIGenerationWhereUniqueInput[]
    connect?: BlogAIGenerationWhereUniqueInput | BlogAIGenerationWhereUniqueInput[]
    update?: BlogAIGenerationUpdateWithWhereUniqueWithoutUserInput | BlogAIGenerationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogAIGenerationUpdateManyWithWhereWithoutUserInput | BlogAIGenerationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogAIGenerationScalarWhereInput | BlogAIGenerationScalarWhereInput[]
  }

  export type BlogCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput> | BlogCommentCreateWithoutUserInput[] | BlogCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutUserInput | BlogCommentCreateOrConnectWithoutUserInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutUserInput | BlogCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogCommentCreateManyUserInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutUserInput | BlogCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutUserInput | BlogCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type BlogPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutUserInput | BlogPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutUserInput | BlogPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutUserInput | BlogPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostViewUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogPostViewCreateWithoutUserInput, BlogPostViewUncheckedCreateWithoutUserInput> | BlogPostViewCreateWithoutUserInput[] | BlogPostViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostViewCreateOrConnectWithoutUserInput | BlogPostViewCreateOrConnectWithoutUserInput[]
    upsert?: BlogPostViewUpsertWithWhereUniqueWithoutUserInput | BlogPostViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogPostViewCreateManyUserInputEnvelope
    set?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    disconnect?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    delete?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    connect?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    update?: BlogPostViewUpdateWithWhereUniqueWithoutUserInput | BlogPostViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogPostViewUpdateManyWithWhereWithoutUserInput | BlogPostViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogPostViewScalarWhereInput | BlogPostViewScalarWhereInput[]
  }

  export type EmailUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailCreateWithoutUserInput, EmailUncheckedCreateWithoutUserInput> | EmailCreateWithoutUserInput[] | EmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutUserInput | EmailCreateOrConnectWithoutUserInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutUserInput | EmailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailCreateManyUserInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutUserInput | EmailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutUserInput | EmailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type FlagedBlogPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlagedBlogPostCreateWithoutUserInput, FlagedBlogPostUncheckedCreateWithoutUserInput> | FlagedBlogPostCreateWithoutUserInput[] | FlagedBlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlagedBlogPostCreateOrConnectWithoutUserInput | FlagedBlogPostCreateOrConnectWithoutUserInput[]
    upsert?: FlagedBlogPostUpsertWithWhereUniqueWithoutUserInput | FlagedBlogPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlagedBlogPostCreateManyUserInputEnvelope
    set?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    disconnect?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    delete?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    connect?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    update?: FlagedBlogPostUpdateWithWhereUniqueWithoutUserInput | FlagedBlogPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlagedBlogPostUpdateManyWithWhereWithoutUserInput | FlagedBlogPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlagedBlogPostScalarWhereInput | FlagedBlogPostScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type KycUpdateOneWithoutUserNestedInput = {
    create?: XOR<KycCreateWithoutUserInput, KycUncheckedCreateWithoutUserInput>
    connectOrCreate?: KycCreateOrConnectWithoutUserInput
    upsert?: KycUpsertWithoutUserInput
    disconnect?: KycWhereInput | boolean
    delete?: KycWhereInput | boolean
    connect?: KycWhereUniqueInput
    update?: XOR<XOR<KycUpdateToOneWithWhereWithoutUserInput, KycUpdateWithoutUserInput>, KycUncheckedUpdateWithoutUserInput>
  }

  export type MembershipUsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MembershipUsageCreateWithoutUserInput, MembershipUsageUncheckedCreateWithoutUserInput> | MembershipUsageCreateWithoutUserInput[] | MembershipUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipUsageCreateOrConnectWithoutUserInput | MembershipUsageCreateOrConnectWithoutUserInput[]
    upsert?: MembershipUsageUpsertWithWhereUniqueWithoutUserInput | MembershipUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MembershipUsageCreateManyUserInputEnvelope
    set?: MembershipUsageWhereUniqueInput | MembershipUsageWhereUniqueInput[]
    disconnect?: MembershipUsageWhereUniqueInput | MembershipUsageWhereUniqueInput[]
    delete?: MembershipUsageWhereUniqueInput | MembershipUsageWhereUniqueInput[]
    connect?: MembershipUsageWhereUniqueInput | MembershipUsageWhereUniqueInput[]
    update?: MembershipUsageUpdateWithWhereUniqueWithoutUserInput | MembershipUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MembershipUsageUpdateManyWithWhereWithoutUserInput | MembershipUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MembershipUsageScalarWhereInput | MembershipUsageScalarWhereInput[]
  }

  export type EmailNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailNotificationCreateWithoutUserInput, EmailNotificationUncheckedCreateWithoutUserInput> | EmailNotificationCreateWithoutUserInput[] | EmailNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailNotificationCreateOrConnectWithoutUserInput | EmailNotificationCreateOrConnectWithoutUserInput[]
    upsert?: EmailNotificationUpsertWithWhereUniqueWithoutUserInput | EmailNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailNotificationCreateManyUserInputEnvelope
    set?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    disconnect?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    delete?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    connect?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    update?: EmailNotificationUpdateWithWhereUniqueWithoutUserInput | EmailNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailNotificationUpdateManyWithWhereWithoutUserInput | EmailNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailNotificationScalarWhereInput | EmailNotificationScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type ReportedCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportedCommentCreateWithoutUserInput, ReportedCommentUncheckedCreateWithoutUserInput> | ReportedCommentCreateWithoutUserInput[] | ReportedCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportedCommentCreateOrConnectWithoutUserInput | ReportedCommentCreateOrConnectWithoutUserInput[]
    upsert?: ReportedCommentUpsertWithWhereUniqueWithoutUserInput | ReportedCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportedCommentCreateManyUserInputEnvelope
    set?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    disconnect?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    delete?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    connect?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    update?: ReportedCommentUpdateWithWhereUniqueWithoutUserInput | ReportedCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportedCommentUpdateManyWithWhereWithoutUserInput | ReportedCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportedCommentScalarWhereInput | ReportedCommentScalarWhereInput[]
  }

  export type EmailTemplateUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput> | EmailTemplateCreateWithoutUserInput[] | EmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutUserInput | EmailTemplateCreateOrConnectWithoutUserInput[]
    upsert?: EmailTemplateUpsertWithWhereUniqueWithoutUserInput | EmailTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailTemplateCreateManyUserInputEnvelope
    set?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    disconnect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    delete?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    update?: EmailTemplateUpdateWithWhereUniqueWithoutUserInput | EmailTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailTemplateUpdateManyWithWhereWithoutUserInput | EmailTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogAIGenerationCreateWithoutUserInput, BlogAIGenerationUncheckedCreateWithoutUserInput> | BlogAIGenerationCreateWithoutUserInput[] | BlogAIGenerationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogAIGenerationCreateOrConnectWithoutUserInput | BlogAIGenerationCreateOrConnectWithoutUserInput[]
    upsert?: BlogAIGenerationUpsertWithWhereUniqueWithoutUserInput | BlogAIGenerationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogAIGenerationCreateManyUserInputEnvelope
    set?: BlogAIGenerationWhereUniqueInput | BlogAIGenerationWhereUniqueInput[]
    disconnect?: BlogAIGenerationWhereUniqueInput | BlogAIGenerationWhereUniqueInput[]
    delete?: BlogAIGenerationWhereUniqueInput | BlogAIGenerationWhereUniqueInput[]
    connect?: BlogAIGenerationWhereUniqueInput | BlogAIGenerationWhereUniqueInput[]
    update?: BlogAIGenerationUpdateWithWhereUniqueWithoutUserInput | BlogAIGenerationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogAIGenerationUpdateManyWithWhereWithoutUserInput | BlogAIGenerationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogAIGenerationScalarWhereInput | BlogAIGenerationScalarWhereInput[]
  }

  export type BlogCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput> | BlogCommentCreateWithoutUserInput[] | BlogCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutUserInput | BlogCommentCreateOrConnectWithoutUserInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutUserInput | BlogCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogCommentCreateManyUserInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutUserInput | BlogCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutUserInput | BlogCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutUserInput | BlogPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutUserInput | BlogPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutUserInput | BlogPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostViewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogPostViewCreateWithoutUserInput, BlogPostViewUncheckedCreateWithoutUserInput> | BlogPostViewCreateWithoutUserInput[] | BlogPostViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostViewCreateOrConnectWithoutUserInput | BlogPostViewCreateOrConnectWithoutUserInput[]
    upsert?: BlogPostViewUpsertWithWhereUniqueWithoutUserInput | BlogPostViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogPostViewCreateManyUserInputEnvelope
    set?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    disconnect?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    delete?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    connect?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    update?: BlogPostViewUpdateWithWhereUniqueWithoutUserInput | BlogPostViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogPostViewUpdateManyWithWhereWithoutUserInput | BlogPostViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogPostViewScalarWhereInput | BlogPostViewScalarWhereInput[]
  }

  export type EmailUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailCreateWithoutUserInput, EmailUncheckedCreateWithoutUserInput> | EmailCreateWithoutUserInput[] | EmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutUserInput | EmailCreateOrConnectWithoutUserInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutUserInput | EmailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailCreateManyUserInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutUserInput | EmailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutUserInput | EmailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlagedBlogPostCreateWithoutUserInput, FlagedBlogPostUncheckedCreateWithoutUserInput> | FlagedBlogPostCreateWithoutUserInput[] | FlagedBlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlagedBlogPostCreateOrConnectWithoutUserInput | FlagedBlogPostCreateOrConnectWithoutUserInput[]
    upsert?: FlagedBlogPostUpsertWithWhereUniqueWithoutUserInput | FlagedBlogPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlagedBlogPostCreateManyUserInputEnvelope
    set?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    disconnect?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    delete?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    connect?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    update?: FlagedBlogPostUpdateWithWhereUniqueWithoutUserInput | FlagedBlogPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlagedBlogPostUpdateManyWithWhereWithoutUserInput | FlagedBlogPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlagedBlogPostScalarWhereInput | FlagedBlogPostScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type KycUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<KycCreateWithoutUserInput, KycUncheckedCreateWithoutUserInput>
    connectOrCreate?: KycCreateOrConnectWithoutUserInput
    upsert?: KycUpsertWithoutUserInput
    disconnect?: KycWhereInput | boolean
    delete?: KycWhereInput | boolean
    connect?: KycWhereUniqueInput
    update?: XOR<XOR<KycUpdateToOneWithWhereWithoutUserInput, KycUpdateWithoutUserInput>, KycUncheckedUpdateWithoutUserInput>
  }

  export type MembershipUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MembershipUsageCreateWithoutUserInput, MembershipUsageUncheckedCreateWithoutUserInput> | MembershipUsageCreateWithoutUserInput[] | MembershipUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipUsageCreateOrConnectWithoutUserInput | MembershipUsageCreateOrConnectWithoutUserInput[]
    upsert?: MembershipUsageUpsertWithWhereUniqueWithoutUserInput | MembershipUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MembershipUsageCreateManyUserInputEnvelope
    set?: MembershipUsageWhereUniqueInput | MembershipUsageWhereUniqueInput[]
    disconnect?: MembershipUsageWhereUniqueInput | MembershipUsageWhereUniqueInput[]
    delete?: MembershipUsageWhereUniqueInput | MembershipUsageWhereUniqueInput[]
    connect?: MembershipUsageWhereUniqueInput | MembershipUsageWhereUniqueInput[]
    update?: MembershipUsageUpdateWithWhereUniqueWithoutUserInput | MembershipUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MembershipUsageUpdateManyWithWhereWithoutUserInput | MembershipUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MembershipUsageScalarWhereInput | MembershipUsageScalarWhereInput[]
  }

  export type EmailNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailNotificationCreateWithoutUserInput, EmailNotificationUncheckedCreateWithoutUserInput> | EmailNotificationCreateWithoutUserInput[] | EmailNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailNotificationCreateOrConnectWithoutUserInput | EmailNotificationCreateOrConnectWithoutUserInput[]
    upsert?: EmailNotificationUpsertWithWhereUniqueWithoutUserInput | EmailNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailNotificationCreateManyUserInputEnvelope
    set?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    disconnect?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    delete?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    connect?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    update?: EmailNotificationUpdateWithWhereUniqueWithoutUserInput | EmailNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailNotificationUpdateManyWithWhereWithoutUserInput | EmailNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailNotificationScalarWhereInput | EmailNotificationScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type ReportedCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportedCommentCreateWithoutUserInput, ReportedCommentUncheckedCreateWithoutUserInput> | ReportedCommentCreateWithoutUserInput[] | ReportedCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportedCommentCreateOrConnectWithoutUserInput | ReportedCommentCreateOrConnectWithoutUserInput[]
    upsert?: ReportedCommentUpsertWithWhereUniqueWithoutUserInput | ReportedCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportedCommentCreateManyUserInputEnvelope
    set?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    disconnect?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    delete?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    connect?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    update?: ReportedCommentUpdateWithWhereUniqueWithoutUserInput | ReportedCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportedCommentUpdateManyWithWhereWithoutUserInput | ReportedCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportedCommentScalarWhereInput | ReportedCommentScalarWhereInput[]
  }

  export type EmailTemplateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput> | EmailTemplateCreateWithoutUserInput[] | EmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutUserInput | EmailTemplateCreateOrConnectWithoutUserInput[]
    upsert?: EmailTemplateUpsertWithWhereUniqueWithoutUserInput | EmailTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailTemplateCreateManyUserInputEnvelope
    set?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    disconnect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    delete?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    update?: EmailTemplateUpdateWithWhereUniqueWithoutUserInput | EmailTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailTemplateUpdateManyWithWhereWithoutUserInput | EmailTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTokensInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTokensNestedInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    upsert?: UserUpsertWithoutTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokensInput, UserUpdateWithoutTokensInput>, UserUncheckedUpdateWithoutTokensInput>
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserCreateNestedOneWithoutKycInput = {
    create?: XOR<UserCreateWithoutKycInput, UserUncheckedCreateWithoutKycInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycInput
    connect?: UserWhereUniqueInput
  }

  export type KYCDocumentCreateNestedManyWithoutKycInput = {
    create?: XOR<KYCDocumentCreateWithoutKycInput, KYCDocumentUncheckedCreateWithoutKycInput> | KYCDocumentCreateWithoutKycInput[] | KYCDocumentUncheckedCreateWithoutKycInput[]
    connectOrCreate?: KYCDocumentCreateOrConnectWithoutKycInput | KYCDocumentCreateOrConnectWithoutKycInput[]
    createMany?: KYCDocumentCreateManyKycInputEnvelope
    connect?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
  }

  export type KYCDocumentUncheckedCreateNestedManyWithoutKycInput = {
    create?: XOR<KYCDocumentCreateWithoutKycInput, KYCDocumentUncheckedCreateWithoutKycInput> | KYCDocumentCreateWithoutKycInput[] | KYCDocumentUncheckedCreateWithoutKycInput[]
    connectOrCreate?: KYCDocumentCreateOrConnectWithoutKycInput | KYCDocumentCreateOrConnectWithoutKycInput[]
    createMany?: KYCDocumentCreateManyKycInputEnvelope
    connect?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
  }

  export type EnumKYCAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.KYCAccountType
  }

  export type UserUpdateOneRequiredWithoutKycNestedInput = {
    create?: XOR<UserCreateWithoutKycInput, UserUncheckedCreateWithoutKycInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycInput
    upsert?: UserUpsertWithoutKycInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKycInput, UserUpdateWithoutKycInput>, UserUncheckedUpdateWithoutKycInput>
  }

  export type KYCDocumentUpdateManyWithoutKycNestedInput = {
    create?: XOR<KYCDocumentCreateWithoutKycInput, KYCDocumentUncheckedCreateWithoutKycInput> | KYCDocumentCreateWithoutKycInput[] | KYCDocumentUncheckedCreateWithoutKycInput[]
    connectOrCreate?: KYCDocumentCreateOrConnectWithoutKycInput | KYCDocumentCreateOrConnectWithoutKycInput[]
    upsert?: KYCDocumentUpsertWithWhereUniqueWithoutKycInput | KYCDocumentUpsertWithWhereUniqueWithoutKycInput[]
    createMany?: KYCDocumentCreateManyKycInputEnvelope
    set?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    disconnect?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    delete?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    connect?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    update?: KYCDocumentUpdateWithWhereUniqueWithoutKycInput | KYCDocumentUpdateWithWhereUniqueWithoutKycInput[]
    updateMany?: KYCDocumentUpdateManyWithWhereWithoutKycInput | KYCDocumentUpdateManyWithWhereWithoutKycInput[]
    deleteMany?: KYCDocumentScalarWhereInput | KYCDocumentScalarWhereInput[]
  }

  export type KYCDocumentUncheckedUpdateManyWithoutKycNestedInput = {
    create?: XOR<KYCDocumentCreateWithoutKycInput, KYCDocumentUncheckedCreateWithoutKycInput> | KYCDocumentCreateWithoutKycInput[] | KYCDocumentUncheckedCreateWithoutKycInput[]
    connectOrCreate?: KYCDocumentCreateOrConnectWithoutKycInput | KYCDocumentCreateOrConnectWithoutKycInput[]
    upsert?: KYCDocumentUpsertWithWhereUniqueWithoutKycInput | KYCDocumentUpsertWithWhereUniqueWithoutKycInput[]
    createMany?: KYCDocumentCreateManyKycInputEnvelope
    set?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    disconnect?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    delete?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    connect?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    update?: KYCDocumentUpdateWithWhereUniqueWithoutKycInput | KYCDocumentUpdateWithWhereUniqueWithoutKycInput[]
    updateMany?: KYCDocumentUpdateManyWithWhereWithoutKycInput | KYCDocumentUpdateManyWithWhereWithoutKycInput[]
    deleteMany?: KYCDocumentScalarWhereInput | KYCDocumentScalarWhereInput[]
  }

  export type KycCreateNestedOneWithoutKycDocumentsInput = {
    create?: XOR<KycCreateWithoutKycDocumentsInput, KycUncheckedCreateWithoutKycDocumentsInput>
    connectOrCreate?: KycCreateOrConnectWithoutKycDocumentsInput
    connect?: KycWhereUniqueInput
  }

  export type KycUpdateOneRequiredWithoutKycDocumentsNestedInput = {
    create?: XOR<KycCreateWithoutKycDocumentsInput, KycUncheckedCreateWithoutKycDocumentsInput>
    connectOrCreate?: KycCreateOrConnectWithoutKycDocumentsInput
    upsert?: KycUpsertWithoutKycDocumentsInput
    connect?: KycWhereUniqueInput
    update?: XOR<XOR<KycUpdateToOneWithWhereWithoutKycDocumentsInput, KycUpdateWithoutKycDocumentsInput>, KycUncheckedUpdateWithoutKycDocumentsInput>
  }

  export type UserCreateNestedOneWithoutUsageInput = {
    create?: XOR<UserCreateWithoutUsageInput, UserUncheckedCreateWithoutUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsageNestedInput = {
    create?: XOR<UserCreateWithoutUsageInput, UserUncheckedCreateWithoutUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageInput
    upsert?: UserUpsertWithoutUsageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsageInput, UserUpdateWithoutUsageInput>, UserUncheckedUpdateWithoutUsageInput>
  }

  export type BlogPostCreategalleryImagesInput = {
    set: string[]
  }

  export type BlogPostCreateseoKeywordsInput = {
    set: string[]
  }

  export type BlogCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput> | BlogCommentCreateWithoutPostInput[] | BlogCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutPostInput | BlogCommentCreateOrConnectWithoutPostInput[]
    createMany?: BlogCommentCreateManyPostInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
  }

  export type BlogCategoryCreateNestedOneWithoutPostsInput = {
    create?: XOR<BlogCategoryCreateWithoutPostsInput, BlogCategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: BlogCategoryCreateOrConnectWithoutPostsInput
    connect?: BlogCategoryWhereUniqueInput
  }

  export type BlogAIGenerationCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<BlogAIGenerationCreateWithoutBlogPostsInput, BlogAIGenerationUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: BlogAIGenerationCreateOrConnectWithoutBlogPostsInput
    connect?: BlogAIGenerationWhereUniqueInput
  }

  export type BlogPostViewCreateNestedManyWithoutPostInput = {
    create?: XOR<BlogPostViewCreateWithoutPostInput, BlogPostViewUncheckedCreateWithoutPostInput> | BlogPostViewCreateWithoutPostInput[] | BlogPostViewUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogPostViewCreateOrConnectWithoutPostInput | BlogPostViewCreateOrConnectWithoutPostInput[]
    createMany?: BlogPostViewCreateManyPostInputEnvelope
    connect?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
  }

  export type FlagedBlogPostCreateNestedManyWithoutPostInput = {
    create?: XOR<FlagedBlogPostCreateWithoutPostInput, FlagedBlogPostUncheckedCreateWithoutPostInput> | FlagedBlogPostCreateWithoutPostInput[] | FlagedBlogPostUncheckedCreateWithoutPostInput[]
    connectOrCreate?: FlagedBlogPostCreateOrConnectWithoutPostInput | FlagedBlogPostCreateOrConnectWithoutPostInput[]
    createMany?: FlagedBlogPostCreateManyPostInputEnvelope
    connect?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
  }

  export type BlogTagCreateNestedManyWithoutPostsInput = {
    create?: XOR<BlogTagCreateWithoutPostsInput, BlogTagUncheckedCreateWithoutPostsInput> | BlogTagCreateWithoutPostsInput[] | BlogTagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutPostsInput | BlogTagCreateOrConnectWithoutPostsInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
  }

  export type BlogCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput> | BlogCommentCreateWithoutPostInput[] | BlogCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutPostInput | BlogCommentCreateOrConnectWithoutPostInput[]
    createMany?: BlogCommentCreateManyPostInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type BlogPostViewUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<BlogPostViewCreateWithoutPostInput, BlogPostViewUncheckedCreateWithoutPostInput> | BlogPostViewCreateWithoutPostInput[] | BlogPostViewUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogPostViewCreateOrConnectWithoutPostInput | BlogPostViewCreateOrConnectWithoutPostInput[]
    createMany?: BlogPostViewCreateManyPostInputEnvelope
    connect?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
  }

  export type FlagedBlogPostUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<FlagedBlogPostCreateWithoutPostInput, FlagedBlogPostUncheckedCreateWithoutPostInput> | FlagedBlogPostCreateWithoutPostInput[] | FlagedBlogPostUncheckedCreateWithoutPostInput[]
    connectOrCreate?: FlagedBlogPostCreateOrConnectWithoutPostInput | FlagedBlogPostCreateOrConnectWithoutPostInput[]
    createMany?: FlagedBlogPostCreateManyPostInputEnvelope
    connect?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
  }

  export type BlogTagUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<BlogTagCreateWithoutPostsInput, BlogTagUncheckedCreateWithoutPostsInput> | BlogTagCreateWithoutPostsInput[] | BlogTagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutPostsInput | BlogTagCreateOrConnectWithoutPostsInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
  }

  export type EnumContentFormatFieldUpdateOperationsInput = {
    set?: $Enums.ContentFormat
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type EnumPostVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.PostVisibility
  }

  export type BlogPostUpdategalleryImagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BlogPostUpdateseoKeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BlogCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput> | BlogCommentCreateWithoutPostInput[] | BlogCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutPostInput | BlogCommentCreateOrConnectWithoutPostInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutPostInput | BlogCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BlogCommentCreateManyPostInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutPostInput | BlogCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutPostInput | BlogCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutBlogPostsNestedInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    upsert?: UserUpsertWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogPostsInput, UserUpdateWithoutBlogPostsInput>, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type BlogCategoryUpdateOneWithoutPostsNestedInput = {
    create?: XOR<BlogCategoryCreateWithoutPostsInput, BlogCategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: BlogCategoryCreateOrConnectWithoutPostsInput
    upsert?: BlogCategoryUpsertWithoutPostsInput
    disconnect?: BlogCategoryWhereInput | boolean
    delete?: BlogCategoryWhereInput | boolean
    connect?: BlogCategoryWhereUniqueInput
    update?: XOR<XOR<BlogCategoryUpdateToOneWithWhereWithoutPostsInput, BlogCategoryUpdateWithoutPostsInput>, BlogCategoryUncheckedUpdateWithoutPostsInput>
  }

  export type BlogAIGenerationUpdateOneWithoutBlogPostsNestedInput = {
    create?: XOR<BlogAIGenerationCreateWithoutBlogPostsInput, BlogAIGenerationUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: BlogAIGenerationCreateOrConnectWithoutBlogPostsInput
    upsert?: BlogAIGenerationUpsertWithoutBlogPostsInput
    disconnect?: BlogAIGenerationWhereInput | boolean
    delete?: BlogAIGenerationWhereInput | boolean
    connect?: BlogAIGenerationWhereUniqueInput
    update?: XOR<XOR<BlogAIGenerationUpdateToOneWithWhereWithoutBlogPostsInput, BlogAIGenerationUpdateWithoutBlogPostsInput>, BlogAIGenerationUncheckedUpdateWithoutBlogPostsInput>
  }

  export type BlogPostViewUpdateManyWithoutPostNestedInput = {
    create?: XOR<BlogPostViewCreateWithoutPostInput, BlogPostViewUncheckedCreateWithoutPostInput> | BlogPostViewCreateWithoutPostInput[] | BlogPostViewUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogPostViewCreateOrConnectWithoutPostInput | BlogPostViewCreateOrConnectWithoutPostInput[]
    upsert?: BlogPostViewUpsertWithWhereUniqueWithoutPostInput | BlogPostViewUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BlogPostViewCreateManyPostInputEnvelope
    set?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    disconnect?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    delete?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    connect?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    update?: BlogPostViewUpdateWithWhereUniqueWithoutPostInput | BlogPostViewUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BlogPostViewUpdateManyWithWhereWithoutPostInput | BlogPostViewUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BlogPostViewScalarWhereInput | BlogPostViewScalarWhereInput[]
  }

  export type FlagedBlogPostUpdateManyWithoutPostNestedInput = {
    create?: XOR<FlagedBlogPostCreateWithoutPostInput, FlagedBlogPostUncheckedCreateWithoutPostInput> | FlagedBlogPostCreateWithoutPostInput[] | FlagedBlogPostUncheckedCreateWithoutPostInput[]
    connectOrCreate?: FlagedBlogPostCreateOrConnectWithoutPostInput | FlagedBlogPostCreateOrConnectWithoutPostInput[]
    upsert?: FlagedBlogPostUpsertWithWhereUniqueWithoutPostInput | FlagedBlogPostUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: FlagedBlogPostCreateManyPostInputEnvelope
    set?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    disconnect?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    delete?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    connect?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    update?: FlagedBlogPostUpdateWithWhereUniqueWithoutPostInput | FlagedBlogPostUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: FlagedBlogPostUpdateManyWithWhereWithoutPostInput | FlagedBlogPostUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: FlagedBlogPostScalarWhereInput | FlagedBlogPostScalarWhereInput[]
  }

  export type BlogTagUpdateManyWithoutPostsNestedInput = {
    create?: XOR<BlogTagCreateWithoutPostsInput, BlogTagUncheckedCreateWithoutPostsInput> | BlogTagCreateWithoutPostsInput[] | BlogTagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutPostsInput | BlogTagCreateOrConnectWithoutPostsInput[]
    upsert?: BlogTagUpsertWithWhereUniqueWithoutPostsInput | BlogTagUpsertWithWhereUniqueWithoutPostsInput[]
    set?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    disconnect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    delete?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    update?: BlogTagUpdateWithWhereUniqueWithoutPostsInput | BlogTagUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: BlogTagUpdateManyWithWhereWithoutPostsInput | BlogTagUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
  }

  export type BlogCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput> | BlogCommentCreateWithoutPostInput[] | BlogCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutPostInput | BlogCommentCreateOrConnectWithoutPostInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutPostInput | BlogCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BlogCommentCreateManyPostInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutPostInput | BlogCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutPostInput | BlogCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type BlogPostViewUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<BlogPostViewCreateWithoutPostInput, BlogPostViewUncheckedCreateWithoutPostInput> | BlogPostViewCreateWithoutPostInput[] | BlogPostViewUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogPostViewCreateOrConnectWithoutPostInput | BlogPostViewCreateOrConnectWithoutPostInput[]
    upsert?: BlogPostViewUpsertWithWhereUniqueWithoutPostInput | BlogPostViewUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BlogPostViewCreateManyPostInputEnvelope
    set?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    disconnect?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    delete?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    connect?: BlogPostViewWhereUniqueInput | BlogPostViewWhereUniqueInput[]
    update?: BlogPostViewUpdateWithWhereUniqueWithoutPostInput | BlogPostViewUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BlogPostViewUpdateManyWithWhereWithoutPostInput | BlogPostViewUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BlogPostViewScalarWhereInput | BlogPostViewScalarWhereInput[]
  }

  export type FlagedBlogPostUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<FlagedBlogPostCreateWithoutPostInput, FlagedBlogPostUncheckedCreateWithoutPostInput> | FlagedBlogPostCreateWithoutPostInput[] | FlagedBlogPostUncheckedCreateWithoutPostInput[]
    connectOrCreate?: FlagedBlogPostCreateOrConnectWithoutPostInput | FlagedBlogPostCreateOrConnectWithoutPostInput[]
    upsert?: FlagedBlogPostUpsertWithWhereUniqueWithoutPostInput | FlagedBlogPostUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: FlagedBlogPostCreateManyPostInputEnvelope
    set?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    disconnect?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    delete?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    connect?: FlagedBlogPostWhereUniqueInput | FlagedBlogPostWhereUniqueInput[]
    update?: FlagedBlogPostUpdateWithWhereUniqueWithoutPostInput | FlagedBlogPostUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: FlagedBlogPostUpdateManyWithWhereWithoutPostInput | FlagedBlogPostUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: FlagedBlogPostScalarWhereInput | FlagedBlogPostScalarWhereInput[]
  }

  export type BlogTagUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<BlogTagCreateWithoutPostsInput, BlogTagUncheckedCreateWithoutPostsInput> | BlogTagCreateWithoutPostsInput[] | BlogTagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutPostsInput | BlogTagCreateOrConnectWithoutPostsInput[]
    upsert?: BlogTagUpsertWithWhereUniqueWithoutPostsInput | BlogTagUpsertWithWhereUniqueWithoutPostsInput[]
    set?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    disconnect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    delete?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    update?: BlogTagUpdateWithWhereUniqueWithoutPostsInput | BlogTagUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: BlogTagUpdateManyWithWhereWithoutPostsInput | BlogTagUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
  }

  export type BlogPostCreateNestedOneWithoutFlaggedPostsInput = {
    create?: XOR<BlogPostCreateWithoutFlaggedPostsInput, BlogPostUncheckedCreateWithoutFlaggedPostsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutFlaggedPostsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFlagedPostsInput = {
    create?: XOR<UserCreateWithoutFlagedPostsInput, UserUncheckedCreateWithoutFlagedPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlagedPostsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFlagStatusFieldUpdateOperationsInput = {
    set?: $Enums.FlagStatus
  }

  export type BlogPostUpdateOneRequiredWithoutFlaggedPostsNestedInput = {
    create?: XOR<BlogPostCreateWithoutFlaggedPostsInput, BlogPostUncheckedCreateWithoutFlaggedPostsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutFlaggedPostsInput
    upsert?: BlogPostUpsertWithoutFlaggedPostsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutFlaggedPostsInput, BlogPostUpdateWithoutFlaggedPostsInput>, BlogPostUncheckedUpdateWithoutFlaggedPostsInput>
  }

  export type UserUpdateOneRequiredWithoutFlagedPostsNestedInput = {
    create?: XOR<UserCreateWithoutFlagedPostsInput, UserUncheckedCreateWithoutFlagedPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlagedPostsInput
    upsert?: UserUpsertWithoutFlagedPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFlagedPostsInput, UserUpdateWithoutFlagedPostsInput>, UserUncheckedUpdateWithoutFlagedPostsInput>
  }

  export type BlogPostCreateNestedOneWithoutViewsCountInput = {
    create?: XOR<BlogPostCreateWithoutViewsCountInput, BlogPostUncheckedCreateWithoutViewsCountInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutViewsCountInput
    connect?: BlogPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostViewsInput = {
    create?: XOR<UserCreateWithoutPostViewsInput, UserUncheckedCreateWithoutPostViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostViewsInput
    connect?: UserWhereUniqueInput
  }

  export type BlogPostUpdateOneRequiredWithoutViewsCountNestedInput = {
    create?: XOR<BlogPostCreateWithoutViewsCountInput, BlogPostUncheckedCreateWithoutViewsCountInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutViewsCountInput
    upsert?: BlogPostUpsertWithoutViewsCountInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutViewsCountInput, BlogPostUpdateWithoutViewsCountInput>, BlogPostUncheckedUpdateWithoutViewsCountInput>
  }

  export type UserUpdateOneWithoutPostViewsNestedInput = {
    create?: XOR<UserCreateWithoutPostViewsInput, UserUncheckedCreateWithoutPostViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostViewsInput
    upsert?: UserUpsertWithoutPostViewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostViewsInput, UserUpdateWithoutPostViewsInput>, UserUncheckedUpdateWithoutPostViewsInput>
  }

  export type BlogPostCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutCategoryInput | BlogPostUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutCategoryInput | BlogPostUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutCategoryInput | BlogPostUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutCategoryInput | BlogPostUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutCategoryInput | BlogPostUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutCategoryInput | BlogPostUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostCreateNestedManyWithoutTagsInput = {
    create?: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput> | BlogPostCreateWithoutTagsInput[] | BlogPostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagsInput | BlogPostCreateOrConnectWithoutTagsInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput> | BlogPostCreateWithoutTagsInput[] | BlogPostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagsInput | BlogPostCreateOrConnectWithoutTagsInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostUpdateManyWithoutTagsNestedInput = {
    create?: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput> | BlogPostCreateWithoutTagsInput[] | BlogPostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagsInput | BlogPostCreateOrConnectWithoutTagsInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutTagsInput | BlogPostUpsertWithWhereUniqueWithoutTagsInput[]
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutTagsInput | BlogPostUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutTagsInput | BlogPostUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput> | BlogPostCreateWithoutTagsInput[] | BlogPostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagsInput | BlogPostCreateOrConnectWithoutTagsInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutTagsInput | BlogPostUpsertWithWhereUniqueWithoutTagsInput[]
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutTagsInput | BlogPostUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutTagsInput | BlogPostUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBlogCommentsInput = {
    create?: XOR<UserCreateWithoutBlogCommentsInput, UserUncheckedCreateWithoutBlogCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type BlogCommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<BlogCommentCreateWithoutRepliesInput, BlogCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: BlogCommentCreateOrConnectWithoutRepliesInput
    connect?: BlogCommentWhereUniqueInput
  }

  export type BlogCommentCreateNestedManyWithoutParentInput = {
    create?: XOR<BlogCommentCreateWithoutParentInput, BlogCommentUncheckedCreateWithoutParentInput> | BlogCommentCreateWithoutParentInput[] | BlogCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutParentInput | BlogCommentCreateOrConnectWithoutParentInput[]
    createMany?: BlogCommentCreateManyParentInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type BlogPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<BlogPostCreateWithoutCommentsInput, BlogPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutCommentsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type ReportedCommentCreateNestedManyWithoutCommentInput = {
    create?: XOR<ReportedCommentCreateWithoutCommentInput, ReportedCommentUncheckedCreateWithoutCommentInput> | ReportedCommentCreateWithoutCommentInput[] | ReportedCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReportedCommentCreateOrConnectWithoutCommentInput | ReportedCommentCreateOrConnectWithoutCommentInput[]
    createMany?: ReportedCommentCreateManyCommentInputEnvelope
    connect?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
  }

  export type BlogCommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<BlogCommentCreateWithoutParentInput, BlogCommentUncheckedCreateWithoutParentInput> | BlogCommentCreateWithoutParentInput[] | BlogCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutParentInput | BlogCommentCreateOrConnectWithoutParentInput[]
    createMany?: BlogCommentCreateManyParentInputEnvelope
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
  }

  export type ReportedCommentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<ReportedCommentCreateWithoutCommentInput, ReportedCommentUncheckedCreateWithoutCommentInput> | ReportedCommentCreateWithoutCommentInput[] | ReportedCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReportedCommentCreateOrConnectWithoutCommentInput | ReportedCommentCreateOrConnectWithoutCommentInput[]
    createMany?: ReportedCommentCreateManyCommentInputEnvelope
    connect?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutBlogCommentsNestedInput = {
    create?: XOR<UserCreateWithoutBlogCommentsInput, UserUncheckedCreateWithoutBlogCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogCommentsInput
    upsert?: UserUpsertWithoutBlogCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogCommentsInput, UserUpdateWithoutBlogCommentsInput>, UserUncheckedUpdateWithoutBlogCommentsInput>
  }

  export type BlogCommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<BlogCommentCreateWithoutRepliesInput, BlogCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: BlogCommentCreateOrConnectWithoutRepliesInput
    upsert?: BlogCommentUpsertWithoutRepliesInput
    disconnect?: BlogCommentWhereInput | boolean
    delete?: BlogCommentWhereInput | boolean
    connect?: BlogCommentWhereUniqueInput
    update?: XOR<XOR<BlogCommentUpdateToOneWithWhereWithoutRepliesInput, BlogCommentUpdateWithoutRepliesInput>, BlogCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type BlogCommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<BlogCommentCreateWithoutParentInput, BlogCommentUncheckedCreateWithoutParentInput> | BlogCommentCreateWithoutParentInput[] | BlogCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutParentInput | BlogCommentCreateOrConnectWithoutParentInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutParentInput | BlogCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: BlogCommentCreateManyParentInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutParentInput | BlogCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutParentInput | BlogCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type BlogPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<BlogPostCreateWithoutCommentsInput, BlogPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutCommentsInput
    upsert?: BlogPostUpsertWithoutCommentsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutCommentsInput, BlogPostUpdateWithoutCommentsInput>, BlogPostUncheckedUpdateWithoutCommentsInput>
  }

  export type ReportedCommentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ReportedCommentCreateWithoutCommentInput, ReportedCommentUncheckedCreateWithoutCommentInput> | ReportedCommentCreateWithoutCommentInput[] | ReportedCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReportedCommentCreateOrConnectWithoutCommentInput | ReportedCommentCreateOrConnectWithoutCommentInput[]
    upsert?: ReportedCommentUpsertWithWhereUniqueWithoutCommentInput | ReportedCommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ReportedCommentCreateManyCommentInputEnvelope
    set?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    disconnect?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    delete?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    connect?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    update?: ReportedCommentUpdateWithWhereUniqueWithoutCommentInput | ReportedCommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ReportedCommentUpdateManyWithWhereWithoutCommentInput | ReportedCommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ReportedCommentScalarWhereInput | ReportedCommentScalarWhereInput[]
  }

  export type BlogCommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<BlogCommentCreateWithoutParentInput, BlogCommentUncheckedCreateWithoutParentInput> | BlogCommentCreateWithoutParentInput[] | BlogCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: BlogCommentCreateOrConnectWithoutParentInput | BlogCommentCreateOrConnectWithoutParentInput[]
    upsert?: BlogCommentUpsertWithWhereUniqueWithoutParentInput | BlogCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: BlogCommentCreateManyParentInputEnvelope
    set?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    disconnect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    delete?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    connect?: BlogCommentWhereUniqueInput | BlogCommentWhereUniqueInput[]
    update?: BlogCommentUpdateWithWhereUniqueWithoutParentInput | BlogCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: BlogCommentUpdateManyWithWhereWithoutParentInput | BlogCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
  }

  export type ReportedCommentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ReportedCommentCreateWithoutCommentInput, ReportedCommentUncheckedCreateWithoutCommentInput> | ReportedCommentCreateWithoutCommentInput[] | ReportedCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReportedCommentCreateOrConnectWithoutCommentInput | ReportedCommentCreateOrConnectWithoutCommentInput[]
    upsert?: ReportedCommentUpsertWithWhereUniqueWithoutCommentInput | ReportedCommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ReportedCommentCreateManyCommentInputEnvelope
    set?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    disconnect?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    delete?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    connect?: ReportedCommentWhereUniqueInput | ReportedCommentWhereUniqueInput[]
    update?: ReportedCommentUpdateWithWhereUniqueWithoutCommentInput | ReportedCommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ReportedCommentUpdateManyWithWhereWithoutCommentInput | ReportedCommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ReportedCommentScalarWhereInput | ReportedCommentScalarWhereInput[]
  }

  export type BlogCommentCreateNestedOneWithoutReportedCommentsInput = {
    create?: XOR<BlogCommentCreateWithoutReportedCommentsInput, BlogCommentUncheckedCreateWithoutReportedCommentsInput>
    connectOrCreate?: BlogCommentCreateOrConnectWithoutReportedCommentsInput
    connect?: BlogCommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportedCommentsInput = {
    create?: XOR<UserCreateWithoutReportedCommentsInput, UserUncheckedCreateWithoutReportedCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type BlogCommentUpdateOneRequiredWithoutReportedCommentsNestedInput = {
    create?: XOR<BlogCommentCreateWithoutReportedCommentsInput, BlogCommentUncheckedCreateWithoutReportedCommentsInput>
    connectOrCreate?: BlogCommentCreateOrConnectWithoutReportedCommentsInput
    upsert?: BlogCommentUpsertWithoutReportedCommentsInput
    connect?: BlogCommentWhereUniqueInput
    update?: XOR<XOR<BlogCommentUpdateToOneWithWhereWithoutReportedCommentsInput, BlogCommentUpdateWithoutReportedCommentsInput>, BlogCommentUncheckedUpdateWithoutReportedCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutReportedCommentsNestedInput = {
    create?: XOR<UserCreateWithoutReportedCommentsInput, UserUncheckedCreateWithoutReportedCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedCommentsInput
    upsert?: UserUpsertWithoutReportedCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportedCommentsInput, UserUpdateWithoutReportedCommentsInput>, UserUncheckedUpdateWithoutReportedCommentsInput>
  }

  export type UserCreateNestedOneWithoutAIContentGenerationToExcerptInput = {
    create?: XOR<UserCreateWithoutAIContentGenerationToExcerptInput, UserUncheckedCreateWithoutAIContentGenerationToExcerptInput>
    connectOrCreate?: UserCreateOrConnectWithoutAIContentGenerationToExcerptInput
    connect?: UserWhereUniqueInput
  }

  export type BlogPostCreateNestedManyWithoutAiGenerationInput = {
    create?: XOR<BlogPostCreateWithoutAiGenerationInput, BlogPostUncheckedCreateWithoutAiGenerationInput> | BlogPostCreateWithoutAiGenerationInput[] | BlogPostUncheckedCreateWithoutAiGenerationInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAiGenerationInput | BlogPostCreateOrConnectWithoutAiGenerationInput[]
    createMany?: BlogPostCreateManyAiGenerationInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutAiGenerationInput = {
    create?: XOR<BlogPostCreateWithoutAiGenerationInput, BlogPostUncheckedCreateWithoutAiGenerationInput> | BlogPostCreateWithoutAiGenerationInput[] | BlogPostUncheckedCreateWithoutAiGenerationInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAiGenerationInput | BlogPostCreateOrConnectWithoutAiGenerationInput[]
    createMany?: BlogPostCreateManyAiGenerationInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type EnumAIGenerationStatusFieldUpdateOperationsInput = {
    set?: $Enums.AIGenerationStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAIContentGenerationToExcerptNestedInput = {
    create?: XOR<UserCreateWithoutAIContentGenerationToExcerptInput, UserUncheckedCreateWithoutAIContentGenerationToExcerptInput>
    connectOrCreate?: UserCreateOrConnectWithoutAIContentGenerationToExcerptInput
    upsert?: UserUpsertWithoutAIContentGenerationToExcerptInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAIContentGenerationToExcerptInput, UserUpdateWithoutAIContentGenerationToExcerptInput>, UserUncheckedUpdateWithoutAIContentGenerationToExcerptInput>
  }

  export type BlogPostUpdateManyWithoutAiGenerationNestedInput = {
    create?: XOR<BlogPostCreateWithoutAiGenerationInput, BlogPostUncheckedCreateWithoutAiGenerationInput> | BlogPostCreateWithoutAiGenerationInput[] | BlogPostUncheckedCreateWithoutAiGenerationInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAiGenerationInput | BlogPostCreateOrConnectWithoutAiGenerationInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAiGenerationInput | BlogPostUpsertWithWhereUniqueWithoutAiGenerationInput[]
    createMany?: BlogPostCreateManyAiGenerationInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAiGenerationInput | BlogPostUpdateWithWhereUniqueWithoutAiGenerationInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAiGenerationInput | BlogPostUpdateManyWithWhereWithoutAiGenerationInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutAiGenerationNestedInput = {
    create?: XOR<BlogPostCreateWithoutAiGenerationInput, BlogPostUncheckedCreateWithoutAiGenerationInput> | BlogPostCreateWithoutAiGenerationInput[] | BlogPostUncheckedCreateWithoutAiGenerationInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAiGenerationInput | BlogPostCreateOrConnectWithoutAiGenerationInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAiGenerationInput | BlogPostUpsertWithWhereUniqueWithoutAiGenerationInput[]
    createMany?: BlogPostCreateManyAiGenerationInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAiGenerationInput | BlogPostUpdateWithWhereUniqueWithoutAiGenerationInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAiGenerationInput | BlogPostUpdateManyWithWhereWithoutAiGenerationInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type EmailCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EmailCreateWithoutCampaignInput, EmailUncheckedCreateWithoutCampaignInput> | EmailCreateWithoutCampaignInput[] | EmailUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutCampaignInput | EmailCreateOrConnectWithoutCampaignInput[]
    createMany?: EmailCreateManyCampaignInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type EmailUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EmailCreateWithoutCampaignInput, EmailUncheckedCreateWithoutCampaignInput> | EmailCreateWithoutCampaignInput[] | EmailUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutCampaignInput | EmailCreateOrConnectWithoutCampaignInput[]
    createMany?: EmailCreateManyCampaignInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type EmailUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EmailCreateWithoutCampaignInput, EmailUncheckedCreateWithoutCampaignInput> | EmailCreateWithoutCampaignInput[] | EmailUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutCampaignInput | EmailCreateOrConnectWithoutCampaignInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutCampaignInput | EmailUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EmailCreateManyCampaignInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutCampaignInput | EmailUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutCampaignInput | EmailUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type EmailUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EmailCreateWithoutCampaignInput, EmailUncheckedCreateWithoutCampaignInput> | EmailCreateWithoutCampaignInput[] | EmailUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutCampaignInput | EmailCreateOrConnectWithoutCampaignInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutCampaignInput | EmailUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EmailCreateManyCampaignInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutCampaignInput | EmailUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutCampaignInput | EmailUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type EmailNotificationCreateopenedByEmailsInput = {
    set: string[]
  }

  export type EmailNotificationCreateclickedByEmailsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutNotificationEmailsInput = {
    create?: XOR<UserCreateWithoutNotificationEmailsInput, UserUncheckedCreateWithoutNotificationEmailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationEmailsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationEmailClickedLinkCreateNestedManyWithoutNotificationEmailInput = {
    create?: XOR<NotificationEmailClickedLinkCreateWithoutNotificationEmailInput, NotificationEmailClickedLinkUncheckedCreateWithoutNotificationEmailInput> | NotificationEmailClickedLinkCreateWithoutNotificationEmailInput[] | NotificationEmailClickedLinkUncheckedCreateWithoutNotificationEmailInput[]
    connectOrCreate?: NotificationEmailClickedLinkCreateOrConnectWithoutNotificationEmailInput | NotificationEmailClickedLinkCreateOrConnectWithoutNotificationEmailInput[]
    createMany?: NotificationEmailClickedLinkCreateManyNotificationEmailInputEnvelope
    connect?: NotificationEmailClickedLinkWhereUniqueInput | NotificationEmailClickedLinkWhereUniqueInput[]
  }

  export type NotificationEmailClickedLinkUncheckedCreateNestedManyWithoutNotificationEmailInput = {
    create?: XOR<NotificationEmailClickedLinkCreateWithoutNotificationEmailInput, NotificationEmailClickedLinkUncheckedCreateWithoutNotificationEmailInput> | NotificationEmailClickedLinkCreateWithoutNotificationEmailInput[] | NotificationEmailClickedLinkUncheckedCreateWithoutNotificationEmailInput[]
    connectOrCreate?: NotificationEmailClickedLinkCreateOrConnectWithoutNotificationEmailInput | NotificationEmailClickedLinkCreateOrConnectWithoutNotificationEmailInput[]
    createMany?: NotificationEmailClickedLinkCreateManyNotificationEmailInputEnvelope
    connect?: NotificationEmailClickedLinkWhereUniqueInput | NotificationEmailClickedLinkWhereUniqueInput[]
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationCategoryFieldUpdateOperationsInput = {
    set?: $Enums.NotificationCategory
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority
  }

  export type EmailNotificationUpdateopenedByEmailsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailNotificationUpdateclickedByEmailsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutNotificationEmailsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationEmailsInput, UserUncheckedCreateWithoutNotificationEmailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationEmailsInput
    upsert?: UserUpsertWithoutNotificationEmailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationEmailsInput, UserUpdateWithoutNotificationEmailsInput>, UserUncheckedUpdateWithoutNotificationEmailsInput>
  }

  export type NotificationEmailClickedLinkUpdateManyWithoutNotificationEmailNestedInput = {
    create?: XOR<NotificationEmailClickedLinkCreateWithoutNotificationEmailInput, NotificationEmailClickedLinkUncheckedCreateWithoutNotificationEmailInput> | NotificationEmailClickedLinkCreateWithoutNotificationEmailInput[] | NotificationEmailClickedLinkUncheckedCreateWithoutNotificationEmailInput[]
    connectOrCreate?: NotificationEmailClickedLinkCreateOrConnectWithoutNotificationEmailInput | NotificationEmailClickedLinkCreateOrConnectWithoutNotificationEmailInput[]
    upsert?: NotificationEmailClickedLinkUpsertWithWhereUniqueWithoutNotificationEmailInput | NotificationEmailClickedLinkUpsertWithWhereUniqueWithoutNotificationEmailInput[]
    createMany?: NotificationEmailClickedLinkCreateManyNotificationEmailInputEnvelope
    set?: NotificationEmailClickedLinkWhereUniqueInput | NotificationEmailClickedLinkWhereUniqueInput[]
    disconnect?: NotificationEmailClickedLinkWhereUniqueInput | NotificationEmailClickedLinkWhereUniqueInput[]
    delete?: NotificationEmailClickedLinkWhereUniqueInput | NotificationEmailClickedLinkWhereUniqueInput[]
    connect?: NotificationEmailClickedLinkWhereUniqueInput | NotificationEmailClickedLinkWhereUniqueInput[]
    update?: NotificationEmailClickedLinkUpdateWithWhereUniqueWithoutNotificationEmailInput | NotificationEmailClickedLinkUpdateWithWhereUniqueWithoutNotificationEmailInput[]
    updateMany?: NotificationEmailClickedLinkUpdateManyWithWhereWithoutNotificationEmailInput | NotificationEmailClickedLinkUpdateManyWithWhereWithoutNotificationEmailInput[]
    deleteMany?: NotificationEmailClickedLinkScalarWhereInput | NotificationEmailClickedLinkScalarWhereInput[]
  }

  export type NotificationEmailClickedLinkUncheckedUpdateManyWithoutNotificationEmailNestedInput = {
    create?: XOR<NotificationEmailClickedLinkCreateWithoutNotificationEmailInput, NotificationEmailClickedLinkUncheckedCreateWithoutNotificationEmailInput> | NotificationEmailClickedLinkCreateWithoutNotificationEmailInput[] | NotificationEmailClickedLinkUncheckedCreateWithoutNotificationEmailInput[]
    connectOrCreate?: NotificationEmailClickedLinkCreateOrConnectWithoutNotificationEmailInput | NotificationEmailClickedLinkCreateOrConnectWithoutNotificationEmailInput[]
    upsert?: NotificationEmailClickedLinkUpsertWithWhereUniqueWithoutNotificationEmailInput | NotificationEmailClickedLinkUpsertWithWhereUniqueWithoutNotificationEmailInput[]
    createMany?: NotificationEmailClickedLinkCreateManyNotificationEmailInputEnvelope
    set?: NotificationEmailClickedLinkWhereUniqueInput | NotificationEmailClickedLinkWhereUniqueInput[]
    disconnect?: NotificationEmailClickedLinkWhereUniqueInput | NotificationEmailClickedLinkWhereUniqueInput[]
    delete?: NotificationEmailClickedLinkWhereUniqueInput | NotificationEmailClickedLinkWhereUniqueInput[]
    connect?: NotificationEmailClickedLinkWhereUniqueInput | NotificationEmailClickedLinkWhereUniqueInput[]
    update?: NotificationEmailClickedLinkUpdateWithWhereUniqueWithoutNotificationEmailInput | NotificationEmailClickedLinkUpdateWithWhereUniqueWithoutNotificationEmailInput[]
    updateMany?: NotificationEmailClickedLinkUpdateManyWithWhereWithoutNotificationEmailInput | NotificationEmailClickedLinkUpdateManyWithWhereWithoutNotificationEmailInput[]
    deleteMany?: NotificationEmailClickedLinkScalarWhereInput | NotificationEmailClickedLinkScalarWhereInput[]
  }

  export type EmailCreateNestedOneWithoutClickedLinksInput = {
    create?: XOR<EmailCreateWithoutClickedLinksInput, EmailUncheckedCreateWithoutClickedLinksInput>
    connectOrCreate?: EmailCreateOrConnectWithoutClickedLinksInput
    connect?: EmailWhereUniqueInput
  }

  export type EmailUpdateOneRequiredWithoutClickedLinksNestedInput = {
    create?: XOR<EmailCreateWithoutClickedLinksInput, EmailUncheckedCreateWithoutClickedLinksInput>
    connectOrCreate?: EmailCreateOrConnectWithoutClickedLinksInput
    upsert?: EmailUpsertWithoutClickedLinksInput
    connect?: EmailWhereUniqueInput
    update?: XOR<XOR<EmailUpdateToOneWithWhereWithoutClickedLinksInput, EmailUpdateWithoutClickedLinksInput>, EmailUncheckedUpdateWithoutClickedLinksInput>
  }

  export type EmailNotificationCreateNestedOneWithoutNotificationEmailClickedLinkInput = {
    create?: XOR<EmailNotificationCreateWithoutNotificationEmailClickedLinkInput, EmailNotificationUncheckedCreateWithoutNotificationEmailClickedLinkInput>
    connectOrCreate?: EmailNotificationCreateOrConnectWithoutNotificationEmailClickedLinkInput
    connect?: EmailNotificationWhereUniqueInput
  }

  export type EmailNotificationUpdateOneWithoutNotificationEmailClickedLinkNestedInput = {
    create?: XOR<EmailNotificationCreateWithoutNotificationEmailClickedLinkInput, EmailNotificationUncheckedCreateWithoutNotificationEmailClickedLinkInput>
    connectOrCreate?: EmailNotificationCreateOrConnectWithoutNotificationEmailClickedLinkInput
    upsert?: EmailNotificationUpsertWithoutNotificationEmailClickedLinkInput
    disconnect?: EmailNotificationWhereInput | boolean
    delete?: EmailNotificationWhereInput | boolean
    connect?: EmailNotificationWhereUniqueInput
    update?: XOR<XOR<EmailNotificationUpdateToOneWithWhereWithoutNotificationEmailClickedLinkInput, EmailNotificationUpdateWithoutNotificationEmailClickedLinkInput>, EmailNotificationUncheckedUpdateWithoutNotificationEmailClickedLinkInput>
  }

  export type EmailCreateopenedByIpsInput = {
    set: string[]
  }

  export type EmailCreateopenedByEmailsInput = {
    set: string[]
  }

  export type EmailCreateclickedByIpsInput = {
    set: string[]
  }

  export type EmailCreateclickedByEmailsInput = {
    set: string[]
  }

  export type EmailElementCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailElementCreateWithoutEmailInput, EmailElementUncheckedCreateWithoutEmailInput> | EmailElementCreateWithoutEmailInput[] | EmailElementUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailElementCreateOrConnectWithoutEmailInput | EmailElementCreateOrConnectWithoutEmailInput[]
    createMany?: EmailElementCreateManyEmailInputEnvelope
    connect?: EmailElementWhereUniqueInput | EmailElementWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutEmailsInput = {
    create?: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutEmailsInput = {
    create?: XOR<CampaignCreateWithoutEmailsInput, CampaignUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEmailsInput
    connect?: CampaignWhereUniqueInput
  }

  export type ClickedLinkCreateNestedManyWithoutEmailInput = {
    create?: XOR<ClickedLinkCreateWithoutEmailInput, ClickedLinkUncheckedCreateWithoutEmailInput> | ClickedLinkCreateWithoutEmailInput[] | ClickedLinkUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: ClickedLinkCreateOrConnectWithoutEmailInput | ClickedLinkCreateOrConnectWithoutEmailInput[]
    createMany?: ClickedLinkCreateManyEmailInputEnvelope
    connect?: ClickedLinkWhereUniqueInput | ClickedLinkWhereUniqueInput[]
  }

  export type EmailAttachmentCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput> | EmailAttachmentCreateWithoutEmailInput[] | EmailAttachmentUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailAttachmentCreateOrConnectWithoutEmailInput | EmailAttachmentCreateOrConnectWithoutEmailInput[]
    createMany?: EmailAttachmentCreateManyEmailInputEnvelope
    connect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
  }

  export type EmailRecipientCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailRecipientCreateWithoutEmailInput, EmailRecipientUncheckedCreateWithoutEmailInput> | EmailRecipientCreateWithoutEmailInput[] | EmailRecipientUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailRecipientCreateOrConnectWithoutEmailInput | EmailRecipientCreateOrConnectWithoutEmailInput[]
    createMany?: EmailRecipientCreateManyEmailInputEnvelope
    connect?: EmailRecipientWhereUniqueInput | EmailRecipientWhereUniqueInput[]
  }

  export type EmailTemplateCreateNestedOneWithoutEmailsInput = {
    create?: XOR<EmailTemplateCreateWithoutEmailsInput, EmailTemplateUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutEmailsInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type EmailAnalyticsCreateNestedOneWithoutEmailInput = {
    create?: XOR<EmailAnalyticsCreateWithoutEmailInput, EmailAnalyticsUncheckedCreateWithoutEmailInput>
    connectOrCreate?: EmailAnalyticsCreateOrConnectWithoutEmailInput
    connect?: EmailAnalyticsWhereUniqueInput
  }

  export type EmailElementUncheckedCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailElementCreateWithoutEmailInput, EmailElementUncheckedCreateWithoutEmailInput> | EmailElementCreateWithoutEmailInput[] | EmailElementUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailElementCreateOrConnectWithoutEmailInput | EmailElementCreateOrConnectWithoutEmailInput[]
    createMany?: EmailElementCreateManyEmailInputEnvelope
    connect?: EmailElementWhereUniqueInput | EmailElementWhereUniqueInput[]
  }

  export type ClickedLinkUncheckedCreateNestedManyWithoutEmailInput = {
    create?: XOR<ClickedLinkCreateWithoutEmailInput, ClickedLinkUncheckedCreateWithoutEmailInput> | ClickedLinkCreateWithoutEmailInput[] | ClickedLinkUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: ClickedLinkCreateOrConnectWithoutEmailInput | ClickedLinkCreateOrConnectWithoutEmailInput[]
    createMany?: ClickedLinkCreateManyEmailInputEnvelope
    connect?: ClickedLinkWhereUniqueInput | ClickedLinkWhereUniqueInput[]
  }

  export type EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput> | EmailAttachmentCreateWithoutEmailInput[] | EmailAttachmentUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailAttachmentCreateOrConnectWithoutEmailInput | EmailAttachmentCreateOrConnectWithoutEmailInput[]
    createMany?: EmailAttachmentCreateManyEmailInputEnvelope
    connect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
  }

  export type EmailRecipientUncheckedCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailRecipientCreateWithoutEmailInput, EmailRecipientUncheckedCreateWithoutEmailInput> | EmailRecipientCreateWithoutEmailInput[] | EmailRecipientUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailRecipientCreateOrConnectWithoutEmailInput | EmailRecipientCreateOrConnectWithoutEmailInput[]
    createMany?: EmailRecipientCreateManyEmailInputEnvelope
    connect?: EmailRecipientWhereUniqueInput | EmailRecipientWhereUniqueInput[]
  }

  export type EmailAnalyticsUncheckedCreateNestedOneWithoutEmailInput = {
    create?: XOR<EmailAnalyticsCreateWithoutEmailInput, EmailAnalyticsUncheckedCreateWithoutEmailInput>
    connectOrCreate?: EmailAnalyticsCreateOrConnectWithoutEmailInput
    connect?: EmailAnalyticsWhereUniqueInput
  }

  export type EnumEmailStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmailStatus
  }

  export type EnumEmailTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmailType
  }

  export type EmailUpdateopenedByIpsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailUpdateopenedByEmailsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailUpdateclickedByIpsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailUpdateclickedByEmailsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailElementUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailElementCreateWithoutEmailInput, EmailElementUncheckedCreateWithoutEmailInput> | EmailElementCreateWithoutEmailInput[] | EmailElementUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailElementCreateOrConnectWithoutEmailInput | EmailElementCreateOrConnectWithoutEmailInput[]
    upsert?: EmailElementUpsertWithWhereUniqueWithoutEmailInput | EmailElementUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailElementCreateManyEmailInputEnvelope
    set?: EmailElementWhereUniqueInput | EmailElementWhereUniqueInput[]
    disconnect?: EmailElementWhereUniqueInput | EmailElementWhereUniqueInput[]
    delete?: EmailElementWhereUniqueInput | EmailElementWhereUniqueInput[]
    connect?: EmailElementWhereUniqueInput | EmailElementWhereUniqueInput[]
    update?: EmailElementUpdateWithWhereUniqueWithoutEmailInput | EmailElementUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailElementUpdateManyWithWhereWithoutEmailInput | EmailElementUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailElementScalarWhereInput | EmailElementScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailsInput
    upsert?: UserUpsertWithoutEmailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailsInput, UserUpdateWithoutEmailsInput>, UserUncheckedUpdateWithoutEmailsInput>
  }

  export type CampaignUpdateOneWithoutEmailsNestedInput = {
    create?: XOR<CampaignCreateWithoutEmailsInput, CampaignUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEmailsInput
    upsert?: CampaignUpsertWithoutEmailsInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutEmailsInput, CampaignUpdateWithoutEmailsInput>, CampaignUncheckedUpdateWithoutEmailsInput>
  }

  export type ClickedLinkUpdateManyWithoutEmailNestedInput = {
    create?: XOR<ClickedLinkCreateWithoutEmailInput, ClickedLinkUncheckedCreateWithoutEmailInput> | ClickedLinkCreateWithoutEmailInput[] | ClickedLinkUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: ClickedLinkCreateOrConnectWithoutEmailInput | ClickedLinkCreateOrConnectWithoutEmailInput[]
    upsert?: ClickedLinkUpsertWithWhereUniqueWithoutEmailInput | ClickedLinkUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: ClickedLinkCreateManyEmailInputEnvelope
    set?: ClickedLinkWhereUniqueInput | ClickedLinkWhereUniqueInput[]
    disconnect?: ClickedLinkWhereUniqueInput | ClickedLinkWhereUniqueInput[]
    delete?: ClickedLinkWhereUniqueInput | ClickedLinkWhereUniqueInput[]
    connect?: ClickedLinkWhereUniqueInput | ClickedLinkWhereUniqueInput[]
    update?: ClickedLinkUpdateWithWhereUniqueWithoutEmailInput | ClickedLinkUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: ClickedLinkUpdateManyWithWhereWithoutEmailInput | ClickedLinkUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: ClickedLinkScalarWhereInput | ClickedLinkScalarWhereInput[]
  }

  export type EmailAttachmentUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput> | EmailAttachmentCreateWithoutEmailInput[] | EmailAttachmentUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailAttachmentCreateOrConnectWithoutEmailInput | EmailAttachmentCreateOrConnectWithoutEmailInput[]
    upsert?: EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput | EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailAttachmentCreateManyEmailInputEnvelope
    set?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    disconnect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    delete?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    connect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    update?: EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput | EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailAttachmentUpdateManyWithWhereWithoutEmailInput | EmailAttachmentUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailAttachmentScalarWhereInput | EmailAttachmentScalarWhereInput[]
  }

  export type EmailRecipientUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailRecipientCreateWithoutEmailInput, EmailRecipientUncheckedCreateWithoutEmailInput> | EmailRecipientCreateWithoutEmailInput[] | EmailRecipientUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailRecipientCreateOrConnectWithoutEmailInput | EmailRecipientCreateOrConnectWithoutEmailInput[]
    upsert?: EmailRecipientUpsertWithWhereUniqueWithoutEmailInput | EmailRecipientUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailRecipientCreateManyEmailInputEnvelope
    set?: EmailRecipientWhereUniqueInput | EmailRecipientWhereUniqueInput[]
    disconnect?: EmailRecipientWhereUniqueInput | EmailRecipientWhereUniqueInput[]
    delete?: EmailRecipientWhereUniqueInput | EmailRecipientWhereUniqueInput[]
    connect?: EmailRecipientWhereUniqueInput | EmailRecipientWhereUniqueInput[]
    update?: EmailRecipientUpdateWithWhereUniqueWithoutEmailInput | EmailRecipientUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailRecipientUpdateManyWithWhereWithoutEmailInput | EmailRecipientUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailRecipientScalarWhereInput | EmailRecipientScalarWhereInput[]
  }

  export type EmailTemplateUpdateOneWithoutEmailsNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutEmailsInput, EmailTemplateUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutEmailsInput
    upsert?: EmailTemplateUpsertWithoutEmailsInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutEmailsInput, EmailTemplateUpdateWithoutEmailsInput>, EmailTemplateUncheckedUpdateWithoutEmailsInput>
  }

  export type EmailAnalyticsUpdateOneWithoutEmailNestedInput = {
    create?: XOR<EmailAnalyticsCreateWithoutEmailInput, EmailAnalyticsUncheckedCreateWithoutEmailInput>
    connectOrCreate?: EmailAnalyticsCreateOrConnectWithoutEmailInput
    upsert?: EmailAnalyticsUpsertWithoutEmailInput
    disconnect?: EmailAnalyticsWhereInput | boolean
    delete?: EmailAnalyticsWhereInput | boolean
    connect?: EmailAnalyticsWhereUniqueInput
    update?: XOR<XOR<EmailAnalyticsUpdateToOneWithWhereWithoutEmailInput, EmailAnalyticsUpdateWithoutEmailInput>, EmailAnalyticsUncheckedUpdateWithoutEmailInput>
  }

  export type EmailElementUncheckedUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailElementCreateWithoutEmailInput, EmailElementUncheckedCreateWithoutEmailInput> | EmailElementCreateWithoutEmailInput[] | EmailElementUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailElementCreateOrConnectWithoutEmailInput | EmailElementCreateOrConnectWithoutEmailInput[]
    upsert?: EmailElementUpsertWithWhereUniqueWithoutEmailInput | EmailElementUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailElementCreateManyEmailInputEnvelope
    set?: EmailElementWhereUniqueInput | EmailElementWhereUniqueInput[]
    disconnect?: EmailElementWhereUniqueInput | EmailElementWhereUniqueInput[]
    delete?: EmailElementWhereUniqueInput | EmailElementWhereUniqueInput[]
    connect?: EmailElementWhereUniqueInput | EmailElementWhereUniqueInput[]
    update?: EmailElementUpdateWithWhereUniqueWithoutEmailInput | EmailElementUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailElementUpdateManyWithWhereWithoutEmailInput | EmailElementUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailElementScalarWhereInput | EmailElementScalarWhereInput[]
  }

  export type ClickedLinkUncheckedUpdateManyWithoutEmailNestedInput = {
    create?: XOR<ClickedLinkCreateWithoutEmailInput, ClickedLinkUncheckedCreateWithoutEmailInput> | ClickedLinkCreateWithoutEmailInput[] | ClickedLinkUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: ClickedLinkCreateOrConnectWithoutEmailInput | ClickedLinkCreateOrConnectWithoutEmailInput[]
    upsert?: ClickedLinkUpsertWithWhereUniqueWithoutEmailInput | ClickedLinkUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: ClickedLinkCreateManyEmailInputEnvelope
    set?: ClickedLinkWhereUniqueInput | ClickedLinkWhereUniqueInput[]
    disconnect?: ClickedLinkWhereUniqueInput | ClickedLinkWhereUniqueInput[]
    delete?: ClickedLinkWhereUniqueInput | ClickedLinkWhereUniqueInput[]
    connect?: ClickedLinkWhereUniqueInput | ClickedLinkWhereUniqueInput[]
    update?: ClickedLinkUpdateWithWhereUniqueWithoutEmailInput | ClickedLinkUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: ClickedLinkUpdateManyWithWhereWithoutEmailInput | ClickedLinkUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: ClickedLinkScalarWhereInput | ClickedLinkScalarWhereInput[]
  }

  export type EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput> | EmailAttachmentCreateWithoutEmailInput[] | EmailAttachmentUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailAttachmentCreateOrConnectWithoutEmailInput | EmailAttachmentCreateOrConnectWithoutEmailInput[]
    upsert?: EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput | EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailAttachmentCreateManyEmailInputEnvelope
    set?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    disconnect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    delete?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    connect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    update?: EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput | EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailAttachmentUpdateManyWithWhereWithoutEmailInput | EmailAttachmentUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailAttachmentScalarWhereInput | EmailAttachmentScalarWhereInput[]
  }

  export type EmailRecipientUncheckedUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailRecipientCreateWithoutEmailInput, EmailRecipientUncheckedCreateWithoutEmailInput> | EmailRecipientCreateWithoutEmailInput[] | EmailRecipientUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailRecipientCreateOrConnectWithoutEmailInput | EmailRecipientCreateOrConnectWithoutEmailInput[]
    upsert?: EmailRecipientUpsertWithWhereUniqueWithoutEmailInput | EmailRecipientUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailRecipientCreateManyEmailInputEnvelope
    set?: EmailRecipientWhereUniqueInput | EmailRecipientWhereUniqueInput[]
    disconnect?: EmailRecipientWhereUniqueInput | EmailRecipientWhereUniqueInput[]
    delete?: EmailRecipientWhereUniqueInput | EmailRecipientWhereUniqueInput[]
    connect?: EmailRecipientWhereUniqueInput | EmailRecipientWhereUniqueInput[]
    update?: EmailRecipientUpdateWithWhereUniqueWithoutEmailInput | EmailRecipientUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailRecipientUpdateManyWithWhereWithoutEmailInput | EmailRecipientUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailRecipientScalarWhereInput | EmailRecipientScalarWhereInput[]
  }

  export type EmailAnalyticsUncheckedUpdateOneWithoutEmailNestedInput = {
    create?: XOR<EmailAnalyticsCreateWithoutEmailInput, EmailAnalyticsUncheckedCreateWithoutEmailInput>
    connectOrCreate?: EmailAnalyticsCreateOrConnectWithoutEmailInput
    upsert?: EmailAnalyticsUpsertWithoutEmailInput
    disconnect?: EmailAnalyticsWhereInput | boolean
    delete?: EmailAnalyticsWhereInput | boolean
    connect?: EmailAnalyticsWhereUniqueInput
    update?: XOR<XOR<EmailAnalyticsUpdateToOneWithWhereWithoutEmailInput, EmailAnalyticsUpdateWithoutEmailInput>, EmailAnalyticsUncheckedUpdateWithoutEmailInput>
  }

  export type EmailCreateNestedOneWithoutElementsInput = {
    create?: XOR<EmailCreateWithoutElementsInput, EmailUncheckedCreateWithoutElementsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutElementsInput
    connect?: EmailWhereUniqueInput
  }

  export type EnumElementTypeFieldUpdateOperationsInput = {
    set?: $Enums.ElementType
  }

  export type EmailUpdateOneRequiredWithoutElementsNestedInput = {
    create?: XOR<EmailCreateWithoutElementsInput, EmailUncheckedCreateWithoutElementsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutElementsInput
    upsert?: EmailUpsertWithoutElementsInput
    connect?: EmailWhereUniqueInput
    update?: XOR<XOR<EmailUpdateToOneWithWhereWithoutElementsInput, EmailUpdateWithoutElementsInput>, EmailUncheckedUpdateWithoutElementsInput>
  }

  export type EmailTemplateCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutTemplateInput = {
    create?: XOR<UserCreateWithoutTemplateInput, UserUncheckedCreateWithoutTemplateInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemplateInput
    connect?: UserWhereUniqueInput
  }

  export type EmailCreateNestedManyWithoutTemplateInput = {
    create?: XOR<EmailCreateWithoutTemplateInput, EmailUncheckedCreateWithoutTemplateInput> | EmailCreateWithoutTemplateInput[] | EmailUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutTemplateInput | EmailCreateOrConnectWithoutTemplateInput[]
    createMany?: EmailCreateManyTemplateInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type EmailUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<EmailCreateWithoutTemplateInput, EmailUncheckedCreateWithoutTemplateInput> | EmailCreateWithoutTemplateInput[] | EmailUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutTemplateInput | EmailCreateOrConnectWithoutTemplateInput[]
    createMany?: EmailCreateManyTemplateInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type EmailTemplateUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutTemplateNestedInput = {
    create?: XOR<UserCreateWithoutTemplateInput, UserUncheckedCreateWithoutTemplateInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemplateInput
    upsert?: UserUpsertWithoutTemplateInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTemplateInput, UserUpdateWithoutTemplateInput>, UserUncheckedUpdateWithoutTemplateInput>
  }

  export type EmailUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<EmailCreateWithoutTemplateInput, EmailUncheckedCreateWithoutTemplateInput> | EmailCreateWithoutTemplateInput[] | EmailUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutTemplateInput | EmailCreateOrConnectWithoutTemplateInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutTemplateInput | EmailUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: EmailCreateManyTemplateInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutTemplateInput | EmailUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutTemplateInput | EmailUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type EmailUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<EmailCreateWithoutTemplateInput, EmailUncheckedCreateWithoutTemplateInput> | EmailCreateWithoutTemplateInput[] | EmailUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutTemplateInput | EmailCreateOrConnectWithoutTemplateInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutTemplateInput | EmailUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: EmailCreateManyTemplateInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutTemplateInput | EmailUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutTemplateInput | EmailUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type EmailCreateNestedOneWithoutEmailAttachmentsInput = {
    create?: XOR<EmailCreateWithoutEmailAttachmentsInput, EmailUncheckedCreateWithoutEmailAttachmentsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutEmailAttachmentsInput
    connect?: EmailWhereUniqueInput
  }

  export type EmailUpdateOneRequiredWithoutEmailAttachmentsNestedInput = {
    create?: XOR<EmailCreateWithoutEmailAttachmentsInput, EmailUncheckedCreateWithoutEmailAttachmentsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutEmailAttachmentsInput
    upsert?: EmailUpsertWithoutEmailAttachmentsInput
    connect?: EmailWhereUniqueInput
    update?: XOR<XOR<EmailUpdateToOneWithWhereWithoutEmailAttachmentsInput, EmailUpdateWithoutEmailAttachmentsInput>, EmailUncheckedUpdateWithoutEmailAttachmentsInput>
  }

  export type EmailCreateNestedOneWithoutEmailRecipientsInput = {
    create?: XOR<EmailCreateWithoutEmailRecipientsInput, EmailUncheckedCreateWithoutEmailRecipientsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutEmailRecipientsInput
    connect?: EmailWhereUniqueInput
  }

  export type EnumRecipientStatusFieldUpdateOperationsInput = {
    set?: $Enums.RecipientStatus
  }

  export type EmailUpdateOneRequiredWithoutEmailRecipientsNestedInput = {
    create?: XOR<EmailCreateWithoutEmailRecipientsInput, EmailUncheckedCreateWithoutEmailRecipientsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutEmailRecipientsInput
    upsert?: EmailUpsertWithoutEmailRecipientsInput
    connect?: EmailWhereUniqueInput
    update?: XOR<XOR<EmailUpdateToOneWithWhereWithoutEmailRecipientsInput, EmailUpdateWithoutEmailRecipientsInput>, EmailUncheckedUpdateWithoutEmailRecipientsInput>
  }

  export type EmailCreateNestedOneWithoutEmailAnalyticsInput = {
    create?: XOR<EmailCreateWithoutEmailAnalyticsInput, EmailUncheckedCreateWithoutEmailAnalyticsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutEmailAnalyticsInput
    connect?: EmailWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmailUpdateOneRequiredWithoutEmailAnalyticsNestedInput = {
    create?: XOR<EmailCreateWithoutEmailAnalyticsInput, EmailUncheckedCreateWithoutEmailAnalyticsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutEmailAnalyticsInput
    upsert?: EmailUpsertWithoutEmailAnalyticsInput
    connect?: EmailWhereUniqueInput
    update?: XOR<XOR<EmailUpdateToOneWithWhereWithoutEmailAnalyticsInput, EmailUpdateWithoutEmailAnalyticsInput>, EmailUncheckedUpdateWithoutEmailAnalyticsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanFilter<$PrismaModel> | $Enums.Plan
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumPlanSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanSubscriptionStatus | EnumPlanSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlanSubscriptionStatus[] | ListEnumPlanSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanSubscriptionStatus[] | ListEnumPlanSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanSubscriptionStatusFilter<$PrismaModel> | $Enums.PlanSubscriptionStatus
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanWithAggregatesFilter<$PrismaModel> | $Enums.Plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanFilter<$PrismaModel>
    _max?: NestedEnumPlanFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumPlanSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanSubscriptionStatus | EnumPlanSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlanSubscriptionStatus[] | ListEnumPlanSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanSubscriptionStatus[] | ListEnumPlanSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlanSubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumPlanSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumKYCAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCAccountType | EnumKYCAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KYCAccountType[] | ListEnumKYCAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCAccountType[] | ListEnumKYCAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCAccountTypeFilter<$PrismaModel> | $Enums.KYCAccountType
  }

  export type NestedEnumKYCAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCAccountType | EnumKYCAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KYCAccountType[] | ListEnumKYCAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCAccountType[] | ListEnumKYCAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.KYCAccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumKYCAccountTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumContentFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentFormat | EnumContentFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ContentFormat[] | ListEnumContentFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentFormat[] | ListEnumContentFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumContentFormatFilter<$PrismaModel> | $Enums.ContentFormat
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedEnumPostVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityFilter<$PrismaModel> | $Enums.PostVisibility
  }

  export type NestedEnumContentFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentFormat | EnumContentFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ContentFormat[] | ListEnumContentFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentFormat[] | ListEnumContentFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumContentFormatWithAggregatesFilter<$PrismaModel> | $Enums.ContentFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentFormatFilter<$PrismaModel>
    _max?: NestedEnumContentFormatFilter<$PrismaModel>
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.PostVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostVisibilityFilter<$PrismaModel>
    _max?: NestedEnumPostVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumFlagStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagStatus | EnumFlagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagStatusFilter<$PrismaModel> | $Enums.FlagStatus
  }

  export type NestedEnumFlagStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagStatus | EnumFlagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagStatusWithAggregatesFilter<$PrismaModel> | $Enums.FlagStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlagStatusFilter<$PrismaModel>
    _max?: NestedEnumFlagStatusFilter<$PrismaModel>
  }

  export type NestedEnumAIGenerationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AIGenerationStatus | EnumAIGenerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIGenerationStatus[] | ListEnumAIGenerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIGenerationStatus[] | ListEnumAIGenerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIGenerationStatusFilter<$PrismaModel> | $Enums.AIGenerationStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAIGenerationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIGenerationStatus | EnumAIGenerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIGenerationStatus[] | ListEnumAIGenerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIGenerationStatus[] | ListEnumAIGenerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIGenerationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AIGenerationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIGenerationStatusFilter<$PrismaModel>
    _max?: NestedEnumAIGenerationStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationCategory | EnumNotificationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationCategoryFilter<$PrismaModel> | $Enums.NotificationCategory
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationCategory | EnumNotificationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NotificationCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationCategoryFilter<$PrismaModel>
    _max?: NestedEnumNotificationCategoryFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type NestedEnumEmailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusFilter<$PrismaModel> | $Enums.EmailStatus
  }

  export type NestedEnumEmailTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailType | EnumEmailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTypeFilter<$PrismaModel> | $Enums.EmailType
  }

  export type NestedEnumEmailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailStatusFilter<$PrismaModel>
    _max?: NestedEnumEmailStatusFilter<$PrismaModel>
  }

  export type NestedEnumEmailTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailType | EnumEmailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmailType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailTypeFilter<$PrismaModel>
    _max?: NestedEnumEmailTypeFilter<$PrismaModel>
  }

  export type NestedEnumElementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeFilter<$PrismaModel> | $Enums.ElementType
  }

  export type NestedEnumElementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ElementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumElementTypeFilter<$PrismaModel>
    _max?: NestedEnumElementTypeFilter<$PrismaModel>
  }

  export type NestedEnumRecipientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecipientStatus | EnumRecipientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecipientStatusFilter<$PrismaModel> | $Enums.RecipientStatus
  }

  export type NestedEnumRecipientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecipientStatus | EnumRecipientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecipientStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecipientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecipientStatusFilter<$PrismaModel>
    _max?: NestedEnumRecipientStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ApiKeyCreateWithoutUserInput = {
    id?: string
    keyHash: string
    jwt: string
    createdAt?: Date | string
    isTrial?: boolean
    expiresAt: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutUserInput = {
    id?: string
    keyHash: string
    jwt: string
    createdAt?: Date | string
    isTrial?: boolean
    expiresAt: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyCreateManyUserInputEnvelope = {
    data: ApiKeyCreateManyUserInput | ApiKeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogAIGenerationCreateWithoutUserInput = {
    id?: string
    prompt: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIGenerationStatus
    output: string
    format?: $Enums.ContentFormat
    cost?: number | null
    tokensUsed?: number | null
    model?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    blogPosts?: BlogPostCreateNestedManyWithoutAiGenerationInput
  }

  export type BlogAIGenerationUncheckedCreateWithoutUserInput = {
    id?: string
    prompt: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIGenerationStatus
    output: string
    format?: $Enums.ContentFormat
    cost?: number | null
    tokensUsed?: number | null
    model?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAiGenerationInput
  }

  export type BlogAIGenerationCreateOrConnectWithoutUserInput = {
    where: BlogAIGenerationWhereUniqueInput
    create: XOR<BlogAIGenerationCreateWithoutUserInput, BlogAIGenerationUncheckedCreateWithoutUserInput>
  }

  export type BlogAIGenerationCreateManyUserInputEnvelope = {
    data: BlogAIGenerationCreateManyUserInput | BlogAIGenerationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogCommentCreateWithoutUserInput = {
    id?: string
    content: string
    userId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: BlogCommentCreateNestedOneWithoutRepliesInput
    replies?: BlogCommentCreateNestedManyWithoutParentInput
    post: BlogPostCreateNestedOneWithoutCommentsInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutCommentInput
  }

  export type BlogCommentUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    postId: string
    userId?: string | null
    parentId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: BlogCommentUncheckedCreateNestedManyWithoutParentInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type BlogCommentCreateOrConnectWithoutUserInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput>
  }

  export type BlogCommentCreateManyUserInputEnvelope = {
    data: BlogCommentCreateManyUserInput | BlogCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostCreateWithoutUserInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorBio: string
    authorTitle: string
    author: string
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: BlogCommentCreateNestedManyWithoutPostInput
    category?: BlogCategoryCreateNestedOneWithoutPostsInput
    aiGeneration?: BlogAIGenerationCreateNestedOneWithoutBlogPostsInput
    viewsCount?: BlogPostViewCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostCreateNestedManyWithoutPostInput
    tags?: BlogTagCreateNestedManyWithoutPostsInput
  }

  export type BlogPostUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorBio: string
    authorTitle: string
    author: string
    categoryId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedById?: string | null
    comments?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
    viewsCount?: BlogPostViewUncheckedCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutPostInput
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type BlogPostCreateOrConnectWithoutUserInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput>
  }

  export type BlogPostCreateManyUserInputEnvelope = {
    data: BlogPostCreateManyUserInput | BlogPostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostViewCreateWithoutUserInput = {
    id?: string
    externalName?: string | null
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutViewsCountInput
  }

  export type BlogPostViewUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    externalName?: string | null
    createdAt?: Date | string
  }

  export type BlogPostViewCreateOrConnectWithoutUserInput = {
    where: BlogPostViewWhereUniqueInput
    create: XOR<BlogPostViewCreateWithoutUserInput, BlogPostViewUncheckedCreateWithoutUserInput>
  }

  export type BlogPostViewCreateManyUserInputEnvelope = {
    data: BlogPostViewCreateManyUserInput | BlogPostViewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    newsLetterOwnerId: string
    messageId?: string | null
    elements?: EmailElementCreateNestedManyWithoutEmailInput
    campaign?: CampaignCreateNestedOneWithoutEmailsInput
    clickedLinks?: ClickedLinkCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientCreateNestedManyWithoutEmailInput
    template?: EmailTemplateCreateNestedOneWithoutEmailsInput
    emailAnalytics?: EmailAnalyticsCreateNestedOneWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    newsLetterOwnerId: string
    campaignId?: string | null
    messageId?: string | null
    elements?: EmailElementUncheckedCreateNestedManyWithoutEmailInput
    clickedLinks?: ClickedLinkUncheckedCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientUncheckedCreateNestedManyWithoutEmailInput
    emailAnalytics?: EmailAnalyticsUncheckedCreateNestedOneWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutUserInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutUserInput, EmailUncheckedCreateWithoutUserInput>
  }

  export type EmailCreateManyUserInputEnvelope = {
    data: EmailCreateManyUserInput | EmailCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FlagedBlogPostCreateWithoutUserInput = {
    id?: string
    reason: string
    comment: string
    flaggedBy: string
    status?: $Enums.FlagStatus
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    post: BlogPostCreateNestedOneWithoutFlaggedPostsInput
  }

  export type FlagedBlogPostUncheckedCreateWithoutUserInput = {
    id?: string
    reason: string
    comment: string
    flaggedBy: string
    status?: $Enums.FlagStatus
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    postId: string
  }

  export type FlagedBlogPostCreateOrConnectWithoutUserInput = {
    where: FlagedBlogPostWhereUniqueInput
    create: XOR<FlagedBlogPostCreateWithoutUserInput, FlagedBlogPostUncheckedCreateWithoutUserInput>
  }

  export type FlagedBlogPostCreateManyUserInputEnvelope = {
    data: FlagedBlogPostCreateManyUserInput | FlagedBlogPostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutUserInput = {
    id?: string
    description: string
    amount: number
    status: string
    invoiceUrl: string
    date?: Date | string
    externalId?: string | null
  }

  export type InvoiceUncheckedCreateWithoutUserInput = {
    id?: string
    description: string
    amount: number
    status: string
    invoiceUrl: string
    date?: Date | string
    externalId?: string | null
  }

  export type InvoiceCreateOrConnectWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateManyUserInputEnvelope = {
    data: InvoiceCreateManyUserInput | InvoiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type KycCreateWithoutUserInput = {
    id?: string
    accountType: $Enums.KYCAccountType
    status?: $Enums.KYCStatus
    levels: JsonNullValueInput | InputJsonValue
    documents: JsonNullValueInput | InputJsonValue
    livePhoto?: string | null
    reviewedTime?: Date | string | null
    reviewedBy?: string | null
    rejectedResponse?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    kycDocuments?: KYCDocumentCreateNestedManyWithoutKycInput
  }

  export type KycUncheckedCreateWithoutUserInput = {
    id?: string
    accountType: $Enums.KYCAccountType
    status?: $Enums.KYCStatus
    levels: JsonNullValueInput | InputJsonValue
    documents: JsonNullValueInput | InputJsonValue
    livePhoto?: string | null
    reviewedTime?: Date | string | null
    reviewedBy?: string | null
    rejectedResponse?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutKycInput
  }

  export type KycCreateOrConnectWithoutUserInput = {
    where: KycWhereUniqueInput
    create: XOR<KycCreateWithoutUserInput, KycUncheckedCreateWithoutUserInput>
  }

  export type MembershipUsageCreateWithoutUserInput = {
    id?: string
    month: string
    emailsSent?: number
    subscribersAdded?: number
    campaignsCreated?: number
    blogPostsCreated?: number
    aiGenerationsUsed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUsageUncheckedCreateWithoutUserInput = {
    id?: string
    month: string
    emailsSent?: number
    subscribersAdded?: number
    campaignsCreated?: number
    blogPostsCreated?: number
    aiGenerationsUsed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUsageCreateOrConnectWithoutUserInput = {
    where: MembershipUsageWhereUniqueInput
    create: XOR<MembershipUsageCreateWithoutUserInput, MembershipUsageUncheckedCreateWithoutUserInput>
  }

  export type MembershipUsageCreateManyUserInputEnvelope = {
    data: MembershipUsageCreateManyUserInput | MembershipUsageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailNotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    title: string
    content: JsonNullValueInput | InputJsonValue
    textContent?: string | null
    htmlContent?: string | null
    status?: $Enums.NotificationStatus
    priority?: $Enums.NotificationPriority
    emailsSentCount?: number | null
    openCount?: number | null
    clickCount?: number | null
    recipients?: number | null
    bounceCount?: number | null
    openedByEmails?: EmailNotificationCreateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationCreateclickedByEmailsInput | string[]
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    NotificationEmailClickedLink?: NotificationEmailClickedLinkCreateNestedManyWithoutNotificationEmailInput
  }

  export type EmailNotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    title: string
    content: JsonNullValueInput | InputJsonValue
    textContent?: string | null
    htmlContent?: string | null
    status?: $Enums.NotificationStatus
    priority?: $Enums.NotificationPriority
    emailsSentCount?: number | null
    openCount?: number | null
    clickCount?: number | null
    recipients?: number | null
    bounceCount?: number | null
    openedByEmails?: EmailNotificationCreateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationCreateclickedByEmailsInput | string[]
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    NotificationEmailClickedLink?: NotificationEmailClickedLinkUncheckedCreateNestedManyWithoutNotificationEmailInput
  }

  export type EmailNotificationCreateOrConnectWithoutUserInput = {
    where: EmailNotificationWhereUniqueInput
    create: XOR<EmailNotificationCreateWithoutUserInput, EmailNotificationUncheckedCreateWithoutUserInput>
  }

  export type EmailNotificationCreateManyUserInputEnvelope = {
    data: EmailNotificationCreateManyUserInput | EmailNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    jti: string
    hashed: string
    userAgent?: string | null
    ip?: string | null
    revoked?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    jti: string
    hashed: string
    userAgent?: string | null
    ip?: string | null
    revoked?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportedCommentCreateWithoutUserInput = {
    id?: string
    blogSlug: string
    blogOwner: string
    parentCommentBy: string
    reason?: string | null
    reportedAt?: Date | string
    resolved?: boolean
    comment: BlogCommentCreateNestedOneWithoutReportedCommentsInput
  }

  export type ReportedCommentUncheckedCreateWithoutUserInput = {
    id?: string
    commentId: string
    blogSlug: string
    blogOwner: string
    parentCommentBy: string
    reason?: string | null
    reportedAt?: Date | string
    resolved?: boolean
  }

  export type ReportedCommentCreateOrConnectWithoutUserInput = {
    where: ReportedCommentWhereUniqueInput
    create: XOR<ReportedCommentCreateWithoutUserInput, ReportedCommentUncheckedCreateWithoutUserInput>
  }

  export type ReportedCommentCreateManyUserInputEnvelope = {
    data: ReportedCommentCreateManyUserInput | ReportedCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    thumbnail?: string | null
    category: string
    tags?: EmailTemplateCreatetagsInput | string[]
    elements: JsonNullValueInput | InputJsonValue
    subject: string
    isPublic?: boolean
    isFeatured?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    thumbnail?: string | null
    category: string
    tags?: EmailTemplateCreatetagsInput | string[]
    elements: JsonNullValueInput | InputJsonValue
    subject: string
    isPublic?: boolean
    isFeatured?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutUserInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput>
  }

  export type EmailTemplateCreateManyUserInputEnvelope = {
    data: EmailTemplateCreateManyUserInput | EmailTemplateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    jwt?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    isTrial?: BoolFilter<"ApiKey"> | boolean
    expiresAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type BlogAIGenerationUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogAIGenerationWhereUniqueInput
    update: XOR<BlogAIGenerationUpdateWithoutUserInput, BlogAIGenerationUncheckedUpdateWithoutUserInput>
    create: XOR<BlogAIGenerationCreateWithoutUserInput, BlogAIGenerationUncheckedCreateWithoutUserInput>
  }

  export type BlogAIGenerationUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogAIGenerationWhereUniqueInput
    data: XOR<BlogAIGenerationUpdateWithoutUserInput, BlogAIGenerationUncheckedUpdateWithoutUserInput>
  }

  export type BlogAIGenerationUpdateManyWithWhereWithoutUserInput = {
    where: BlogAIGenerationScalarWhereInput
    data: XOR<BlogAIGenerationUpdateManyMutationInput, BlogAIGenerationUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogAIGenerationScalarWhereInput = {
    AND?: BlogAIGenerationScalarWhereInput | BlogAIGenerationScalarWhereInput[]
    OR?: BlogAIGenerationScalarWhereInput[]
    NOT?: BlogAIGenerationScalarWhereInput | BlogAIGenerationScalarWhereInput[]
    id?: StringFilter<"BlogAIGeneration"> | string
    prompt?: StringFilter<"BlogAIGeneration"> | string
    parameters?: JsonNullableFilter<"BlogAIGeneration">
    status?: EnumAIGenerationStatusFilter<"BlogAIGeneration"> | $Enums.AIGenerationStatus
    output?: StringFilter<"BlogAIGeneration"> | string
    format?: EnumContentFormatFilter<"BlogAIGeneration"> | $Enums.ContentFormat
    cost?: FloatNullableFilter<"BlogAIGeneration"> | number | null
    tokensUsed?: IntNullableFilter<"BlogAIGeneration"> | number | null
    model?: StringNullableFilter<"BlogAIGeneration"> | string | null
    userId?: StringFilter<"BlogAIGeneration"> | string
    createdAt?: DateTimeFilter<"BlogAIGeneration"> | Date | string
    completedAt?: DateTimeNullableFilter<"BlogAIGeneration"> | Date | string | null
  }

  export type BlogCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogCommentWhereUniqueInput
    update: XOR<BlogCommentUpdateWithoutUserInput, BlogCommentUncheckedUpdateWithoutUserInput>
    create: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput>
  }

  export type BlogCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogCommentWhereUniqueInput
    data: XOR<BlogCommentUpdateWithoutUserInput, BlogCommentUncheckedUpdateWithoutUserInput>
  }

  export type BlogCommentUpdateManyWithWhereWithoutUserInput = {
    where: BlogCommentScalarWhereInput
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogCommentScalarWhereInput = {
    AND?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
    OR?: BlogCommentScalarWhereInput[]
    NOT?: BlogCommentScalarWhereInput | BlogCommentScalarWhereInput[]
    id?: StringFilter<"BlogComment"> | string
    content?: StringFilter<"BlogComment"> | string
    authorId?: StringFilter<"BlogComment"> | string
    postId?: StringFilter<"BlogComment"> | string
    userId?: StringNullableFilter<"BlogComment"> | string | null
    parentId?: StringNullableFilter<"BlogComment"> | string | null
    externalName?: StringNullableFilter<"BlogComment"> | string | null
    externalAvatar?: StringNullableFilter<"BlogComment"> | string | null
    likes?: IntFilter<"BlogComment"> | number
    status?: StringFilter<"BlogComment"> | string
    createdAt?: DateTimeFilter<"BlogComment"> | Date | string
    updatedAt?: DateTimeFilter<"BlogComment"> | Date | string
  }

  export type BlogPostUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutUserInput, BlogPostUncheckedUpdateWithoutUserInput>
    create: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutUserInput, BlogPostUncheckedUpdateWithoutUserInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutUserInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    subtitle?: StringNullableFilter<"BlogPost"> | string | null
    slug?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    format?: EnumContentFormatFilter<"BlogPost"> | $Enums.ContentFormat
    status?: EnumPostStatusFilter<"BlogPost"> | $Enums.PostStatus
    visibility?: EnumPostVisibilityFilter<"BlogPost"> | $Enums.PostVisibility
    featuredImage?: StringFilter<"BlogPost"> | string
    featuredVideo?: StringNullableFilter<"BlogPost"> | string | null
    galleryImages?: StringNullableListFilter<"BlogPost">
    authorId?: StringFilter<"BlogPost"> | string
    authorBio?: StringFilter<"BlogPost"> | string
    authorTitle?: StringFilter<"BlogPost"> | string
    author?: StringFilter<"BlogPost"> | string
    categoryId?: StringNullableFilter<"BlogPost"> | string | null
    seoTitle?: StringNullableFilter<"BlogPost"> | string | null
    seoDescription?: StringNullableFilter<"BlogPost"> | string | null
    seoKeywords?: StringNullableListFilter<"BlogPost">
    seoScore?: IntFilter<"BlogPost"> | number
    shares?: IntFilter<"BlogPost"> | number
    readTime?: IntFilter<"BlogPost"> | number
    wordCount?: IntFilter<"BlogPost"> | number
    characterCount?: IntFilter<"BlogPost"> | number
    likes?: IntFilter<"BlogPost"> | number
    views?: IntFilter<"BlogPost"> | number
    flagReason?: StringNullableFilter<"BlogPost"> | string | null
    isFlagged?: BoolFilter<"BlogPost"> | boolean
    isFeatured?: BoolFilter<"BlogPost"> | boolean
    isPinned?: BoolFilter<"BlogPost"> | boolean
    allowComments?: BoolFilter<"BlogPost"> | boolean
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    flaggedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    scheduledAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    generatedById?: StringNullableFilter<"BlogPost"> | string | null
  }

  export type BlogPostViewUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogPostViewWhereUniqueInput
    update: XOR<BlogPostViewUpdateWithoutUserInput, BlogPostViewUncheckedUpdateWithoutUserInput>
    create: XOR<BlogPostViewCreateWithoutUserInput, BlogPostViewUncheckedCreateWithoutUserInput>
  }

  export type BlogPostViewUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogPostViewWhereUniqueInput
    data: XOR<BlogPostViewUpdateWithoutUserInput, BlogPostViewUncheckedUpdateWithoutUserInput>
  }

  export type BlogPostViewUpdateManyWithWhereWithoutUserInput = {
    where: BlogPostViewScalarWhereInput
    data: XOR<BlogPostViewUpdateManyMutationInput, BlogPostViewUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogPostViewScalarWhereInput = {
    AND?: BlogPostViewScalarWhereInput | BlogPostViewScalarWhereInput[]
    OR?: BlogPostViewScalarWhereInput[]
    NOT?: BlogPostViewScalarWhereInput | BlogPostViewScalarWhereInput[]
    id?: StringFilter<"BlogPostView"> | string
    postId?: StringFilter<"BlogPostView"> | string
    userId?: StringNullableFilter<"BlogPostView"> | string | null
    externalName?: StringNullableFilter<"BlogPostView"> | string | null
    createdAt?: DateTimeFilter<"BlogPostView"> | Date | string
  }

  export type EmailUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailWhereUniqueInput
    update: XOR<EmailUpdateWithoutUserInput, EmailUncheckedUpdateWithoutUserInput>
    create: XOR<EmailCreateWithoutUserInput, EmailUncheckedCreateWithoutUserInput>
  }

  export type EmailUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailWhereUniqueInput
    data: XOR<EmailUpdateWithoutUserInput, EmailUncheckedUpdateWithoutUserInput>
  }

  export type EmailUpdateManyWithWhereWithoutUserInput = {
    where: EmailScalarWhereInput
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailScalarWhereInput = {
    AND?: EmailScalarWhereInput | EmailScalarWhereInput[]
    OR?: EmailScalarWhereInput[]
    NOT?: EmailScalarWhereInput | EmailScalarWhereInput[]
    id?: StringFilter<"Email"> | string
    title?: StringFilter<"Email"> | string
    content?: StringFilter<"Email"> | string
    emailSubject?: StringFilter<"Email"> | string
    previewText?: StringNullableFilter<"Email"> | string | null
    builderMode?: StringFilter<"Email"> | string
    builderData?: JsonNullableFilter<"Email">
    templateUsed?: StringNullableFilter<"Email"> | string | null
    status?: EnumEmailStatusFilter<"Email"> | $Enums.EmailStatus
    emailType?: EnumEmailTypeFilter<"Email"> | $Enums.EmailType
    trackOpens?: BoolFilter<"Email"> | boolean
    trackClicks?: BoolFilter<"Email"> | boolean
    enableUnsubscribe?: BoolFilter<"Email"> | boolean
    scheduleDate?: DateTimeNullableFilter<"Email"> | Date | string | null
    scheduleTime?: StringNullableFilter<"Email"> | string | null
    emailsSentCount?: IntFilter<"Email"> | number
    recipients?: IntFilter<"Email"> | number
    bounceCount?: IntFilter<"Email"> | number
    openCount?: IntFilter<"Email"> | number
    clickCount?: IntFilter<"Email"> | number
    sentAt?: DateTimeNullableFilter<"Email"> | Date | string | null
    lastOpened?: DateTimeNullableFilter<"Email"> | Date | string | null
    lastClicked?: DateTimeNullableFilter<"Email"> | Date | string | null
    openedByIps?: StringNullableListFilter<"Email">
    openedByEmails?: StringNullableListFilter<"Email">
    clickedByIps?: StringNullableListFilter<"Email">
    clickedByEmails?: StringNullableListFilter<"Email">
    createdAt?: DateTimeFilter<"Email"> | Date | string
    updatedAt?: DateTimeFilter<"Email"> | Date | string
    userId?: StringFilter<"Email"> | string
    newsLetterOwnerId?: StringFilter<"Email"> | string
    campaignId?: StringNullableFilter<"Email"> | string | null
    messageId?: StringNullableFilter<"Email"> | string | null
  }

  export type FlagedBlogPostUpsertWithWhereUniqueWithoutUserInput = {
    where: FlagedBlogPostWhereUniqueInput
    update: XOR<FlagedBlogPostUpdateWithoutUserInput, FlagedBlogPostUncheckedUpdateWithoutUserInput>
    create: XOR<FlagedBlogPostCreateWithoutUserInput, FlagedBlogPostUncheckedCreateWithoutUserInput>
  }

  export type FlagedBlogPostUpdateWithWhereUniqueWithoutUserInput = {
    where: FlagedBlogPostWhereUniqueInput
    data: XOR<FlagedBlogPostUpdateWithoutUserInput, FlagedBlogPostUncheckedUpdateWithoutUserInput>
  }

  export type FlagedBlogPostUpdateManyWithWhereWithoutUserInput = {
    where: FlagedBlogPostScalarWhereInput
    data: XOR<FlagedBlogPostUpdateManyMutationInput, FlagedBlogPostUncheckedUpdateManyWithoutUserInput>
  }

  export type FlagedBlogPostScalarWhereInput = {
    AND?: FlagedBlogPostScalarWhereInput | FlagedBlogPostScalarWhereInput[]
    OR?: FlagedBlogPostScalarWhereInput[]
    NOT?: FlagedBlogPostScalarWhereInput | FlagedBlogPostScalarWhereInput[]
    id?: StringFilter<"FlagedBlogPost"> | string
    reason?: StringFilter<"FlagedBlogPost"> | string
    comment?: StringFilter<"FlagedBlogPost"> | string
    flaggedBy?: StringFilter<"FlagedBlogPost"> | string
    status?: EnumFlagStatusFilter<"FlagedBlogPost"> | $Enums.FlagStatus
    createdAt?: DateTimeFilter<"FlagedBlogPost"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"FlagedBlogPost"> | Date | string | null
    postId?: StringFilter<"FlagedBlogPost"> | string
    userId?: StringFilter<"FlagedBlogPost"> | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUserInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    description?: StringFilter<"Invoice"> | string
    amount?: IntFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    invoiceUrl?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    externalId?: StringNullableFilter<"Invoice"> | string | null
  }

  export type KycUpsertWithoutUserInput = {
    update: XOR<KycUpdateWithoutUserInput, KycUncheckedUpdateWithoutUserInput>
    create: XOR<KycCreateWithoutUserInput, KycUncheckedCreateWithoutUserInput>
    where?: KycWhereInput
  }

  export type KycUpdateToOneWithWhereWithoutUserInput = {
    where?: KycWhereInput
    data: XOR<KycUpdateWithoutUserInput, KycUncheckedUpdateWithoutUserInput>
  }

  export type KycUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: EnumKYCAccountTypeFieldUpdateOperationsInput | $Enums.KYCAccountType
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    levels?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    livePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedResponse?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kycDocuments?: KYCDocumentUpdateManyWithoutKycNestedInput
  }

  export type KycUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: EnumKYCAccountTypeFieldUpdateOperationsInput | $Enums.KYCAccountType
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    levels?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    livePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedResponse?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutKycNestedInput
  }

  export type MembershipUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: MembershipUsageWhereUniqueInput
    update: XOR<MembershipUsageUpdateWithoutUserInput, MembershipUsageUncheckedUpdateWithoutUserInput>
    create: XOR<MembershipUsageCreateWithoutUserInput, MembershipUsageUncheckedCreateWithoutUserInput>
  }

  export type MembershipUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: MembershipUsageWhereUniqueInput
    data: XOR<MembershipUsageUpdateWithoutUserInput, MembershipUsageUncheckedUpdateWithoutUserInput>
  }

  export type MembershipUsageUpdateManyWithWhereWithoutUserInput = {
    where: MembershipUsageScalarWhereInput
    data: XOR<MembershipUsageUpdateManyMutationInput, MembershipUsageUncheckedUpdateManyWithoutUserInput>
  }

  export type MembershipUsageScalarWhereInput = {
    AND?: MembershipUsageScalarWhereInput | MembershipUsageScalarWhereInput[]
    OR?: MembershipUsageScalarWhereInput[]
    NOT?: MembershipUsageScalarWhereInput | MembershipUsageScalarWhereInput[]
    id?: StringFilter<"MembershipUsage"> | string
    userId?: StringFilter<"MembershipUsage"> | string
    month?: StringFilter<"MembershipUsage"> | string
    emailsSent?: IntFilter<"MembershipUsage"> | number
    subscribersAdded?: IntFilter<"MembershipUsage"> | number
    campaignsCreated?: IntFilter<"MembershipUsage"> | number
    blogPostsCreated?: IntFilter<"MembershipUsage"> | number
    aiGenerationsUsed?: IntFilter<"MembershipUsage"> | number
    createdAt?: DateTimeFilter<"MembershipUsage"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipUsage"> | Date | string
  }

  export type EmailNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailNotificationWhereUniqueInput
    update: XOR<EmailNotificationUpdateWithoutUserInput, EmailNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<EmailNotificationCreateWithoutUserInput, EmailNotificationUncheckedCreateWithoutUserInput>
  }

  export type EmailNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailNotificationWhereUniqueInput
    data: XOR<EmailNotificationUpdateWithoutUserInput, EmailNotificationUncheckedUpdateWithoutUserInput>
  }

  export type EmailNotificationUpdateManyWithWhereWithoutUserInput = {
    where: EmailNotificationScalarWhereInput
    data: XOR<EmailNotificationUpdateManyMutationInput, EmailNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailNotificationScalarWhereInput = {
    AND?: EmailNotificationScalarWhereInput | EmailNotificationScalarWhereInput[]
    OR?: EmailNotificationScalarWhereInput[]
    NOT?: EmailNotificationScalarWhereInput | EmailNotificationScalarWhereInput[]
    id?: StringFilter<"EmailNotification"> | string
    type?: EnumNotificationTypeFilter<"EmailNotification"> | $Enums.NotificationType
    category?: EnumNotificationCategoryFilter<"EmailNotification"> | $Enums.NotificationCategory
    title?: StringFilter<"EmailNotification"> | string
    content?: JsonFilter<"EmailNotification">
    textContent?: StringNullableFilter<"EmailNotification"> | string | null
    htmlContent?: StringNullableFilter<"EmailNotification"> | string | null
    status?: EnumNotificationStatusFilter<"EmailNotification"> | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityFilter<"EmailNotification"> | $Enums.NotificationPriority
    userId?: StringFilter<"EmailNotification"> | string
    emailsSentCount?: IntNullableFilter<"EmailNotification"> | number | null
    openCount?: IntNullableFilter<"EmailNotification"> | number | null
    clickCount?: IntNullableFilter<"EmailNotification"> | number | null
    recipients?: IntNullableFilter<"EmailNotification"> | number | null
    bounceCount?: IntNullableFilter<"EmailNotification"> | number | null
    openedByEmails?: StringNullableListFilter<"EmailNotification">
    clickedByEmails?: StringNullableListFilter<"EmailNotification">
    lastOpened?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    lastClicked?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    metadata?: JsonNullableFilter<"EmailNotification">
    sentAt?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailNotification"> | Date | string
    updatedAt?: DateTimeFilter<"EmailNotification"> | Date | string
    read?: BoolFilter<"EmailNotification"> | boolean
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    jti?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    hashed?: StringFilter<"RefreshToken"> | string
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    ip?: StringNullableFilter<"RefreshToken"> | string | null
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type ReportedCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportedCommentWhereUniqueInput
    update: XOR<ReportedCommentUpdateWithoutUserInput, ReportedCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ReportedCommentCreateWithoutUserInput, ReportedCommentUncheckedCreateWithoutUserInput>
  }

  export type ReportedCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportedCommentWhereUniqueInput
    data: XOR<ReportedCommentUpdateWithoutUserInput, ReportedCommentUncheckedUpdateWithoutUserInput>
  }

  export type ReportedCommentUpdateManyWithWhereWithoutUserInput = {
    where: ReportedCommentScalarWhereInput
    data: XOR<ReportedCommentUpdateManyMutationInput, ReportedCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type ReportedCommentScalarWhereInput = {
    AND?: ReportedCommentScalarWhereInput | ReportedCommentScalarWhereInput[]
    OR?: ReportedCommentScalarWhereInput[]
    NOT?: ReportedCommentScalarWhereInput | ReportedCommentScalarWhereInput[]
    id?: StringFilter<"ReportedComment"> | string
    commentId?: StringFilter<"ReportedComment"> | string
    blogSlug?: StringFilter<"ReportedComment"> | string
    blogOwner?: StringFilter<"ReportedComment"> | string
    parentCommentBy?: StringFilter<"ReportedComment"> | string
    reportedBy?: StringFilter<"ReportedComment"> | string
    reason?: StringNullableFilter<"ReportedComment"> | string | null
    reportedAt?: DateTimeFilter<"ReportedComment"> | Date | string
    resolved?: BoolFilter<"ReportedComment"> | boolean
  }

  export type EmailTemplateUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailTemplateWhereUniqueInput
    update: XOR<EmailTemplateUpdateWithoutUserInput, EmailTemplateUncheckedUpdateWithoutUserInput>
    create: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput>
  }

  export type EmailTemplateUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailTemplateWhereUniqueInput
    data: XOR<EmailTemplateUpdateWithoutUserInput, EmailTemplateUncheckedUpdateWithoutUserInput>
  }

  export type EmailTemplateUpdateManyWithWhereWithoutUserInput = {
    where: EmailTemplateScalarWhereInput
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailTemplateScalarWhereInput = {
    AND?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
    OR?: EmailTemplateScalarWhereInput[]
    NOT?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    description?: StringNullableFilter<"EmailTemplate"> | string | null
    thumbnail?: StringNullableFilter<"EmailTemplate"> | string | null
    category?: StringFilter<"EmailTemplate"> | string
    tags?: StringNullableListFilter<"EmailTemplate">
    elements?: JsonFilter<"EmailTemplate">
    subject?: StringFilter<"EmailTemplate"> | string
    isPublic?: BoolFilter<"EmailTemplate"> | boolean
    isFeatured?: BoolFilter<"EmailTemplate"> | boolean
    usageCount?: IntFilter<"EmailTemplate"> | number
    userId?: StringNullableFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }

  export type UserCreateWithoutTokensInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTokensInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
  }

  export type UserUpsertWithoutTokensInput = {
    update: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
  }

  export type UserUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutApiKeysInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutKycInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKycInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKycInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKycInput, UserUncheckedCreateWithoutKycInput>
  }

  export type KYCDocumentCreateWithoutKycInput = {
    id?: string
    type: string
    url: string
    key: string
    uploadedAt?: Date | string
  }

  export type KYCDocumentUncheckedCreateWithoutKycInput = {
    id?: string
    type: string
    url: string
    key: string
    uploadedAt?: Date | string
  }

  export type KYCDocumentCreateOrConnectWithoutKycInput = {
    where: KYCDocumentWhereUniqueInput
    create: XOR<KYCDocumentCreateWithoutKycInput, KYCDocumentUncheckedCreateWithoutKycInput>
  }

  export type KYCDocumentCreateManyKycInputEnvelope = {
    data: KYCDocumentCreateManyKycInput | KYCDocumentCreateManyKycInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutKycInput = {
    update: XOR<UserUpdateWithoutKycInput, UserUncheckedUpdateWithoutKycInput>
    create: XOR<UserCreateWithoutKycInput, UserUncheckedCreateWithoutKycInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKycInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKycInput, UserUncheckedUpdateWithoutKycInput>
  }

  export type UserUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type KYCDocumentUpsertWithWhereUniqueWithoutKycInput = {
    where: KYCDocumentWhereUniqueInput
    update: XOR<KYCDocumentUpdateWithoutKycInput, KYCDocumentUncheckedUpdateWithoutKycInput>
    create: XOR<KYCDocumentCreateWithoutKycInput, KYCDocumentUncheckedCreateWithoutKycInput>
  }

  export type KYCDocumentUpdateWithWhereUniqueWithoutKycInput = {
    where: KYCDocumentWhereUniqueInput
    data: XOR<KYCDocumentUpdateWithoutKycInput, KYCDocumentUncheckedUpdateWithoutKycInput>
  }

  export type KYCDocumentUpdateManyWithWhereWithoutKycInput = {
    where: KYCDocumentScalarWhereInput
    data: XOR<KYCDocumentUpdateManyMutationInput, KYCDocumentUncheckedUpdateManyWithoutKycInput>
  }

  export type KYCDocumentScalarWhereInput = {
    AND?: KYCDocumentScalarWhereInput | KYCDocumentScalarWhereInput[]
    OR?: KYCDocumentScalarWhereInput[]
    NOT?: KYCDocumentScalarWhereInput | KYCDocumentScalarWhereInput[]
    id?: StringFilter<"KYCDocument"> | string
    kycId?: StringFilter<"KYCDocument"> | string
    type?: StringFilter<"KYCDocument"> | string
    url?: StringFilter<"KYCDocument"> | string
    key?: StringFilter<"KYCDocument"> | string
    uploadedAt?: DateTimeFilter<"KYCDocument"> | Date | string
  }

  export type KycCreateWithoutKycDocumentsInput = {
    id?: string
    accountType: $Enums.KYCAccountType
    status?: $Enums.KYCStatus
    levels: JsonNullValueInput | InputJsonValue
    documents: JsonNullValueInput | InputJsonValue
    livePhoto?: string | null
    reviewedTime?: Date | string | null
    reviewedBy?: string | null
    rejectedResponse?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKycInput
  }

  export type KycUncheckedCreateWithoutKycDocumentsInput = {
    id?: string
    userId: string
    accountType: $Enums.KYCAccountType
    status?: $Enums.KYCStatus
    levels: JsonNullValueInput | InputJsonValue
    documents: JsonNullValueInput | InputJsonValue
    livePhoto?: string | null
    reviewedTime?: Date | string | null
    reviewedBy?: string | null
    rejectedResponse?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KycCreateOrConnectWithoutKycDocumentsInput = {
    where: KycWhereUniqueInput
    create: XOR<KycCreateWithoutKycDocumentsInput, KycUncheckedCreateWithoutKycDocumentsInput>
  }

  export type KycUpsertWithoutKycDocumentsInput = {
    update: XOR<KycUpdateWithoutKycDocumentsInput, KycUncheckedUpdateWithoutKycDocumentsInput>
    create: XOR<KycCreateWithoutKycDocumentsInput, KycUncheckedCreateWithoutKycDocumentsInput>
    where?: KycWhereInput
  }

  export type KycUpdateToOneWithWhereWithoutKycDocumentsInput = {
    where?: KycWhereInput
    data: XOR<KycUpdateWithoutKycDocumentsInput, KycUncheckedUpdateWithoutKycDocumentsInput>
  }

  export type KycUpdateWithoutKycDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: EnumKYCAccountTypeFieldUpdateOperationsInput | $Enums.KYCAccountType
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    levels?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    livePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedResponse?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKycNestedInput
  }

  export type KycUncheckedUpdateWithoutKycDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: EnumKYCAccountTypeFieldUpdateOperationsInput | $Enums.KYCAccountType
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    levels?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    livePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedResponse?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUsageInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsageInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsageInput, UserUncheckedCreateWithoutUsageInput>
  }

  export type UserUpsertWithoutUsageInput = {
    update: XOR<UserUpdateWithoutUsageInput, UserUncheckedUpdateWithoutUsageInput>
    create: XOR<UserCreateWithoutUsageInput, UserUncheckedCreateWithoutUsageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsageInput, UserUncheckedUpdateWithoutUsageInput>
  }

  export type UserUpdateWithoutUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogCommentCreateWithoutPostInput = {
    id?: string
    content: string
    userId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBlogCommentsInput
    parent?: BlogCommentCreateNestedOneWithoutRepliesInput
    replies?: BlogCommentCreateNestedManyWithoutParentInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutCommentInput
  }

  export type BlogCommentUncheckedCreateWithoutPostInput = {
    id?: string
    content: string
    authorId: string
    userId?: string | null
    parentId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: BlogCommentUncheckedCreateNestedManyWithoutParentInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type BlogCommentCreateOrConnectWithoutPostInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput>
  }

  export type BlogCommentCreateManyPostInputEnvelope = {
    data: BlogCommentCreateManyPostInput | BlogCommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBlogPostsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogPostsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
  }

  export type BlogCategoryCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogCategoryUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogCategoryCreateOrConnectWithoutPostsInput = {
    where: BlogCategoryWhereUniqueInput
    create: XOR<BlogCategoryCreateWithoutPostsInput, BlogCategoryUncheckedCreateWithoutPostsInput>
  }

  export type BlogAIGenerationCreateWithoutBlogPostsInput = {
    id?: string
    prompt: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIGenerationStatus
    output: string
    format?: $Enums.ContentFormat
    cost?: number | null
    tokensUsed?: number | null
    model?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAIContentGenerationToExcerptInput
  }

  export type BlogAIGenerationUncheckedCreateWithoutBlogPostsInput = {
    id?: string
    prompt: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIGenerationStatus
    output: string
    format?: $Enums.ContentFormat
    cost?: number | null
    tokensUsed?: number | null
    model?: string | null
    userId: string
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type BlogAIGenerationCreateOrConnectWithoutBlogPostsInput = {
    where: BlogAIGenerationWhereUniqueInput
    create: XOR<BlogAIGenerationCreateWithoutBlogPostsInput, BlogAIGenerationUncheckedCreateWithoutBlogPostsInput>
  }

  export type BlogPostViewCreateWithoutPostInput = {
    id?: string
    externalName?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutPostViewsInput
  }

  export type BlogPostViewUncheckedCreateWithoutPostInput = {
    id?: string
    userId?: string | null
    externalName?: string | null
    createdAt?: Date | string
  }

  export type BlogPostViewCreateOrConnectWithoutPostInput = {
    where: BlogPostViewWhereUniqueInput
    create: XOR<BlogPostViewCreateWithoutPostInput, BlogPostViewUncheckedCreateWithoutPostInput>
  }

  export type BlogPostViewCreateManyPostInputEnvelope = {
    data: BlogPostViewCreateManyPostInput | BlogPostViewCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type FlagedBlogPostCreateWithoutPostInput = {
    id?: string
    reason: string
    comment: string
    flaggedBy: string
    status?: $Enums.FlagStatus
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    user: UserCreateNestedOneWithoutFlagedPostsInput
  }

  export type FlagedBlogPostUncheckedCreateWithoutPostInput = {
    id?: string
    reason: string
    comment: string
    flaggedBy: string
    status?: $Enums.FlagStatus
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    userId: string
  }

  export type FlagedBlogPostCreateOrConnectWithoutPostInput = {
    where: FlagedBlogPostWhereUniqueInput
    create: XOR<FlagedBlogPostCreateWithoutPostInput, FlagedBlogPostUncheckedCreateWithoutPostInput>
  }

  export type FlagedBlogPostCreateManyPostInputEnvelope = {
    data: FlagedBlogPostCreateManyPostInput | FlagedBlogPostCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type BlogTagCreateWithoutPostsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogTagUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogTagCreateOrConnectWithoutPostsInput = {
    where: BlogTagWhereUniqueInput
    create: XOR<BlogTagCreateWithoutPostsInput, BlogTagUncheckedCreateWithoutPostsInput>
  }

  export type BlogCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: BlogCommentWhereUniqueInput
    update: XOR<BlogCommentUpdateWithoutPostInput, BlogCommentUncheckedUpdateWithoutPostInput>
    create: XOR<BlogCommentCreateWithoutPostInput, BlogCommentUncheckedCreateWithoutPostInput>
  }

  export type BlogCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: BlogCommentWhereUniqueInput
    data: XOR<BlogCommentUpdateWithoutPostInput, BlogCommentUncheckedUpdateWithoutPostInput>
  }

  export type BlogCommentUpdateManyWithWhereWithoutPostInput = {
    where: BlogCommentScalarWhereInput
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyWithoutPostInput>
  }

  export type UserUpsertWithoutBlogPostsInput = {
    update: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type UserUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogCategoryUpsertWithoutPostsInput = {
    update: XOR<BlogCategoryUpdateWithoutPostsInput, BlogCategoryUncheckedUpdateWithoutPostsInput>
    create: XOR<BlogCategoryCreateWithoutPostsInput, BlogCategoryUncheckedCreateWithoutPostsInput>
    where?: BlogCategoryWhereInput
  }

  export type BlogCategoryUpdateToOneWithWhereWithoutPostsInput = {
    where?: BlogCategoryWhereInput
    data: XOR<BlogCategoryUpdateWithoutPostsInput, BlogCategoryUncheckedUpdateWithoutPostsInput>
  }

  export type BlogCategoryUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCategoryUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogAIGenerationUpsertWithoutBlogPostsInput = {
    update: XOR<BlogAIGenerationUpdateWithoutBlogPostsInput, BlogAIGenerationUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<BlogAIGenerationCreateWithoutBlogPostsInput, BlogAIGenerationUncheckedCreateWithoutBlogPostsInput>
    where?: BlogAIGenerationWhereInput
  }

  export type BlogAIGenerationUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: BlogAIGenerationWhereInput
    data: XOR<BlogAIGenerationUpdateWithoutBlogPostsInput, BlogAIGenerationUncheckedUpdateWithoutBlogPostsInput>
  }

  export type BlogAIGenerationUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIGenerationStatusFieldUpdateOperationsInput | $Enums.AIGenerationStatus
    output?: StringFieldUpdateOperationsInput | string
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAIContentGenerationToExcerptNestedInput
  }

  export type BlogAIGenerationUncheckedUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIGenerationStatusFieldUpdateOperationsInput | $Enums.AIGenerationStatus
    output?: StringFieldUpdateOperationsInput | string
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlogPostViewUpsertWithWhereUniqueWithoutPostInput = {
    where: BlogPostViewWhereUniqueInput
    update: XOR<BlogPostViewUpdateWithoutPostInput, BlogPostViewUncheckedUpdateWithoutPostInput>
    create: XOR<BlogPostViewCreateWithoutPostInput, BlogPostViewUncheckedCreateWithoutPostInput>
  }

  export type BlogPostViewUpdateWithWhereUniqueWithoutPostInput = {
    where: BlogPostViewWhereUniqueInput
    data: XOR<BlogPostViewUpdateWithoutPostInput, BlogPostViewUncheckedUpdateWithoutPostInput>
  }

  export type BlogPostViewUpdateManyWithWhereWithoutPostInput = {
    where: BlogPostViewScalarWhereInput
    data: XOR<BlogPostViewUpdateManyMutationInput, BlogPostViewUncheckedUpdateManyWithoutPostInput>
  }

  export type FlagedBlogPostUpsertWithWhereUniqueWithoutPostInput = {
    where: FlagedBlogPostWhereUniqueInput
    update: XOR<FlagedBlogPostUpdateWithoutPostInput, FlagedBlogPostUncheckedUpdateWithoutPostInput>
    create: XOR<FlagedBlogPostCreateWithoutPostInput, FlagedBlogPostUncheckedCreateWithoutPostInput>
  }

  export type FlagedBlogPostUpdateWithWhereUniqueWithoutPostInput = {
    where: FlagedBlogPostWhereUniqueInput
    data: XOR<FlagedBlogPostUpdateWithoutPostInput, FlagedBlogPostUncheckedUpdateWithoutPostInput>
  }

  export type FlagedBlogPostUpdateManyWithWhereWithoutPostInput = {
    where: FlagedBlogPostScalarWhereInput
    data: XOR<FlagedBlogPostUpdateManyMutationInput, FlagedBlogPostUncheckedUpdateManyWithoutPostInput>
  }

  export type BlogTagUpsertWithWhereUniqueWithoutPostsInput = {
    where: BlogTagWhereUniqueInput
    update: XOR<BlogTagUpdateWithoutPostsInput, BlogTagUncheckedUpdateWithoutPostsInput>
    create: XOR<BlogTagCreateWithoutPostsInput, BlogTagUncheckedCreateWithoutPostsInput>
  }

  export type BlogTagUpdateWithWhereUniqueWithoutPostsInput = {
    where: BlogTagWhereUniqueInput
    data: XOR<BlogTagUpdateWithoutPostsInput, BlogTagUncheckedUpdateWithoutPostsInput>
  }

  export type BlogTagUpdateManyWithWhereWithoutPostsInput = {
    where: BlogTagScalarWhereInput
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyWithoutPostsInput>
  }

  export type BlogTagScalarWhereInput = {
    AND?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
    OR?: BlogTagScalarWhereInput[]
    NOT?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
    id?: StringFilter<"BlogTag"> | string
    name?: StringFilter<"BlogTag"> | string
    createdAt?: DateTimeFilter<"BlogTag"> | Date | string
    updatedAt?: DateTimeFilter<"BlogTag"> | Date | string
  }

  export type BlogPostCreateWithoutFlaggedPostsInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorBio: string
    authorTitle: string
    author: string
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: BlogCommentCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutBlogPostsInput
    category?: BlogCategoryCreateNestedOneWithoutPostsInput
    aiGeneration?: BlogAIGenerationCreateNestedOneWithoutBlogPostsInput
    viewsCount?: BlogPostViewCreateNestedManyWithoutPostInput
    tags?: BlogTagCreateNestedManyWithoutPostsInput
  }

  export type BlogPostUncheckedCreateWithoutFlaggedPostsInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorId: string
    authorBio: string
    authorTitle: string
    author: string
    categoryId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedById?: string | null
    comments?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
    viewsCount?: BlogPostViewUncheckedCreateNestedManyWithoutPostInput
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type BlogPostCreateOrConnectWithoutFlaggedPostsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutFlaggedPostsInput, BlogPostUncheckedCreateWithoutFlaggedPostsInput>
  }

  export type UserCreateWithoutFlagedPostsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFlagedPostsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFlagedPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFlagedPostsInput, UserUncheckedCreateWithoutFlagedPostsInput>
  }

  export type BlogPostUpsertWithoutFlaggedPostsInput = {
    update: XOR<BlogPostUpdateWithoutFlaggedPostsInput, BlogPostUncheckedUpdateWithoutFlaggedPostsInput>
    create: XOR<BlogPostCreateWithoutFlaggedPostsInput, BlogPostUncheckedCreateWithoutFlaggedPostsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutFlaggedPostsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutFlaggedPostsInput, BlogPostUncheckedUpdateWithoutFlaggedPostsInput>
  }

  export type BlogPostUpdateWithoutFlaggedPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: BlogCommentUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    category?: BlogCategoryUpdateOneWithoutPostsNestedInput
    aiGeneration?: BlogAIGenerationUpdateOneWithoutBlogPostsNestedInput
    viewsCount?: BlogPostViewUpdateManyWithoutPostNestedInput
    tags?: BlogTagUpdateManyWithoutPostsNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutFlaggedPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
    viewsCount?: BlogPostViewUncheckedUpdateManyWithoutPostNestedInput
    tags?: BlogTagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type UserUpsertWithoutFlagedPostsInput = {
    update: XOR<UserUpdateWithoutFlagedPostsInput, UserUncheckedUpdateWithoutFlagedPostsInput>
    create: XOR<UserCreateWithoutFlagedPostsInput, UserUncheckedCreateWithoutFlagedPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFlagedPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFlagedPostsInput, UserUncheckedUpdateWithoutFlagedPostsInput>
  }

  export type UserUpdateWithoutFlagedPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFlagedPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogPostCreateWithoutViewsCountInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorBio: string
    authorTitle: string
    author: string
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: BlogCommentCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutBlogPostsInput
    category?: BlogCategoryCreateNestedOneWithoutPostsInput
    aiGeneration?: BlogAIGenerationCreateNestedOneWithoutBlogPostsInput
    flaggedPosts?: FlagedBlogPostCreateNestedManyWithoutPostInput
    tags?: BlogTagCreateNestedManyWithoutPostsInput
  }

  export type BlogPostUncheckedCreateWithoutViewsCountInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorId: string
    authorBio: string
    authorTitle: string
    author: string
    categoryId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedById?: string | null
    comments?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutPostInput
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type BlogPostCreateOrConnectWithoutViewsCountInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutViewsCountInput, BlogPostUncheckedCreateWithoutViewsCountInput>
  }

  export type UserCreateWithoutPostViewsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostViewsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostViewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostViewsInput, UserUncheckedCreateWithoutPostViewsInput>
  }

  export type BlogPostUpsertWithoutViewsCountInput = {
    update: XOR<BlogPostUpdateWithoutViewsCountInput, BlogPostUncheckedUpdateWithoutViewsCountInput>
    create: XOR<BlogPostCreateWithoutViewsCountInput, BlogPostUncheckedCreateWithoutViewsCountInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutViewsCountInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutViewsCountInput, BlogPostUncheckedUpdateWithoutViewsCountInput>
  }

  export type BlogPostUpdateWithoutViewsCountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: BlogCommentUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    category?: BlogCategoryUpdateOneWithoutPostsNestedInput
    aiGeneration?: BlogAIGenerationUpdateOneWithoutBlogPostsNestedInput
    flaggedPosts?: FlagedBlogPostUpdateManyWithoutPostNestedInput
    tags?: BlogTagUpdateManyWithoutPostsNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutViewsCountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutPostNestedInput
    tags?: BlogTagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type UserUpsertWithoutPostViewsInput = {
    update: XOR<UserUpdateWithoutPostViewsInput, UserUncheckedUpdateWithoutPostViewsInput>
    create: XOR<UserCreateWithoutPostViewsInput, UserUncheckedCreateWithoutPostViewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostViewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostViewsInput, UserUncheckedUpdateWithoutPostViewsInput>
  }

  export type UserUpdateWithoutPostViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogPostCreateWithoutCategoryInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorBio: string
    authorTitle: string
    author: string
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: BlogCommentCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutBlogPostsInput
    aiGeneration?: BlogAIGenerationCreateNestedOneWithoutBlogPostsInput
    viewsCount?: BlogPostViewCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostCreateNestedManyWithoutPostInput
    tags?: BlogTagCreateNestedManyWithoutPostsInput
  }

  export type BlogPostUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorId: string
    authorBio: string
    authorTitle: string
    author: string
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedById?: string | null
    comments?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
    viewsCount?: BlogPostViewUncheckedCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutPostInput
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type BlogPostCreateOrConnectWithoutCategoryInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput>
  }

  export type BlogPostCreateManyCategoryInputEnvelope = {
    data: BlogPostCreateManyCategoryInput | BlogPostCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutCategoryInput, BlogPostUncheckedUpdateWithoutCategoryInput>
    create: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutCategoryInput, BlogPostUncheckedUpdateWithoutCategoryInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutCategoryInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutCategoryInput>
  }

  export type BlogPostCreateWithoutTagsInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorBio: string
    authorTitle: string
    author: string
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: BlogCommentCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutBlogPostsInput
    category?: BlogCategoryCreateNestedOneWithoutPostsInput
    aiGeneration?: BlogAIGenerationCreateNestedOneWithoutBlogPostsInput
    viewsCount?: BlogPostViewCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorId: string
    authorBio: string
    authorTitle: string
    author: string
    categoryId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedById?: string | null
    comments?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
    viewsCount?: BlogPostViewUncheckedCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutTagsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
  }

  export type BlogPostUpsertWithWhereUniqueWithoutTagsInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutTagsInput, BlogPostUncheckedUpdateWithoutTagsInput>
    create: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutTagsInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutTagsInput, BlogPostUncheckedUpdateWithoutTagsInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutTagsInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutTagsInput>
  }

  export type UserCreateWithoutBlogCommentsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogCommentsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogCommentsInput, UserUncheckedCreateWithoutBlogCommentsInput>
  }

  export type BlogCommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    userId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBlogCommentsInput
    parent?: BlogCommentCreateNestedOneWithoutRepliesInput
    post: BlogPostCreateNestedOneWithoutCommentsInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutCommentInput
  }

  export type BlogCommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    content: string
    authorId: string
    postId: string
    userId?: string | null
    parentId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type BlogCommentCreateOrConnectWithoutRepliesInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutRepliesInput, BlogCommentUncheckedCreateWithoutRepliesInput>
  }

  export type BlogCommentCreateWithoutParentInput = {
    id?: string
    content: string
    userId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBlogCommentsInput
    replies?: BlogCommentCreateNestedManyWithoutParentInput
    post: BlogPostCreateNestedOneWithoutCommentsInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutCommentInput
  }

  export type BlogCommentUncheckedCreateWithoutParentInput = {
    id?: string
    content: string
    authorId: string
    postId: string
    userId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: BlogCommentUncheckedCreateNestedManyWithoutParentInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type BlogCommentCreateOrConnectWithoutParentInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutParentInput, BlogCommentUncheckedCreateWithoutParentInput>
  }

  export type BlogCommentCreateManyParentInputEnvelope = {
    data: BlogCommentCreateManyParentInput | BlogCommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostCreateWithoutCommentsInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorBio: string
    authorTitle: string
    author: string
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBlogPostsInput
    category?: BlogCategoryCreateNestedOneWithoutPostsInput
    aiGeneration?: BlogAIGenerationCreateNestedOneWithoutBlogPostsInput
    viewsCount?: BlogPostViewCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostCreateNestedManyWithoutPostInput
    tags?: BlogTagCreateNestedManyWithoutPostsInput
  }

  export type BlogPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorId: string
    authorBio: string
    authorTitle: string
    author: string
    categoryId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedById?: string | null
    viewsCount?: BlogPostViewUncheckedCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutPostInput
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type BlogPostCreateOrConnectWithoutCommentsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutCommentsInput, BlogPostUncheckedCreateWithoutCommentsInput>
  }

  export type ReportedCommentCreateWithoutCommentInput = {
    id?: string
    blogSlug: string
    blogOwner: string
    parentCommentBy: string
    reason?: string | null
    reportedAt?: Date | string
    resolved?: boolean
    user: UserCreateNestedOneWithoutReportedCommentsInput
  }

  export type ReportedCommentUncheckedCreateWithoutCommentInput = {
    id?: string
    blogSlug: string
    blogOwner: string
    parentCommentBy: string
    reportedBy: string
    reason?: string | null
    reportedAt?: Date | string
    resolved?: boolean
  }

  export type ReportedCommentCreateOrConnectWithoutCommentInput = {
    where: ReportedCommentWhereUniqueInput
    create: XOR<ReportedCommentCreateWithoutCommentInput, ReportedCommentUncheckedCreateWithoutCommentInput>
  }

  export type ReportedCommentCreateManyCommentInputEnvelope = {
    data: ReportedCommentCreateManyCommentInput | ReportedCommentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBlogCommentsInput = {
    update: XOR<UserUpdateWithoutBlogCommentsInput, UserUncheckedUpdateWithoutBlogCommentsInput>
    create: XOR<UserCreateWithoutBlogCommentsInput, UserUncheckedCreateWithoutBlogCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogCommentsInput, UserUncheckedUpdateWithoutBlogCommentsInput>
  }

  export type UserUpdateWithoutBlogCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogCommentUpsertWithoutRepliesInput = {
    update: XOR<BlogCommentUpdateWithoutRepliesInput, BlogCommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<BlogCommentCreateWithoutRepliesInput, BlogCommentUncheckedCreateWithoutRepliesInput>
    where?: BlogCommentWhereInput
  }

  export type BlogCommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: BlogCommentWhereInput
    data: XOR<BlogCommentUpdateWithoutRepliesInput, BlogCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type BlogCommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogCommentsNestedInput
    parent?: BlogCommentUpdateOneWithoutRepliesNestedInput
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutCommentNestedInput
  }

  export type BlogCommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type BlogCommentUpsertWithWhereUniqueWithoutParentInput = {
    where: BlogCommentWhereUniqueInput
    update: XOR<BlogCommentUpdateWithoutParentInput, BlogCommentUncheckedUpdateWithoutParentInput>
    create: XOR<BlogCommentCreateWithoutParentInput, BlogCommentUncheckedCreateWithoutParentInput>
  }

  export type BlogCommentUpdateWithWhereUniqueWithoutParentInput = {
    where: BlogCommentWhereUniqueInput
    data: XOR<BlogCommentUpdateWithoutParentInput, BlogCommentUncheckedUpdateWithoutParentInput>
  }

  export type BlogCommentUpdateManyWithWhereWithoutParentInput = {
    where: BlogCommentScalarWhereInput
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyWithoutParentInput>
  }

  export type BlogPostUpsertWithoutCommentsInput = {
    update: XOR<BlogPostUpdateWithoutCommentsInput, BlogPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<BlogPostCreateWithoutCommentsInput, BlogPostUncheckedCreateWithoutCommentsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutCommentsInput, BlogPostUncheckedUpdateWithoutCommentsInput>
  }

  export type BlogPostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    category?: BlogCategoryUpdateOneWithoutPostsNestedInput
    aiGeneration?: BlogAIGenerationUpdateOneWithoutBlogPostsNestedInput
    viewsCount?: BlogPostViewUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUpdateManyWithoutPostNestedInput
    tags?: BlogTagUpdateManyWithoutPostsNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
    viewsCount?: BlogPostViewUncheckedUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutPostNestedInput
    tags?: BlogTagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type ReportedCommentUpsertWithWhereUniqueWithoutCommentInput = {
    where: ReportedCommentWhereUniqueInput
    update: XOR<ReportedCommentUpdateWithoutCommentInput, ReportedCommentUncheckedUpdateWithoutCommentInput>
    create: XOR<ReportedCommentCreateWithoutCommentInput, ReportedCommentUncheckedCreateWithoutCommentInput>
  }

  export type ReportedCommentUpdateWithWhereUniqueWithoutCommentInput = {
    where: ReportedCommentWhereUniqueInput
    data: XOR<ReportedCommentUpdateWithoutCommentInput, ReportedCommentUncheckedUpdateWithoutCommentInput>
  }

  export type ReportedCommentUpdateManyWithWhereWithoutCommentInput = {
    where: ReportedCommentScalarWhereInput
    data: XOR<ReportedCommentUpdateManyMutationInput, ReportedCommentUncheckedUpdateManyWithoutCommentInput>
  }

  export type BlogCommentCreateWithoutReportedCommentsInput = {
    id?: string
    content: string
    userId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBlogCommentsInput
    parent?: BlogCommentCreateNestedOneWithoutRepliesInput
    replies?: BlogCommentCreateNestedManyWithoutParentInput
    post: BlogPostCreateNestedOneWithoutCommentsInput
  }

  export type BlogCommentUncheckedCreateWithoutReportedCommentsInput = {
    id?: string
    content: string
    authorId: string
    postId: string
    userId?: string | null
    parentId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: BlogCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type BlogCommentCreateOrConnectWithoutReportedCommentsInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutReportedCommentsInput, BlogCommentUncheckedCreateWithoutReportedCommentsInput>
  }

  export type UserCreateWithoutReportedCommentsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportedCommentsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportedCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportedCommentsInput, UserUncheckedCreateWithoutReportedCommentsInput>
  }

  export type BlogCommentUpsertWithoutReportedCommentsInput = {
    update: XOR<BlogCommentUpdateWithoutReportedCommentsInput, BlogCommentUncheckedUpdateWithoutReportedCommentsInput>
    create: XOR<BlogCommentCreateWithoutReportedCommentsInput, BlogCommentUncheckedCreateWithoutReportedCommentsInput>
    where?: BlogCommentWhereInput
  }

  export type BlogCommentUpdateToOneWithWhereWithoutReportedCommentsInput = {
    where?: BlogCommentWhereInput
    data: XOR<BlogCommentUpdateWithoutReportedCommentsInput, BlogCommentUncheckedUpdateWithoutReportedCommentsInput>
  }

  export type BlogCommentUpdateWithoutReportedCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogCommentsNestedInput
    parent?: BlogCommentUpdateOneWithoutRepliesNestedInput
    replies?: BlogCommentUpdateManyWithoutParentNestedInput
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type BlogCommentUncheckedUpdateWithoutReportedCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: BlogCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserUpsertWithoutReportedCommentsInput = {
    update: XOR<UserUpdateWithoutReportedCommentsInput, UserUncheckedUpdateWithoutReportedCommentsInput>
    create: XOR<UserCreateWithoutReportedCommentsInput, UserUncheckedCreateWithoutReportedCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportedCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportedCommentsInput, UserUncheckedUpdateWithoutReportedCommentsInput>
  }

  export type UserUpdateWithoutReportedCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportedCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAIContentGenerationToExcerptInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAIContentGenerationToExcerptInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAIContentGenerationToExcerptInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAIContentGenerationToExcerptInput, UserUncheckedCreateWithoutAIContentGenerationToExcerptInput>
  }

  export type BlogPostCreateWithoutAiGenerationInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorBio: string
    authorTitle: string
    author: string
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: BlogCommentCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutBlogPostsInput
    category?: BlogCategoryCreateNestedOneWithoutPostsInput
    viewsCount?: BlogPostViewCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostCreateNestedManyWithoutPostInput
    tags?: BlogTagCreateNestedManyWithoutPostsInput
  }

  export type BlogPostUncheckedCreateWithoutAiGenerationInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorId: string
    authorBio: string
    authorTitle: string
    author: string
    categoryId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: BlogCommentUncheckedCreateNestedManyWithoutPostInput
    viewsCount?: BlogPostViewUncheckedCreateNestedManyWithoutPostInput
    flaggedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutPostInput
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type BlogPostCreateOrConnectWithoutAiGenerationInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutAiGenerationInput, BlogPostUncheckedCreateWithoutAiGenerationInput>
  }

  export type BlogPostCreateManyAiGenerationInputEnvelope = {
    data: BlogPostCreateManyAiGenerationInput | BlogPostCreateManyAiGenerationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAIContentGenerationToExcerptInput = {
    update: XOR<UserUpdateWithoutAIContentGenerationToExcerptInput, UserUncheckedUpdateWithoutAIContentGenerationToExcerptInput>
    create: XOR<UserCreateWithoutAIContentGenerationToExcerptInput, UserUncheckedCreateWithoutAIContentGenerationToExcerptInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAIContentGenerationToExcerptInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAIContentGenerationToExcerptInput, UserUncheckedUpdateWithoutAIContentGenerationToExcerptInput>
  }

  export type UserUpdateWithoutAIContentGenerationToExcerptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAIContentGenerationToExcerptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogPostUpsertWithWhereUniqueWithoutAiGenerationInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutAiGenerationInput, BlogPostUncheckedUpdateWithoutAiGenerationInput>
    create: XOR<BlogPostCreateWithoutAiGenerationInput, BlogPostUncheckedCreateWithoutAiGenerationInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutAiGenerationInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutAiGenerationInput, BlogPostUncheckedUpdateWithoutAiGenerationInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutAiGenerationInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutAiGenerationInput>
  }

  export type EmailCreateWithoutCampaignInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    newsLetterOwnerId: string
    messageId?: string | null
    elements?: EmailElementCreateNestedManyWithoutEmailInput
    user: UserCreateNestedOneWithoutEmailsInput
    clickedLinks?: ClickedLinkCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientCreateNestedManyWithoutEmailInput
    template?: EmailTemplateCreateNestedOneWithoutEmailsInput
    emailAnalytics?: EmailAnalyticsCreateNestedOneWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutCampaignInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    newsLetterOwnerId: string
    messageId?: string | null
    elements?: EmailElementUncheckedCreateNestedManyWithoutEmailInput
    clickedLinks?: ClickedLinkUncheckedCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientUncheckedCreateNestedManyWithoutEmailInput
    emailAnalytics?: EmailAnalyticsUncheckedCreateNestedOneWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutCampaignInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutCampaignInput, EmailUncheckedCreateWithoutCampaignInput>
  }

  export type EmailCreateManyCampaignInputEnvelope = {
    data: EmailCreateManyCampaignInput | EmailCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type EmailUpsertWithWhereUniqueWithoutCampaignInput = {
    where: EmailWhereUniqueInput
    update: XOR<EmailUpdateWithoutCampaignInput, EmailUncheckedUpdateWithoutCampaignInput>
    create: XOR<EmailCreateWithoutCampaignInput, EmailUncheckedCreateWithoutCampaignInput>
  }

  export type EmailUpdateWithWhereUniqueWithoutCampaignInput = {
    where: EmailWhereUniqueInput
    data: XOR<EmailUpdateWithoutCampaignInput, EmailUncheckedUpdateWithoutCampaignInput>
  }

  export type EmailUpdateManyWithWhereWithoutCampaignInput = {
    where: EmailScalarWhereInput
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyWithoutCampaignInput>
  }

  export type UserCreateWithoutNotificationEmailsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationEmailsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationEmailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationEmailsInput, UserUncheckedCreateWithoutNotificationEmailsInput>
  }

  export type NotificationEmailClickedLinkCreateWithoutNotificationEmailInput = {
    id?: string
    url: string
    clickedAt?: Date | string
    clickedBy?: string | null
  }

  export type NotificationEmailClickedLinkUncheckedCreateWithoutNotificationEmailInput = {
    id?: string
    url: string
    clickedAt?: Date | string
    clickedBy?: string | null
  }

  export type NotificationEmailClickedLinkCreateOrConnectWithoutNotificationEmailInput = {
    where: NotificationEmailClickedLinkWhereUniqueInput
    create: XOR<NotificationEmailClickedLinkCreateWithoutNotificationEmailInput, NotificationEmailClickedLinkUncheckedCreateWithoutNotificationEmailInput>
  }

  export type NotificationEmailClickedLinkCreateManyNotificationEmailInputEnvelope = {
    data: NotificationEmailClickedLinkCreateManyNotificationEmailInput | NotificationEmailClickedLinkCreateManyNotificationEmailInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutNotificationEmailsInput = {
    update: XOR<UserUpdateWithoutNotificationEmailsInput, UserUncheckedUpdateWithoutNotificationEmailsInput>
    create: XOR<UserCreateWithoutNotificationEmailsInput, UserUncheckedCreateWithoutNotificationEmailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationEmailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationEmailsInput, UserUncheckedUpdateWithoutNotificationEmailsInput>
  }

  export type UserUpdateWithoutNotificationEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationEmailClickedLinkUpsertWithWhereUniqueWithoutNotificationEmailInput = {
    where: NotificationEmailClickedLinkWhereUniqueInput
    update: XOR<NotificationEmailClickedLinkUpdateWithoutNotificationEmailInput, NotificationEmailClickedLinkUncheckedUpdateWithoutNotificationEmailInput>
    create: XOR<NotificationEmailClickedLinkCreateWithoutNotificationEmailInput, NotificationEmailClickedLinkUncheckedCreateWithoutNotificationEmailInput>
  }

  export type NotificationEmailClickedLinkUpdateWithWhereUniqueWithoutNotificationEmailInput = {
    where: NotificationEmailClickedLinkWhereUniqueInput
    data: XOR<NotificationEmailClickedLinkUpdateWithoutNotificationEmailInput, NotificationEmailClickedLinkUncheckedUpdateWithoutNotificationEmailInput>
  }

  export type NotificationEmailClickedLinkUpdateManyWithWhereWithoutNotificationEmailInput = {
    where: NotificationEmailClickedLinkScalarWhereInput
    data: XOR<NotificationEmailClickedLinkUpdateManyMutationInput, NotificationEmailClickedLinkUncheckedUpdateManyWithoutNotificationEmailInput>
  }

  export type NotificationEmailClickedLinkScalarWhereInput = {
    AND?: NotificationEmailClickedLinkScalarWhereInput | NotificationEmailClickedLinkScalarWhereInput[]
    OR?: NotificationEmailClickedLinkScalarWhereInput[]
    NOT?: NotificationEmailClickedLinkScalarWhereInput | NotificationEmailClickedLinkScalarWhereInput[]
    id?: StringFilter<"NotificationEmailClickedLink"> | string
    notificationEmailId?: StringNullableFilter<"NotificationEmailClickedLink"> | string | null
    url?: StringFilter<"NotificationEmailClickedLink"> | string
    clickedAt?: DateTimeFilter<"NotificationEmailClickedLink"> | Date | string
    clickedBy?: StringNullableFilter<"NotificationEmailClickedLink"> | string | null
  }

  export type EmailCreateWithoutClickedLinksInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    newsLetterOwnerId: string
    messageId?: string | null
    elements?: EmailElementCreateNestedManyWithoutEmailInput
    user: UserCreateNestedOneWithoutEmailsInput
    campaign?: CampaignCreateNestedOneWithoutEmailsInput
    emailAttachments?: EmailAttachmentCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientCreateNestedManyWithoutEmailInput
    template?: EmailTemplateCreateNestedOneWithoutEmailsInput
    emailAnalytics?: EmailAnalyticsCreateNestedOneWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutClickedLinksInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    newsLetterOwnerId: string
    campaignId?: string | null
    messageId?: string | null
    elements?: EmailElementUncheckedCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientUncheckedCreateNestedManyWithoutEmailInput
    emailAnalytics?: EmailAnalyticsUncheckedCreateNestedOneWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutClickedLinksInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutClickedLinksInput, EmailUncheckedCreateWithoutClickedLinksInput>
  }

  export type EmailUpsertWithoutClickedLinksInput = {
    update: XOR<EmailUpdateWithoutClickedLinksInput, EmailUncheckedUpdateWithoutClickedLinksInput>
    create: XOR<EmailCreateWithoutClickedLinksInput, EmailUncheckedCreateWithoutClickedLinksInput>
    where?: EmailWhereInput
  }

  export type EmailUpdateToOneWithWhereWithoutClickedLinksInput = {
    where?: EmailWhereInput
    data: XOR<EmailUpdateWithoutClickedLinksInput, EmailUncheckedUpdateWithoutClickedLinksInput>
  }

  export type EmailUpdateWithoutClickedLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUpdateManyWithoutEmailNestedInput
    user?: UserUpdateOneRequiredWithoutEmailsNestedInput
    campaign?: CampaignUpdateOneWithoutEmailsNestedInput
    emailAttachments?: EmailAttachmentUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUpdateManyWithoutEmailNestedInput
    template?: EmailTemplateUpdateOneWithoutEmailsNestedInput
    emailAnalytics?: EmailAnalyticsUpdateOneWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutClickedLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUncheckedUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUncheckedUpdateManyWithoutEmailNestedInput
    emailAnalytics?: EmailAnalyticsUncheckedUpdateOneWithoutEmailNestedInput
  }

  export type EmailNotificationCreateWithoutNotificationEmailClickedLinkInput = {
    id?: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    title: string
    content: JsonNullValueInput | InputJsonValue
    textContent?: string | null
    htmlContent?: string | null
    status?: $Enums.NotificationStatus
    priority?: $Enums.NotificationPriority
    emailsSentCount?: number | null
    openCount?: number | null
    clickCount?: number | null
    recipients?: number | null
    bounceCount?: number | null
    openedByEmails?: EmailNotificationCreateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationCreateclickedByEmailsInput | string[]
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    user: UserCreateNestedOneWithoutNotificationEmailsInput
  }

  export type EmailNotificationUncheckedCreateWithoutNotificationEmailClickedLinkInput = {
    id?: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    title: string
    content: JsonNullValueInput | InputJsonValue
    textContent?: string | null
    htmlContent?: string | null
    status?: $Enums.NotificationStatus
    priority?: $Enums.NotificationPriority
    userId: string
    emailsSentCount?: number | null
    openCount?: number | null
    clickCount?: number | null
    recipients?: number | null
    bounceCount?: number | null
    openedByEmails?: EmailNotificationCreateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationCreateclickedByEmailsInput | string[]
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
  }

  export type EmailNotificationCreateOrConnectWithoutNotificationEmailClickedLinkInput = {
    where: EmailNotificationWhereUniqueInput
    create: XOR<EmailNotificationCreateWithoutNotificationEmailClickedLinkInput, EmailNotificationUncheckedCreateWithoutNotificationEmailClickedLinkInput>
  }

  export type EmailNotificationUpsertWithoutNotificationEmailClickedLinkInput = {
    update: XOR<EmailNotificationUpdateWithoutNotificationEmailClickedLinkInput, EmailNotificationUncheckedUpdateWithoutNotificationEmailClickedLinkInput>
    create: XOR<EmailNotificationCreateWithoutNotificationEmailClickedLinkInput, EmailNotificationUncheckedCreateWithoutNotificationEmailClickedLinkInput>
    where?: EmailNotificationWhereInput
  }

  export type EmailNotificationUpdateToOneWithWhereWithoutNotificationEmailClickedLinkInput = {
    where?: EmailNotificationWhereInput
    data: XOR<EmailNotificationUpdateWithoutNotificationEmailClickedLinkInput, EmailNotificationUncheckedUpdateWithoutNotificationEmailClickedLinkInput>
  }

  export type EmailNotificationUpdateWithoutNotificationEmailClickedLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    emailsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    openCount?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    bounceCount?: NullableIntFieldUpdateOperationsInput | number | null
    openedByEmails?: EmailNotificationUpdateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationUpdateclickedByEmailsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutNotificationEmailsNestedInput
  }

  export type EmailNotificationUncheckedUpdateWithoutNotificationEmailClickedLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    userId?: StringFieldUpdateOperationsInput | string
    emailsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    openCount?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    bounceCount?: NullableIntFieldUpdateOperationsInput | number | null
    openedByEmails?: EmailNotificationUpdateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationUpdateclickedByEmailsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailElementCreateWithoutEmailInput = {
    id?: string
    elementId: string
    type: $Enums.ElementType
    content?: string | null
    properties: JsonNullValueInput | InputJsonValue
    sortOrder: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailElementUncheckedCreateWithoutEmailInput = {
    id?: string
    elementId: string
    type: $Enums.ElementType
    content?: string | null
    properties: JsonNullValueInput | InputJsonValue
    sortOrder: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailElementCreateOrConnectWithoutEmailInput = {
    where: EmailElementWhereUniqueInput
    create: XOR<EmailElementCreateWithoutEmailInput, EmailElementUncheckedCreateWithoutEmailInput>
  }

  export type EmailElementCreateManyEmailInputEnvelope = {
    data: EmailElementCreateManyEmailInput | EmailElementCreateManyEmailInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutEmailsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
    template?: EmailTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailsInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
    template?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
  }

  export type CampaignCreateWithoutEmailsInput = {
    id?: string
    name: string
    userId: string
    description?: string | null
    type?: string | null
    status?: $Enums.CampaignStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    emailsSent?: number
    recipients?: number | null
    openRate?: number | null
    clickRate?: number | null
    lastSentAt?: Date | string | null
  }

  export type CampaignUncheckedCreateWithoutEmailsInput = {
    id?: string
    name: string
    userId: string
    description?: string | null
    type?: string | null
    status?: $Enums.CampaignStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    emailsSent?: number
    recipients?: number | null
    openRate?: number | null
    clickRate?: number | null
    lastSentAt?: Date | string | null
  }

  export type CampaignCreateOrConnectWithoutEmailsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutEmailsInput, CampaignUncheckedCreateWithoutEmailsInput>
  }

  export type ClickedLinkCreateWithoutEmailInput = {
    id?: string
    url: string
    clickedAt?: Date | string
    clickedBy?: string | null
  }

  export type ClickedLinkUncheckedCreateWithoutEmailInput = {
    id?: string
    url: string
    clickedAt?: Date | string
    clickedBy?: string | null
  }

  export type ClickedLinkCreateOrConnectWithoutEmailInput = {
    where: ClickedLinkWhereUniqueInput
    create: XOR<ClickedLinkCreateWithoutEmailInput, ClickedLinkUncheckedCreateWithoutEmailInput>
  }

  export type ClickedLinkCreateManyEmailInputEnvelope = {
    data: ClickedLinkCreateManyEmailInput | ClickedLinkCreateManyEmailInput[]
    skipDuplicates?: boolean
  }

  export type EmailAttachmentCreateWithoutEmailInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
  }

  export type EmailAttachmentUncheckedCreateWithoutEmailInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
  }

  export type EmailAttachmentCreateOrConnectWithoutEmailInput = {
    where: EmailAttachmentWhereUniqueInput
    create: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput>
  }

  export type EmailAttachmentCreateManyEmailInputEnvelope = {
    data: EmailAttachmentCreateManyEmailInput | EmailAttachmentCreateManyEmailInput[]
    skipDuplicates?: boolean
  }

  export type EmailRecipientCreateWithoutEmailInput = {
    id?: string
    recipientEmail: string
    status?: $Enums.RecipientStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    bouncedAt?: Date | string | null
    bounceReason?: string | null
    unsubscribeAt?: Date | string | null
  }

  export type EmailRecipientUncheckedCreateWithoutEmailInput = {
    id?: string
    recipientEmail: string
    status?: $Enums.RecipientStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    bouncedAt?: Date | string | null
    bounceReason?: string | null
    unsubscribeAt?: Date | string | null
  }

  export type EmailRecipientCreateOrConnectWithoutEmailInput = {
    where: EmailRecipientWhereUniqueInput
    create: XOR<EmailRecipientCreateWithoutEmailInput, EmailRecipientUncheckedCreateWithoutEmailInput>
  }

  export type EmailRecipientCreateManyEmailInputEnvelope = {
    data: EmailRecipientCreateManyEmailInput | EmailRecipientCreateManyEmailInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateCreateWithoutEmailsInput = {
    id?: string
    name: string
    description?: string | null
    thumbnail?: string | null
    category: string
    tags?: EmailTemplateCreatetagsInput | string[]
    elements: JsonNullValueInput | InputJsonValue
    subject: string
    isPublic?: boolean
    isFeatured?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutEmailsInput = {
    id?: string
    name: string
    description?: string | null
    thumbnail?: string | null
    category: string
    tags?: EmailTemplateCreatetagsInput | string[]
    elements: JsonNullValueInput | InputJsonValue
    subject: string
    isPublic?: boolean
    isFeatured?: boolean
    usageCount?: number
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateCreateOrConnectWithoutEmailsInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutEmailsInput, EmailTemplateUncheckedCreateWithoutEmailsInput>
  }

  export type EmailAnalyticsCreateWithoutEmailInput = {
    id?: string
    totalOpens?: number
    deliveredCount?: number
    totalRecipients?: number
    uniqueOpens?: number
    totalClicks?: number
    uniqueClicks?: number
    deliveryRate?: number
    openRate?: number
    clickRate?: number
    bounceRate?: number
    unsubscribeCount?: number
    spamReportCount?: number
    forwardCount?: number
    deviceBreakdown?: NullableJsonNullValueInput | InputJsonValue
    locationData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailAnalyticsUncheckedCreateWithoutEmailInput = {
    id?: string
    totalOpens?: number
    deliveredCount?: number
    totalRecipients?: number
    uniqueOpens?: number
    totalClicks?: number
    uniqueClicks?: number
    deliveryRate?: number
    openRate?: number
    clickRate?: number
    bounceRate?: number
    unsubscribeCount?: number
    spamReportCount?: number
    forwardCount?: number
    deviceBreakdown?: NullableJsonNullValueInput | InputJsonValue
    locationData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailAnalyticsCreateOrConnectWithoutEmailInput = {
    where: EmailAnalyticsWhereUniqueInput
    create: XOR<EmailAnalyticsCreateWithoutEmailInput, EmailAnalyticsUncheckedCreateWithoutEmailInput>
  }

  export type EmailElementUpsertWithWhereUniqueWithoutEmailInput = {
    where: EmailElementWhereUniqueInput
    update: XOR<EmailElementUpdateWithoutEmailInput, EmailElementUncheckedUpdateWithoutEmailInput>
    create: XOR<EmailElementCreateWithoutEmailInput, EmailElementUncheckedCreateWithoutEmailInput>
  }

  export type EmailElementUpdateWithWhereUniqueWithoutEmailInput = {
    where: EmailElementWhereUniqueInput
    data: XOR<EmailElementUpdateWithoutEmailInput, EmailElementUncheckedUpdateWithoutEmailInput>
  }

  export type EmailElementUpdateManyWithWhereWithoutEmailInput = {
    where: EmailElementScalarWhereInput
    data: XOR<EmailElementUpdateManyMutationInput, EmailElementUncheckedUpdateManyWithoutEmailInput>
  }

  export type EmailElementScalarWhereInput = {
    AND?: EmailElementScalarWhereInput | EmailElementScalarWhereInput[]
    OR?: EmailElementScalarWhereInput[]
    NOT?: EmailElementScalarWhereInput | EmailElementScalarWhereInput[]
    id?: StringFilter<"EmailElement"> | string
    emailId?: StringFilter<"EmailElement"> | string
    elementId?: StringFilter<"EmailElement"> | string
    type?: EnumElementTypeFilter<"EmailElement"> | $Enums.ElementType
    content?: StringNullableFilter<"EmailElement"> | string | null
    properties?: JsonFilter<"EmailElement">
    sortOrder?: IntFilter<"EmailElement"> | number
    createdAt?: DateTimeFilter<"EmailElement"> | Date | string
    updatedAt?: DateTimeFilter<"EmailElement"> | Date | string
  }

  export type UserUpsertWithoutEmailsInput = {
    update: XOR<UserUpdateWithoutEmailsInput, UserUncheckedUpdateWithoutEmailsInput>
    create: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailsInput, UserUncheckedUpdateWithoutEmailsInput>
  }

  export type UserUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
    template?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignUpsertWithoutEmailsInput = {
    update: XOR<CampaignUpdateWithoutEmailsInput, CampaignUncheckedUpdateWithoutEmailsInput>
    create: XOR<CampaignCreateWithoutEmailsInput, CampaignUncheckedCreateWithoutEmailsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutEmailsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutEmailsInput, CampaignUncheckedUpdateWithoutEmailsInput>
  }

  export type CampaignUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    openRate?: NullableFloatFieldUpdateOperationsInput | number | null
    clickRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    openRate?: NullableFloatFieldUpdateOperationsInput | number | null
    clickRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClickedLinkUpsertWithWhereUniqueWithoutEmailInput = {
    where: ClickedLinkWhereUniqueInput
    update: XOR<ClickedLinkUpdateWithoutEmailInput, ClickedLinkUncheckedUpdateWithoutEmailInput>
    create: XOR<ClickedLinkCreateWithoutEmailInput, ClickedLinkUncheckedCreateWithoutEmailInput>
  }

  export type ClickedLinkUpdateWithWhereUniqueWithoutEmailInput = {
    where: ClickedLinkWhereUniqueInput
    data: XOR<ClickedLinkUpdateWithoutEmailInput, ClickedLinkUncheckedUpdateWithoutEmailInput>
  }

  export type ClickedLinkUpdateManyWithWhereWithoutEmailInput = {
    where: ClickedLinkScalarWhereInput
    data: XOR<ClickedLinkUpdateManyMutationInput, ClickedLinkUncheckedUpdateManyWithoutEmailInput>
  }

  export type ClickedLinkScalarWhereInput = {
    AND?: ClickedLinkScalarWhereInput | ClickedLinkScalarWhereInput[]
    OR?: ClickedLinkScalarWhereInput[]
    NOT?: ClickedLinkScalarWhereInput | ClickedLinkScalarWhereInput[]
    id?: StringFilter<"ClickedLink"> | string
    emailId?: StringFilter<"ClickedLink"> | string
    url?: StringFilter<"ClickedLink"> | string
    clickedAt?: DateTimeFilter<"ClickedLink"> | Date | string
    clickedBy?: StringNullableFilter<"ClickedLink"> | string | null
  }

  export type EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput = {
    where: EmailAttachmentWhereUniqueInput
    update: XOR<EmailAttachmentUpdateWithoutEmailInput, EmailAttachmentUncheckedUpdateWithoutEmailInput>
    create: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput>
  }

  export type EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput = {
    where: EmailAttachmentWhereUniqueInput
    data: XOR<EmailAttachmentUpdateWithoutEmailInput, EmailAttachmentUncheckedUpdateWithoutEmailInput>
  }

  export type EmailAttachmentUpdateManyWithWhereWithoutEmailInput = {
    where: EmailAttachmentScalarWhereInput
    data: XOR<EmailAttachmentUpdateManyMutationInput, EmailAttachmentUncheckedUpdateManyWithoutEmailInput>
  }

  export type EmailAttachmentScalarWhereInput = {
    AND?: EmailAttachmentScalarWhereInput | EmailAttachmentScalarWhereInput[]
    OR?: EmailAttachmentScalarWhereInput[]
    NOT?: EmailAttachmentScalarWhereInput | EmailAttachmentScalarWhereInput[]
    id?: StringFilter<"EmailAttachment"> | string
    emailId?: StringFilter<"EmailAttachment"> | string
    filename?: StringFilter<"EmailAttachment"> | string
    fileSize?: IntFilter<"EmailAttachment"> | number
    mimeType?: StringFilter<"EmailAttachment"> | string
    url?: StringFilter<"EmailAttachment"> | string
    createdAt?: DateTimeFilter<"EmailAttachment"> | Date | string
  }

  export type EmailRecipientUpsertWithWhereUniqueWithoutEmailInput = {
    where: EmailRecipientWhereUniqueInput
    update: XOR<EmailRecipientUpdateWithoutEmailInput, EmailRecipientUncheckedUpdateWithoutEmailInput>
    create: XOR<EmailRecipientCreateWithoutEmailInput, EmailRecipientUncheckedCreateWithoutEmailInput>
  }

  export type EmailRecipientUpdateWithWhereUniqueWithoutEmailInput = {
    where: EmailRecipientWhereUniqueInput
    data: XOR<EmailRecipientUpdateWithoutEmailInput, EmailRecipientUncheckedUpdateWithoutEmailInput>
  }

  export type EmailRecipientUpdateManyWithWhereWithoutEmailInput = {
    where: EmailRecipientScalarWhereInput
    data: XOR<EmailRecipientUpdateManyMutationInput, EmailRecipientUncheckedUpdateManyWithoutEmailInput>
  }

  export type EmailRecipientScalarWhereInput = {
    AND?: EmailRecipientScalarWhereInput | EmailRecipientScalarWhereInput[]
    OR?: EmailRecipientScalarWhereInput[]
    NOT?: EmailRecipientScalarWhereInput | EmailRecipientScalarWhereInput[]
    id?: StringFilter<"EmailRecipient"> | string
    emailId?: StringFilter<"EmailRecipient"> | string
    recipientEmail?: StringFilter<"EmailRecipient"> | string
    status?: EnumRecipientStatusFilter<"EmailRecipient"> | $Enums.RecipientStatus
    sentAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    bouncedAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
    bounceReason?: StringNullableFilter<"EmailRecipient"> | string | null
    unsubscribeAt?: DateTimeNullableFilter<"EmailRecipient"> | Date | string | null
  }

  export type EmailTemplateUpsertWithoutEmailsInput = {
    update: XOR<EmailTemplateUpdateWithoutEmailsInput, EmailTemplateUncheckedUpdateWithoutEmailsInput>
    create: XOR<EmailTemplateCreateWithoutEmailsInput, EmailTemplateUncheckedCreateWithoutEmailsInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutEmailsInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutEmailsInput, EmailTemplateUncheckedUpdateWithoutEmailsInput>
  }

  export type EmailTemplateUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: EmailTemplateUpdatetagsInput | string[]
    elements?: JsonNullValueInput | InputJsonValue
    subject?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: EmailTemplateUpdatetagsInput | string[]
    elements?: JsonNullValueInput | InputJsonValue
    subject?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAnalyticsUpsertWithoutEmailInput = {
    update: XOR<EmailAnalyticsUpdateWithoutEmailInput, EmailAnalyticsUncheckedUpdateWithoutEmailInput>
    create: XOR<EmailAnalyticsCreateWithoutEmailInput, EmailAnalyticsUncheckedCreateWithoutEmailInput>
    where?: EmailAnalyticsWhereInput
  }

  export type EmailAnalyticsUpdateToOneWithWhereWithoutEmailInput = {
    where?: EmailAnalyticsWhereInput
    data: XOR<EmailAnalyticsUpdateWithoutEmailInput, EmailAnalyticsUncheckedUpdateWithoutEmailInput>
  }

  export type EmailAnalyticsUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOpens?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    totalRecipients?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    deliveryRate?: FloatFieldUpdateOperationsInput | number
    openRate?: FloatFieldUpdateOperationsInput | number
    clickRate?: FloatFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    unsubscribeCount?: IntFieldUpdateOperationsInput | number
    spamReportCount?: IntFieldUpdateOperationsInput | number
    forwardCount?: IntFieldUpdateOperationsInput | number
    deviceBreakdown?: NullableJsonNullValueInput | InputJsonValue
    locationData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailAnalyticsUncheckedUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOpens?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    totalRecipients?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    deliveryRate?: FloatFieldUpdateOperationsInput | number
    openRate?: FloatFieldUpdateOperationsInput | number
    clickRate?: FloatFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    unsubscribeCount?: IntFieldUpdateOperationsInput | number
    spamReportCount?: IntFieldUpdateOperationsInput | number
    forwardCount?: IntFieldUpdateOperationsInput | number
    deviceBreakdown?: NullableJsonNullValueInput | InputJsonValue
    locationData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailCreateWithoutElementsInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    newsLetterOwnerId: string
    messageId?: string | null
    user: UserCreateNestedOneWithoutEmailsInput
    campaign?: CampaignCreateNestedOneWithoutEmailsInput
    clickedLinks?: ClickedLinkCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientCreateNestedManyWithoutEmailInput
    template?: EmailTemplateCreateNestedOneWithoutEmailsInput
    emailAnalytics?: EmailAnalyticsCreateNestedOneWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutElementsInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    newsLetterOwnerId: string
    campaignId?: string | null
    messageId?: string | null
    clickedLinks?: ClickedLinkUncheckedCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientUncheckedCreateNestedManyWithoutEmailInput
    emailAnalytics?: EmailAnalyticsUncheckedCreateNestedOneWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutElementsInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutElementsInput, EmailUncheckedCreateWithoutElementsInput>
  }

  export type EmailUpsertWithoutElementsInput = {
    update: XOR<EmailUpdateWithoutElementsInput, EmailUncheckedUpdateWithoutElementsInput>
    create: XOR<EmailCreateWithoutElementsInput, EmailUncheckedCreateWithoutElementsInput>
    where?: EmailWhereInput
  }

  export type EmailUpdateToOneWithWhereWithoutElementsInput = {
    where?: EmailWhereInput
    data: XOR<EmailUpdateWithoutElementsInput, EmailUncheckedUpdateWithoutElementsInput>
  }

  export type EmailUpdateWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutEmailsNestedInput
    campaign?: CampaignUpdateOneWithoutEmailsNestedInput
    clickedLinks?: ClickedLinkUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUpdateManyWithoutEmailNestedInput
    template?: EmailTemplateUpdateOneWithoutEmailsNestedInput
    emailAnalytics?: EmailAnalyticsUpdateOneWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    clickedLinks?: ClickedLinkUncheckedUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUncheckedUpdateManyWithoutEmailNestedInput
    emailAnalytics?: EmailAnalyticsUncheckedUpdateOneWithoutEmailNestedInput
  }

  export type UserCreateWithoutTemplateInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewCreateNestedManyWithoutUserInput
    emails?: EmailCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    kyc?: KycCreateNestedOneWithoutUserInput
    usage?: MembershipUsageCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTemplateInput = {
    id?: string
    userId: string
    email: string
    fullName: string
    userName: string
    password: string
    imageUrl?: string | null
    paystackCustomerId?: string | null
    paystackSubscriptionId?: string | null
    plan?: $Enums.Plan
    role?: $Enums.Role
    subscriptionStatus?: $Enums.PlanSubscriptionStatus
    accType?: $Enums.AccountType
    currentPeriodEnd?: Date | string | null
    organization?: string | null
    website?: string | null
    kycStatus?: $Enums.KYCStatus
    SenderName?: string | null
    amount?: number
    currency?: string
    lastPaymentDate?: Date | string | null
    nextPaymentDate?: Date | string | null
    successfulPayments?: number
    failedAttempts?: number
    subscriberLimit?: number
    emailLimit?: number
    blogPostLimit?: number
    aiGenerationLimit?: number
    termsAndConditionsAccepted?: boolean
    approvedKYC?: boolean
    isEmailVerified?: boolean
    isLoggedIn?: boolean
    is2FAEnabled?: boolean
    createdAt?: Date | string
    loggedInAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedCreateNestedManyWithoutUserInput
    blogComments?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    postViews?: BlogPostViewUncheckedCreateNestedManyWithoutUserInput
    emails?: EmailUncheckedCreateNestedManyWithoutUserInput
    flagedPosts?: FlagedBlogPostUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    kyc?: KycUncheckedCreateNestedOneWithoutUserInput
    usage?: MembershipUsageUncheckedCreateNestedManyWithoutUserInput
    notificationEmails?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    reportedComments?: ReportedCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTemplateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTemplateInput, UserUncheckedCreateWithoutTemplateInput>
  }

  export type EmailCreateWithoutTemplateInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    newsLetterOwnerId: string
    messageId?: string | null
    elements?: EmailElementCreateNestedManyWithoutEmailInput
    user: UserCreateNestedOneWithoutEmailsInput
    campaign?: CampaignCreateNestedOneWithoutEmailsInput
    clickedLinks?: ClickedLinkCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientCreateNestedManyWithoutEmailInput
    emailAnalytics?: EmailAnalyticsCreateNestedOneWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutTemplateInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    newsLetterOwnerId: string
    campaignId?: string | null
    messageId?: string | null
    elements?: EmailElementUncheckedCreateNestedManyWithoutEmailInput
    clickedLinks?: ClickedLinkUncheckedCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientUncheckedCreateNestedManyWithoutEmailInput
    emailAnalytics?: EmailAnalyticsUncheckedCreateNestedOneWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutTemplateInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutTemplateInput, EmailUncheckedCreateWithoutTemplateInput>
  }

  export type EmailCreateManyTemplateInputEnvelope = {
    data: EmailCreateManyTemplateInput | EmailCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTemplateInput = {
    update: XOR<UserUpdateWithoutTemplateInput, UserUncheckedUpdateWithoutTemplateInput>
    create: XOR<UserCreateWithoutTemplateInput, UserUncheckedCreateWithoutTemplateInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTemplateInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTemplateInput, UserUncheckedUpdateWithoutTemplateInput>
  }

  export type UserUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUpdateManyWithoutUserNestedInput
    emails?: EmailUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    kyc?: KycUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    subscriptionStatus?: EnumPlanSubscriptionStatusFieldUpdateOperationsInput | $Enums.PlanSubscriptionStatus
    accType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successfulPayments?: IntFieldUpdateOperationsInput | number
    failedAttempts?: IntFieldUpdateOperationsInput | number
    subscriberLimit?: IntFieldUpdateOperationsInput | number
    emailLimit?: IntFieldUpdateOperationsInput | number
    blogPostLimit?: IntFieldUpdateOperationsInput | number
    aiGenerationLimit?: IntFieldUpdateOperationsInput | number
    termsAndConditionsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approvedKYC?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    is2FAEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loggedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    aIContentGenerationToExcerpt?: BlogAIGenerationUncheckedUpdateManyWithoutUserNestedInput
    blogComments?: BlogCommentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    postViews?: BlogPostViewUncheckedUpdateManyWithoutUserNestedInput
    emails?: EmailUncheckedUpdateManyWithoutUserNestedInput
    flagedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KycUncheckedUpdateOneWithoutUserNestedInput
    usage?: MembershipUsageUncheckedUpdateManyWithoutUserNestedInput
    notificationEmails?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailUpsertWithWhereUniqueWithoutTemplateInput = {
    where: EmailWhereUniqueInput
    update: XOR<EmailUpdateWithoutTemplateInput, EmailUncheckedUpdateWithoutTemplateInput>
    create: XOR<EmailCreateWithoutTemplateInput, EmailUncheckedCreateWithoutTemplateInput>
  }

  export type EmailUpdateWithWhereUniqueWithoutTemplateInput = {
    where: EmailWhereUniqueInput
    data: XOR<EmailUpdateWithoutTemplateInput, EmailUncheckedUpdateWithoutTemplateInput>
  }

  export type EmailUpdateManyWithWhereWithoutTemplateInput = {
    where: EmailScalarWhereInput
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyWithoutTemplateInput>
  }

  export type EmailCreateWithoutEmailAttachmentsInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    newsLetterOwnerId: string
    messageId?: string | null
    elements?: EmailElementCreateNestedManyWithoutEmailInput
    user: UserCreateNestedOneWithoutEmailsInput
    campaign?: CampaignCreateNestedOneWithoutEmailsInput
    clickedLinks?: ClickedLinkCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientCreateNestedManyWithoutEmailInput
    template?: EmailTemplateCreateNestedOneWithoutEmailsInput
    emailAnalytics?: EmailAnalyticsCreateNestedOneWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutEmailAttachmentsInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    newsLetterOwnerId: string
    campaignId?: string | null
    messageId?: string | null
    elements?: EmailElementUncheckedCreateNestedManyWithoutEmailInput
    clickedLinks?: ClickedLinkUncheckedCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientUncheckedCreateNestedManyWithoutEmailInput
    emailAnalytics?: EmailAnalyticsUncheckedCreateNestedOneWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutEmailAttachmentsInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutEmailAttachmentsInput, EmailUncheckedCreateWithoutEmailAttachmentsInput>
  }

  export type EmailUpsertWithoutEmailAttachmentsInput = {
    update: XOR<EmailUpdateWithoutEmailAttachmentsInput, EmailUncheckedUpdateWithoutEmailAttachmentsInput>
    create: XOR<EmailCreateWithoutEmailAttachmentsInput, EmailUncheckedCreateWithoutEmailAttachmentsInput>
    where?: EmailWhereInput
  }

  export type EmailUpdateToOneWithWhereWithoutEmailAttachmentsInput = {
    where?: EmailWhereInput
    data: XOR<EmailUpdateWithoutEmailAttachmentsInput, EmailUncheckedUpdateWithoutEmailAttachmentsInput>
  }

  export type EmailUpdateWithoutEmailAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUpdateManyWithoutEmailNestedInput
    user?: UserUpdateOneRequiredWithoutEmailsNestedInput
    campaign?: CampaignUpdateOneWithoutEmailsNestedInput
    clickedLinks?: ClickedLinkUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUpdateManyWithoutEmailNestedInput
    template?: EmailTemplateUpdateOneWithoutEmailsNestedInput
    emailAnalytics?: EmailAnalyticsUpdateOneWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutEmailAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUncheckedUpdateManyWithoutEmailNestedInput
    clickedLinks?: ClickedLinkUncheckedUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUncheckedUpdateManyWithoutEmailNestedInput
    emailAnalytics?: EmailAnalyticsUncheckedUpdateOneWithoutEmailNestedInput
  }

  export type EmailCreateWithoutEmailRecipientsInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    newsLetterOwnerId: string
    messageId?: string | null
    elements?: EmailElementCreateNestedManyWithoutEmailInput
    user: UserCreateNestedOneWithoutEmailsInput
    campaign?: CampaignCreateNestedOneWithoutEmailsInput
    clickedLinks?: ClickedLinkCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentCreateNestedManyWithoutEmailInput
    template?: EmailTemplateCreateNestedOneWithoutEmailsInput
    emailAnalytics?: EmailAnalyticsCreateNestedOneWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutEmailRecipientsInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    newsLetterOwnerId: string
    campaignId?: string | null
    messageId?: string | null
    elements?: EmailElementUncheckedCreateNestedManyWithoutEmailInput
    clickedLinks?: ClickedLinkUncheckedCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput
    emailAnalytics?: EmailAnalyticsUncheckedCreateNestedOneWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutEmailRecipientsInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutEmailRecipientsInput, EmailUncheckedCreateWithoutEmailRecipientsInput>
  }

  export type EmailUpsertWithoutEmailRecipientsInput = {
    update: XOR<EmailUpdateWithoutEmailRecipientsInput, EmailUncheckedUpdateWithoutEmailRecipientsInput>
    create: XOR<EmailCreateWithoutEmailRecipientsInput, EmailUncheckedCreateWithoutEmailRecipientsInput>
    where?: EmailWhereInput
  }

  export type EmailUpdateToOneWithWhereWithoutEmailRecipientsInput = {
    where?: EmailWhereInput
    data: XOR<EmailUpdateWithoutEmailRecipientsInput, EmailUncheckedUpdateWithoutEmailRecipientsInput>
  }

  export type EmailUpdateWithoutEmailRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUpdateManyWithoutEmailNestedInput
    user?: UserUpdateOneRequiredWithoutEmailsNestedInput
    campaign?: CampaignUpdateOneWithoutEmailsNestedInput
    clickedLinks?: ClickedLinkUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUpdateManyWithoutEmailNestedInput
    template?: EmailTemplateUpdateOneWithoutEmailsNestedInput
    emailAnalytics?: EmailAnalyticsUpdateOneWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutEmailRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUncheckedUpdateManyWithoutEmailNestedInput
    clickedLinks?: ClickedLinkUncheckedUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput
    emailAnalytics?: EmailAnalyticsUncheckedUpdateOneWithoutEmailNestedInput
  }

  export type EmailCreateWithoutEmailAnalyticsInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    newsLetterOwnerId: string
    messageId?: string | null
    elements?: EmailElementCreateNestedManyWithoutEmailInput
    user: UserCreateNestedOneWithoutEmailsInput
    campaign?: CampaignCreateNestedOneWithoutEmailsInput
    clickedLinks?: ClickedLinkCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientCreateNestedManyWithoutEmailInput
    template?: EmailTemplateCreateNestedOneWithoutEmailsInput
  }

  export type EmailUncheckedCreateWithoutEmailAnalyticsInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    newsLetterOwnerId: string
    campaignId?: string | null
    messageId?: string | null
    elements?: EmailElementUncheckedCreateNestedManyWithoutEmailInput
    clickedLinks?: ClickedLinkUncheckedCreateNestedManyWithoutEmailInput
    emailAttachments?: EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput
    emailRecipients?: EmailRecipientUncheckedCreateNestedManyWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutEmailAnalyticsInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutEmailAnalyticsInput, EmailUncheckedCreateWithoutEmailAnalyticsInput>
  }

  export type EmailUpsertWithoutEmailAnalyticsInput = {
    update: XOR<EmailUpdateWithoutEmailAnalyticsInput, EmailUncheckedUpdateWithoutEmailAnalyticsInput>
    create: XOR<EmailCreateWithoutEmailAnalyticsInput, EmailUncheckedCreateWithoutEmailAnalyticsInput>
    where?: EmailWhereInput
  }

  export type EmailUpdateToOneWithWhereWithoutEmailAnalyticsInput = {
    where?: EmailWhereInput
    data: XOR<EmailUpdateWithoutEmailAnalyticsInput, EmailUncheckedUpdateWithoutEmailAnalyticsInput>
  }

  export type EmailUpdateWithoutEmailAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUpdateManyWithoutEmailNestedInput
    user?: UserUpdateOneRequiredWithoutEmailsNestedInput
    campaign?: CampaignUpdateOneWithoutEmailsNestedInput
    clickedLinks?: ClickedLinkUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUpdateManyWithoutEmailNestedInput
    template?: EmailTemplateUpdateOneWithoutEmailsNestedInput
  }

  export type EmailUncheckedUpdateWithoutEmailAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUncheckedUpdateManyWithoutEmailNestedInput
    clickedLinks?: ClickedLinkUncheckedUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUncheckedUpdateManyWithoutEmailNestedInput
  }

  export type ApiKeyCreateManyUserInput = {
    id?: string
    keyHash: string
    jwt: string
    createdAt?: Date | string
    isTrial?: boolean
    expiresAt: Date | string
  }

  export type BlogAIGenerationCreateManyUserInput = {
    id?: string
    prompt: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIGenerationStatus
    output: string
    format?: $Enums.ContentFormat
    cost?: number | null
    tokensUsed?: number | null
    model?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type BlogCommentCreateManyUserInput = {
    id?: string
    content: string
    postId: string
    userId?: string | null
    parentId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateManyUserInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorBio: string
    authorTitle: string
    author: string
    categoryId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedById?: string | null
  }

  export type BlogPostViewCreateManyUserInput = {
    id?: string
    postId: string
    externalName?: string | null
    createdAt?: Date | string
  }

  export type EmailCreateManyUserInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    newsLetterOwnerId: string
    campaignId?: string | null
    messageId?: string | null
  }

  export type FlagedBlogPostCreateManyUserInput = {
    id?: string
    reason: string
    comment: string
    flaggedBy: string
    status?: $Enums.FlagStatus
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    postId: string
  }

  export type InvoiceCreateManyUserInput = {
    id?: string
    description: string
    amount: number
    status: string
    invoiceUrl: string
    date?: Date | string
    externalId?: string | null
  }

  export type MembershipUsageCreateManyUserInput = {
    id?: string
    month: string
    emailsSent?: number
    subscribersAdded?: number
    campaignsCreated?: number
    blogPostsCreated?: number
    aiGenerationsUsed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailNotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    title: string
    content: JsonNullValueInput | InputJsonValue
    textContent?: string | null
    htmlContent?: string | null
    status?: $Enums.NotificationStatus
    priority?: $Enums.NotificationPriority
    emailsSentCount?: number | null
    openCount?: number | null
    clickCount?: number | null
    recipients?: number | null
    bounceCount?: number | null
    openedByEmails?: EmailNotificationCreateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationCreateclickedByEmailsInput | string[]
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    jti: string
    hashed: string
    userAgent?: string | null
    ip?: string | null
    revoked?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type ReportedCommentCreateManyUserInput = {
    id?: string
    commentId: string
    blogSlug: string
    blogOwner: string
    parentCommentBy: string
    reason?: string | null
    reportedAt?: Date | string
    resolved?: boolean
  }

  export type EmailTemplateCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    thumbnail?: string | null
    category: string
    tags?: EmailTemplateCreatetagsInput | string[]
    elements: JsonNullValueInput | InputJsonValue
    subject: string
    isPublic?: boolean
    isFeatured?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogAIGenerationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIGenerationStatusFieldUpdateOperationsInput | $Enums.AIGenerationStatus
    output?: StringFieldUpdateOperationsInput | string
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blogPosts?: BlogPostUpdateManyWithoutAiGenerationNestedInput
  }

  export type BlogAIGenerationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIGenerationStatusFieldUpdateOperationsInput | $Enums.AIGenerationStatus
    output?: StringFieldUpdateOperationsInput | string
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAiGenerationNestedInput
  }

  export type BlogAIGenerationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIGenerationStatusFieldUpdateOperationsInput | $Enums.AIGenerationStatus
    output?: StringFieldUpdateOperationsInput | string
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlogCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: BlogCommentUpdateOneWithoutRepliesNestedInput
    replies?: BlogCommentUpdateManyWithoutParentNestedInput
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutCommentNestedInput
  }

  export type BlogCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: BlogCommentUncheckedUpdateManyWithoutParentNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type BlogCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: BlogCommentUpdateManyWithoutPostNestedInput
    category?: BlogCategoryUpdateOneWithoutPostsNestedInput
    aiGeneration?: BlogAIGenerationUpdateOneWithoutBlogPostsNestedInput
    viewsCount?: BlogPostViewUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUpdateManyWithoutPostNestedInput
    tags?: BlogTagUpdateManyWithoutPostsNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
    viewsCount?: BlogPostViewUncheckedUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutPostNestedInput
    tags?: BlogTagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlogPostViewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutViewsCountNestedInput
  }

  export type BlogPostViewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostViewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUpdateManyWithoutEmailNestedInput
    campaign?: CampaignUpdateOneWithoutEmailsNestedInput
    clickedLinks?: ClickedLinkUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUpdateManyWithoutEmailNestedInput
    template?: EmailTemplateUpdateOneWithoutEmailsNestedInput
    emailAnalytics?: EmailAnalyticsUpdateOneWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUncheckedUpdateManyWithoutEmailNestedInput
    clickedLinks?: ClickedLinkUncheckedUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUncheckedUpdateManyWithoutEmailNestedInput
    emailAnalytics?: EmailAnalyticsUncheckedUpdateOneWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlagedBlogPostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: BlogPostUpdateOneRequiredWithoutFlaggedPostsNestedInput
  }

  export type FlagedBlogPostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type FlagedBlogPostUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MembershipUsageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    subscribersAdded?: IntFieldUpdateOperationsInput | number
    campaignsCreated?: IntFieldUpdateOperationsInput | number
    blogPostsCreated?: IntFieldUpdateOperationsInput | number
    aiGenerationsUsed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUsageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    subscribersAdded?: IntFieldUpdateOperationsInput | number
    campaignsCreated?: IntFieldUpdateOperationsInput | number
    blogPostsCreated?: IntFieldUpdateOperationsInput | number
    aiGenerationsUsed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUsageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    emailsSent?: IntFieldUpdateOperationsInput | number
    subscribersAdded?: IntFieldUpdateOperationsInput | number
    campaignsCreated?: IntFieldUpdateOperationsInput | number
    blogPostsCreated?: IntFieldUpdateOperationsInput | number
    aiGenerationsUsed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    emailsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    openCount?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    bounceCount?: NullableIntFieldUpdateOperationsInput | number | null
    openedByEmails?: EmailNotificationUpdateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationUpdateclickedByEmailsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    NotificationEmailClickedLink?: NotificationEmailClickedLinkUpdateManyWithoutNotificationEmailNestedInput
  }

  export type EmailNotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    emailsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    openCount?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    bounceCount?: NullableIntFieldUpdateOperationsInput | number | null
    openedByEmails?: EmailNotificationUpdateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationUpdateclickedByEmailsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    NotificationEmailClickedLink?: NotificationEmailClickedLinkUncheckedUpdateManyWithoutNotificationEmailNestedInput
  }

  export type EmailNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    emailsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    openCount?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: NullableIntFieldUpdateOperationsInput | number | null
    bounceCount?: NullableIntFieldUpdateOperationsInput | number | null
    openedByEmails?: EmailNotificationUpdateopenedByEmailsInput | string[]
    clickedByEmails?: EmailNotificationUpdateclickedByEmailsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    hashed?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    hashed?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    hashed?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportedCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogSlug?: StringFieldUpdateOperationsInput | string
    blogOwner?: StringFieldUpdateOperationsInput | string
    parentCommentBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    comment?: BlogCommentUpdateOneRequiredWithoutReportedCommentsNestedInput
  }

  export type ReportedCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    blogSlug?: StringFieldUpdateOperationsInput | string
    blogOwner?: StringFieldUpdateOperationsInput | string
    parentCommentBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReportedCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    blogSlug?: StringFieldUpdateOperationsInput | string
    blogOwner?: StringFieldUpdateOperationsInput | string
    parentCommentBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailTemplateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: EmailTemplateUpdatetagsInput | string[]
    elements?: JsonNullValueInput | InputJsonValue
    subject?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: EmailTemplateUpdatetagsInput | string[]
    elements?: JsonNullValueInput | InputJsonValue
    subject?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: EmailTemplateUpdatetagsInput | string[]
    elements?: JsonNullValueInput | InputJsonValue
    subject?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCDocumentCreateManyKycInput = {
    id?: string
    type: string
    url: string
    key: string
    uploadedAt?: Date | string
  }

  export type KYCDocumentUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCDocumentUncheckedUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCDocumentUncheckedUpdateManyWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentCreateManyPostInput = {
    id?: string
    content: string
    authorId: string
    userId?: string | null
    parentId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostViewCreateManyPostInput = {
    id?: string
    userId?: string | null
    externalName?: string | null
    createdAt?: Date | string
  }

  export type FlagedBlogPostCreateManyPostInput = {
    id?: string
    reason: string
    comment: string
    flaggedBy: string
    status?: $Enums.FlagStatus
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    userId: string
  }

  export type BlogCommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogCommentsNestedInput
    parent?: BlogCommentUpdateOneWithoutRepliesNestedInput
    replies?: BlogCommentUpdateManyWithoutParentNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutCommentNestedInput
  }

  export type BlogCommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: BlogCommentUncheckedUpdateManyWithoutParentNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type BlogCommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostViewUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPostViewsNestedInput
  }

  export type BlogPostViewUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostViewUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagedBlogPostUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutFlagedPostsNestedInput
  }

  export type FlagedBlogPostUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FlagedBlogPostUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogTagUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateManyCategoryInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorId: string
    authorBio: string
    authorTitle: string
    author: string
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedById?: string | null
  }

  export type BlogPostUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: BlogCommentUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    aiGeneration?: BlogAIGenerationUpdateOneWithoutBlogPostsNestedInput
    viewsCount?: BlogPostViewUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUpdateManyWithoutPostNestedInput
    tags?: BlogTagUpdateManyWithoutPostsNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
    viewsCount?: BlogPostViewUncheckedUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutPostNestedInput
    tags?: BlogTagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlogPostUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: BlogCommentUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    category?: BlogCategoryUpdateOneWithoutPostsNestedInput
    aiGeneration?: BlogAIGenerationUpdateOneWithoutBlogPostsNestedInput
    viewsCount?: BlogPostViewUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
    viewsCount?: BlogPostViewUncheckedUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlogCommentCreateManyParentInput = {
    id?: string
    content: string
    authorId: string
    postId: string
    userId?: string | null
    externalName?: string | null
    externalAvatar?: string | null
    likes?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportedCommentCreateManyCommentInput = {
    id?: string
    blogSlug: string
    blogOwner: string
    parentCommentBy: string
    reportedBy: string
    reason?: string | null
    reportedAt?: Date | string
    resolved?: boolean
  }

  export type BlogCommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogCommentsNestedInput
    replies?: BlogCommentUpdateManyWithoutParentNestedInput
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
    reportedComments?: ReportedCommentUpdateManyWithoutCommentNestedInput
  }

  export type BlogCommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: BlogCommentUncheckedUpdateManyWithoutParentNestedInput
    reportedComments?: ReportedCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type BlogCommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportedCommentUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogSlug?: StringFieldUpdateOperationsInput | string
    blogOwner?: StringFieldUpdateOperationsInput | string
    parentCommentBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutReportedCommentsNestedInput
  }

  export type ReportedCommentUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogSlug?: StringFieldUpdateOperationsInput | string
    blogOwner?: StringFieldUpdateOperationsInput | string
    parentCommentBy?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReportedCommentUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogSlug?: StringFieldUpdateOperationsInput | string
    blogOwner?: StringFieldUpdateOperationsInput | string
    parentCommentBy?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogPostCreateManyAiGenerationInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    content: string
    excerpt?: string | null
    format?: $Enums.ContentFormat
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    featuredImage: string
    featuredVideo?: string | null
    galleryImages?: BlogPostCreategalleryImagesInput | string[]
    authorId: string
    authorBio: string
    authorTitle: string
    author: string
    categoryId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: BlogPostCreateseoKeywordsInput | string[]
    seoScore?: number
    shares?: number
    readTime?: number
    wordCount?: number
    characterCount?: number
    likes?: number
    views?: number
    flagReason?: string | null
    isFlagged?: boolean
    isFeatured?: boolean
    isPinned?: boolean
    allowComments?: boolean
    publishedAt?: Date | string | null
    flaggedAt?: Date | string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateWithoutAiGenerationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: BlogCommentUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    category?: BlogCategoryUpdateOneWithoutPostsNestedInput
    viewsCount?: BlogPostViewUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUpdateManyWithoutPostNestedInput
    tags?: BlogTagUpdateManyWithoutPostsNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutAiGenerationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: BlogCommentUncheckedUpdateManyWithoutPostNestedInput
    viewsCount?: BlogPostViewUncheckedUpdateManyWithoutPostNestedInput
    flaggedPosts?: FlagedBlogPostUncheckedUpdateManyWithoutPostNestedInput
    tags?: BlogTagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutAiGenerationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumContentFormatFieldUpdateOperationsInput | $Enums.ContentFormat
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    featuredImage?: StringFieldUpdateOperationsInput | string
    featuredVideo?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: BlogPostUpdategalleryImagesInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    authorBio?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: BlogPostUpdateseoKeywordsInput | string[]
    seoScore?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    characterCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isFlagged?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCreateManyCampaignInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    newsLetterOwnerId: string
    messageId?: string | null
  }

  export type EmailUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUpdateManyWithoutEmailNestedInput
    user?: UserUpdateOneRequiredWithoutEmailsNestedInput
    clickedLinks?: ClickedLinkUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUpdateManyWithoutEmailNestedInput
    template?: EmailTemplateUpdateOneWithoutEmailsNestedInput
    emailAnalytics?: EmailAnalyticsUpdateOneWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUncheckedUpdateManyWithoutEmailNestedInput
    clickedLinks?: ClickedLinkUncheckedUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUncheckedUpdateManyWithoutEmailNestedInput
    emailAnalytics?: EmailAnalyticsUncheckedUpdateOneWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationEmailClickedLinkCreateManyNotificationEmailInput = {
    id?: string
    url: string
    clickedAt?: Date | string
    clickedBy?: string | null
  }

  export type NotificationEmailClickedLinkUpdateWithoutNotificationEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationEmailClickedLinkUncheckedUpdateWithoutNotificationEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationEmailClickedLinkUncheckedUpdateManyWithoutNotificationEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailElementCreateManyEmailInput = {
    id?: string
    elementId: string
    type: $Enums.ElementType
    content?: string | null
    properties: JsonNullValueInput | InputJsonValue
    sortOrder: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClickedLinkCreateManyEmailInput = {
    id?: string
    url: string
    clickedAt?: Date | string
    clickedBy?: string | null
  }

  export type EmailAttachmentCreateManyEmailInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
  }

  export type EmailRecipientCreateManyEmailInput = {
    id?: string
    recipientEmail: string
    status?: $Enums.RecipientStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    bouncedAt?: Date | string | null
    bounceReason?: string | null
    unsubscribeAt?: Date | string | null
  }

  export type EmailElementUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailElementUncheckedUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailElementUncheckedUpdateManyWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClickedLinkUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClickedLinkUncheckedUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClickedLinkUncheckedUpdateManyWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailAttachmentUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentUncheckedUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentUncheckedUpdateManyWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailRecipientUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bouncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bounceReason?: NullableStringFieldUpdateOperationsInput | string | null
    unsubscribeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailRecipientUncheckedUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bouncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bounceReason?: NullableStringFieldUpdateOperationsInput | string | null
    unsubscribeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailRecipientUncheckedUpdateManyWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bouncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bounceReason?: NullableStringFieldUpdateOperationsInput | string | null
    unsubscribeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailCreateManyTemplateInput = {
    id?: string
    title: string
    content: string
    emailSubject: string
    previewText?: string | null
    builderMode?: string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EmailStatus
    emailType?: $Enums.EmailType
    trackOpens?: boolean
    trackClicks?: boolean
    enableUnsubscribe?: boolean
    scheduleDate?: Date | string | null
    scheduleTime?: string | null
    emailsSentCount?: number
    recipients?: number
    bounceCount?: number
    openCount?: number
    clickCount?: number
    sentAt?: Date | string | null
    lastOpened?: Date | string | null
    lastClicked?: Date | string | null
    openedByIps?: EmailCreateopenedByIpsInput | string[]
    openedByEmails?: EmailCreateopenedByEmailsInput | string[]
    clickedByIps?: EmailCreateclickedByIpsInput | string[]
    clickedByEmails?: EmailCreateclickedByEmailsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    newsLetterOwnerId: string
    campaignId?: string | null
    messageId?: string | null
  }

  export type EmailUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUpdateManyWithoutEmailNestedInput
    user?: UserUpdateOneRequiredWithoutEmailsNestedInput
    campaign?: CampaignUpdateOneWithoutEmailsNestedInput
    clickedLinks?: ClickedLinkUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUpdateManyWithoutEmailNestedInput
    emailAnalytics?: EmailAnalyticsUpdateOneWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: EmailElementUncheckedUpdateManyWithoutEmailNestedInput
    clickedLinks?: ClickedLinkUncheckedUpdateManyWithoutEmailNestedInput
    emailAttachments?: EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput
    emailRecipients?: EmailRecipientUncheckedUpdateManyWithoutEmailNestedInput
    emailAnalytics?: EmailAnalyticsUncheckedUpdateOneWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSubject?: StringFieldUpdateOperationsInput | string
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    builderMode?: StringFieldUpdateOperationsInput | string
    builderData?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    emailType?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    trackOpens?: BoolFieldUpdateOperationsInput | boolean
    trackClicks?: BoolFieldUpdateOperationsInput | boolean
    enableUnsubscribe?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleTime?: NullableStringFieldUpdateOperationsInput | string | null
    emailsSentCount?: IntFieldUpdateOperationsInput | number
    recipients?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastClicked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedByIps?: EmailUpdateopenedByIpsInput | string[]
    openedByEmails?: EmailUpdateopenedByEmailsInput | string[]
    clickedByIps?: EmailUpdateclickedByIpsInput | string[]
    clickedByEmails?: EmailUpdateclickedByEmailsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    newsLetterOwnerId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}